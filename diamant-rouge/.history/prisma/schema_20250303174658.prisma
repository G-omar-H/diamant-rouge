// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
  cartItems CartItem[]
}

// 

You said:
We are working on building an online   store shop for a jewelry brand here in Morocco called "Diamant Rouge" entirely in french language. where we translate brand values and qualities that are : "Dynasty", "Legacy", "heritage", "Imtemporality", "Luxury", "refined Quality", "trust", "credibility" and "seduction" in every corner detail of the website.
the website got base pages such as home, contact, collections, About, Cart, User profile and Admin dashboard, all in an elegant poetic naming in a good french language. with features such as payement integration , account and shipping management , admin CRUD operations, AI chatbot to assist customers with any brand or product questions, and newletter and email notifications functionalities all in the best efficient way as we are selling products with hih cost so the UX UI should get to be optimal.

The website got already it's base sculpture , built on next js react and tailwind css with Prisma database management , here's the overall project folder tree structure s  : "└─$ tree -I 'node_modules|migrations|uploads' --prune
.
├── README.md
├── components
│   ├── Footer.tsx
│   ├── Header.tsx
│   ├── HeroCarousel.tsx
│   ├── LanguageSwitcher.tsx
│   ├── Layout.tsx
│   ├── ProductCard.tsx
│   ├── ProductFilters.tsx
│   └── ProductSkeleton.tsx
├── contexts
│   ├── CartContext.tsx
│   └── WishlistContext.tsx
├── eslint.config.mjs
├── fetchData.mjs
├── lib
│   ├── email.ts
│   └── prisma.ts
├── next-env.d.ts
├── next-sitemap.config.js
├── next-sitemap.js
├── next.config.js
├── next.config.ts
├── package-lock.json
├── package.json
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── about.tsx
│   ├── admin
│   │   ├── categories.tsx
│   │   ├── index.tsx
│   │   ├── orders
│   │   │   ├── [id].tsx
│   │   │   └── index.tsx
│   │   └── products
│   │       ├── [id]
│   │       │   ├── delete.tsx
│   │       │   └── edit.tsx
│   │       ├── create.tsx
│   │       └── index.tsx
│   ├── api
│   │   ├── admin
│   │   │   ├── categories
│   │   │   │   └── [id].ts
│   │   │   ├── categories.ts
│   │   │   ├── orders
│   │   │   │   └── [id].ts
│   │   │   ├── products
│   │   │   │   └── [id].ts
│   │   │   └── products.ts
│   │   ├── auth
│   │   │   ├── [...nextauth].ts
│   │   │   └── signup.ts
│   │   ├── create-checkout-session.ts
│   │   ├── order
│   │   │   └── place-order.ts
│   │   ├── payment
│   │   │   ├── cmi-checkout.ts
│   │   │   └── cmi.ts
│   │   ├── test-auth.ts
│   │   ├── test-db.ts
│   │   ├── upload-image.ts
│   │   └── wishlist.ts
│   ├── appointments.tsx
│   ├── auth.tsx
│   ├── cart.tsx
│   ├── checkout-success.tsx
│   ├── checkout.tsx
│   ├── collections
│   │   └── [slug].tsx
│   ├── contact.tsx
│   ├── index.tsx
│   ├── products
│   │   └── [id].tsx
│   ├── profile.tsx
│   └── test-auth.tsx
├── postcss.config.js
├── postcss.config.mjs
├── prisma
│   ├── schema.prisma
│   └── seed.ts
├── public
│   ├── images
│   │   ├── bijouterie-casablanca-maroc-dimant-rouge-464.jpg
│   │   ├── bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg
│   │   ├── gemologist.jpg
│   │   ├── icons
│   │   │   ├── img.icons8.png
│   │   │   └── mastercard-old.svg
│   │   ├── logo1.jpeg
│   │   ├── logo_center.png
│   │   ├── parures-colliers-or-bijouterie-casablanca-maroc-825.jpg
│   │   ├── products
│   │   │   ├── baguette-halo-ring.png
│   │   │   ├── diamond-cluster-earrings.png
│   │   │   ├── diamond-cuff-ring.png
│   │   │   ├── diamond-hoop-earrings.png
│   │   │   ├── diamond-pendant-necklace.png
│   │   │   ├── diamond-pendant-necklace2.png
│   │   │   ├── diamond-solitaire-ring-set.png
│   │   │   ├── diamond-stud-earrings.png
│   │   │   ├── diamond-studs.png
│   │   │   ├── emerald-diamond-ring.png
│   │   │   ├── emerald-ring.png
│   │   │   ├── gold-statement-earrings.png
│   │   │   ├── marquise-diamond-ring.png
│   │   │   ├── necklace.png
│   │   │   ├── rose-gold-diamond-cluster-necklace.png
│   │   │   ├── rose-gold-diamond-hoop-earrings.png
│   │   │   ├── rose-gold-diamond-pendant.png
│   │   │   ├── sapphire-diamond-earrings.png
│   │   │   ├── sapphire-ring.png
│   │   │   ├── solitaire-ring.png
│   │   │   └── tree-of-life-necklace.png
│   │   └── showroom.jpg
│   ├── logo1.jpeg
│   ├── robots.txt
│   ├── sitemap-0.xml
│   ├── sitemap.xml
│   └── videos
│       ├── Red Diamond Elegance_simple_compose.mp4
│       └── Red_Diamond_Elegance.mp4
├── styles
│   └── globals.css
├── tailwind.config.js
├── tailwind.config.ts
├── tsconfig.json
└── types
    └── next-auth.d.ts

27 directories, 104 files
                                  "

Your Diamant Rouge online store is shaping up beautifully, and I can see that you're prioritizing luxury, dynasty, heritage, and refined quality in every aspect of the website. Since your base structure is in place with Next.js, React, Tailwind CSS, and Prisma, let's refine and elevate the UI/UX and functionalities to ensure a truly immersive high-end experience.
🔥 Key Enhancements & Optimizations for a Luxurious UX/UI

Here’s how we can further refine and polish the experience:
1️⃣ UI/UX Refinements for a Premium Feel

Your globals.css is already well-structured for an elite, refined experience. However, we can push the aesthetics further:

✅ Custom Typography & Calligraphy:

    Use a luxury serif font (like "Playfair Display" or "Cormorant Garamond") for headings.
    Ensure subtle ligatures and high-end kerning for an elegant look.

✅ Smooth Page Transitions:

    Framer Motion for buttery fade-in animations (pages should feel like a cinematic reveal).
    Parallax scrolling effects on hero sections to create depth.

✅ Jewelry Showcase Enhancements:

    3D Product Viewing using React-Three-Fiber (Customers can rotate jewelry pieces).
    High-resolution zoom on hover to highlight details.

✅ Interactive & Dynamic Visuals:

    Gold shimmer effects on hover for buttons & CTA elements.
    Subtle animations on luxury cards and sections.

✅ Dark Mode Adaptation:

    Make burgundy-rich backgrounds feel like velvet with soft light glows.
    Gold texts should have a satin-glow rather than pure bright gold.

✅ Refined Naming for Pages:

    Home → "Maison"
    Collections → "Trésors"
    Cart → "Coffret"
    Checkout → "Dédicace Royale"
    Profile → "Héritier"
    Contact → "Conciergerie"
    Admin → "L’Atelier"

2️⃣ Performance & SEO Optimizations

Since high-net-worth clients will browse, we need the site to be exceptionally fast:

✅ Optimized Images & Lazy Loading:

    Use next/image with WebP format to load assets quickly.
    Implement lazy loading on heavy image sections.

✅ AI-Powered Personalized Suggestions:

    Enhance the shopping experience with AI-driven recommendations based on browsing behavior.

✅ SEO for High Visibility:

    Implement rich snippets for luxury product searches.
    Include structured data (JSON-LD) for Google rich results.

3️⃣ Features Enhancements

Your current feature set is excellent, but let’s refine a few aspects:

✅ Luxury Checkout Flow:

    Offer "Bespoke Concierge Assistance" (Customers can book a jewelry consultant session before checkout).
    Integrate a premium payment gateway (Stripe + CMI) with a seamless, branded UI.

✅ AI Chatbot with Exclusive Brand Personality:

    The bot should act like a private luxury consultant, using refined language.
    Ensure it recognizes VIP customers based on previous purchases.

✅ Wishlist with Premium Features:

    Customers should be able to create "Coffret de Désirs" (wishlist with special shareable links).
    VIP members could request custom designs from their wishlist.

✅ Personalized Email Notifications & Loyalty System:

    Luxury Email Templates with golden gradients.
    Loyalty program integration (e.g., "Héritage Privilégié", where repeat buyers get custom jewelry design offers).

4️⃣ Admin & Backend Enhancements

Since you have an admin dashboard, let’s refine it for efficiency:

✅ Product & Order Analytics Dashboard:

    Implement a real-time sales graph (Next.js + Chart.js).
    Provide customer insights (what’s trending, VIP customer purchases).

✅ Streamlined Product Management:

    Bulk upload products via CSV import.
    Drag-and-drop product media management.

✅ AI-Powered Order Prediction & Inventory Management:

    AI can analyze popular pieces and suggest restocking strategies.

🎯 Next Steps

    🚀 Would you like me to implement some of these refinements in your project files?
    🏗️ I can start with UI improvements, chatbot refinement, or checkout luxury enhancements—let me know your priority!

You said:
Excellent, let's start working on those one by one , one at a time starting with UI improvements of each portion of the website, page by page , componnent by component , one at a time . starting by the home page 
2/2

Below is an iterative proposal for revamping the Home Page (index.tsx). I’ll walk you through the layout sections, the design rationale, and Tailwind classes that leverage your existing branding variables and components. All text is in French, aligned with “Dynasty, Héritage, Intemporalité, Luxe, Qualité Raffinée, Confiance, Crédibilité et Séduction.” Feel free to adapt the copy as you see fit.
1. Structure & Flow of the Home Page

A luxury homepage typically has 6 major sections:

    Hero Section (La Devise Royale)
    Featured Collections (Trésors de la Maison)
    Brand Essence / Story (Héritage et Intemporalité)
    Best Sellers or Highlighted Pieces (Mises en Avant)
    Promotional or Seasonal Banner (Événement Exclusif)
    Footer CTA (Invitation au Voyage)

Each section aims to create an immersive narrative that subtly evokes your brand values. Below are suggestions on how to implement each segment in index.tsx using Tailwind and references to your color variables.
2. Hero Section (La Devise Royale)
Design & Psychology

    Convey a Majestic First Impression: large, cinematic image or video background (e.g., the “Red_Diamond_Elegance.mp4”).
    Text overlay in gold and ivory to emphasize luxury and seduction.
    A subtle fade-in animation to welcome visitors gracefully.

Possible Implementation (Hero)

// pages/index.tsx
import Image from "next/image";
import { useState } from "react";
// (If you're using your HeroCarousel component, adapt accordingly)

export default function HomePage() {
  return (
    <main className="relative">
      {/* HERO SECTION */}
      <section className="section-light min-h-screen flex flex-col justify-center items-center bg-fixed bg-center bg-cover relative"
        style={{ 
          backgroundImage: "url('/images/showroom.jpg')", 
          // or use <video> as a background if you prefer 
        }}
      >
        {/* Optional video background approach
        <video 
          className="absolute top-0 left-0 w-full h-full object-cover"
          src="/videos/Red_Diamond_Elegance.mp4"
          autoPlay
          muted
          loop
        />
        */}
        
        <div className="relative z-10 text-center max-w-4xl p-4">
          <h1 className="text-5xl md:text-7xl text-brandGold font-bold tracking-wide mb-4 drop-shadow-lg">
            Bienvenue à la Maison Diamant Rouge
          </h1>
          <p className="text-platinumGray text-xl md:text-2xl leading-relaxed mb-8">
            L’héritage d’un savoir-faire ancestral, taillé pour l’éternité.
          </p>

          <button className="button-primary hover-scale">
            Découvrir nos Collections
          </button>
        </div>
        {/* Optional overlay for a subtle darkening effect */}
        <div className="absolute top-0 left-0 w-full h-full bg-black/30 mix-blend-multiply"></div>
      </section>
      {/* Rest of the page sections below */}
    </main>
  );
}

Key Points

    We use .section-light to keep the brand’s Ivory background by default, but in the hero we override it with a background image or video.
    The CTA button uses .button-primary and a .hover-scale transform from globals.css.
    Text is in French and highlights the brand’s notion of Héritage & Éternité.

3. Featured Collections (Trésors de la Maison)
Design & Psychology

    Immediately showcase selected hero pieces to spark desire.
    Use carousel or grid with carefully curated images.
    Keep descriptions brief but suggestive of each piece’s story and heritage.

Possible Implementation (Collections Showcase)

<section className="py-16 px-4 section-light text-center">
  <h2 className="text-4xl mb-6">Trésors de la Maison</h2>
  <p className="text-lg md:text-xl text-platinumGray max-w-2xl mx-auto mb-12">
    Des créations qui évoquent la royauté, la passion et l’éternité.
  </p>

  <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
    {/* Example: Using your ProductCard component */}
    <div className="hover-scale">
      <ProductCard
        image="/images/products/diamond-solitaire-ring-set.png"
        title="Solitaire Éternel"
        price={29999}
      />
    </div>
    <div className="hover-scale">
      <ProductCard
        image="/images/products/emerald-ring.png"
        title="Émeraude Héritage"
        price={39999}
      />
    </div>
    <div className="hover-scale">
      <ProductCard
        image="/images/products/diamond-pendant-necklace.png"
        title="Pendentif Royal"
        price={24999}
      />
    </div>
  </div>
  
  <div className="mt-8">
    <button className="button-secondary">Voir toutes les Collections</button>
  </div>
</section>

Key Points

    A simple grid with .hover-scale to provide that subtle luxurious animation.
    Titles emphasize royalty and ancestral themes.
    .button-secondary invites users to explore more without overshadowing the main CTA from the hero.

4. Brand Essence / Story (Héritage et Intemporalité)
Design & Psychology

    Present a brief brand story in an elegant, narrative style.
    Reinforce trust, heritage, and exclusivity.
    Use a section-dark with burgundy background for a warm, intimate reading experience.

Possible Implementation (Brand Story)

<section className="section-dark py-16 px-6 text-center">
  <h2 className="text-4xl mb-4">Héritage & Intemporalité</h2>
  <p className="max-w-3xl mx-auto text-lg leading-relaxed text-brandIvory">
    Depuis des générations, Diamant Rouge perpétue un art joaillier inégalé. 
    Nos gemmes portent la trace de siècles d’histoire, taillées pour sublimer 
    les moments précieux de votre vie. L’intemporalité n’est pas un concept, 
    c’est notre héritage vivant.
  </p>
  
  <div className="mt-8">
    <button className="button-primary hover-scale">
      En savoir plus sur notre Histoire
    </button>
  </div>
</section>

Key Points

    .section-dark in Burgundy sets a cozy, intimate environment.
    A single button CTA leading to “À propos” or “Notre Histoire” page.
    Language emphasizes legacy and ancestral know-how.

5. Best Sellers or Highlighted Pieces (Mises en Avant)
Design & Psychology

    Social proof: “These pieces are adored by connoisseurs.”
    Encourage immediate engagement with a strong CTA (e.g., “Commander maintenant”).

<section className="section-light py-16 px-4">
  <h2 className="text-4xl text-center mb-6">Mises en Avant</h2>
  <p className="text-platinumGray text-center max-w-2xl mx-auto mb-12">
    Les incontournables qui font la renommée de Diamant Rouge.
  </p>
  
  <div className="grid grid-cols-2 md:grid-cols-4 gap-6">
    {/* Re-usable ProductCard with 'Bestseller' tag or something similar */}
    {/* ... */}
  </div>
</section>

6. Promotional / Seasonal Banner (Événement Exclusif)
Design & Psychology

    Create urgency or excitement about a special event, like a new collection launch or limited sale.
    Possibly place it between the “Brand Story” and “Footer CTA.”

<section className="py-8 section-dark flex flex-col items-center text-center">
  <h3 className="text-3xl mb-4">Événement Exclusif</h3>
  <p className="text-lg mb-6 text-brandIvory">
    Découvrez notre nouvelle collection “Dynastie Éblouissante” lors d’un gala privé.
  </p>
  <button className="button-secondary hover-scale">
    Réserver ma place
  </button>
</section>

7. Footer CTA (Invitation au Voyage)
Design & Psychology

    End the page with a final invitation to dive into the world of Diamant Rouge.
    Could link to collections or a personalized appointment.

<section className="section-light py-12 text-center">
  <h2 className="text-3xl mb-6">Prêt à Écrire Votre Légende ?</h2>
  <p className="text-lg max-w-xl mx-auto mb-8">
    Laissez Diamant Rouge orner vos moments les plus précieux...
  </p>
  <button className="button-primary hover-scale">
    Commencer l’Expérience
  </button>
</section>

8. Additional Tips & Best Practices

    Subtle Animations
        Use Framer Motion or React Spring for smooth fades, slides, or parallax transitions.
        Keep motion classy and minimal—we want elegance, not distraction.

    High-Quality Imagery
        For a luxury brand, professional photography is crucial (sharp, well-lit, stylized backgrounds).
        Make sure to use next/image for automatic optimizations and lazy loading.

    Responsive & Mobile-First
        Your layouts are primarily grid or flex-based in Tailwind, so be sure to test on smaller devices.
        Larger text and CTA buttons for mobile to maintain the luxury feel.

    Bilingual or Trilingual
        Even though it’s all in French, consider a language switcher if you want to incorporate Arabic or English.
        Provide a consistent branding tone across translations.

    SEO & Performance
        Pre-render or SSG (Static Site Generation) for main pages, so everything loads lightning-fast.
        Hero video can be made click-to-play on mobile to save bandwidth (especially in Morocco or slower connections).

9. Next Steps

With these UI improvements in place for your Home Page:

    Implement or adapt the proposed sections in your pages/index.tsx.
    Validate responsiveness and accessibility (e.g., color contrasts, alt text for images).
    Start fine-tuning the copywriting for a deeper sense of exclusivity and royalty.

Once you’re ready, we can move on to specific component-level enhancements (e.g., HeroCarousel.tsx), or proceed to the next page. Let me know your feedback, and we’ll iterate further!
You said:
okey rework those home page efficiently : "import { Swiper, SwiperSlide } from "swiper/react";
import { Autoplay, Pagination, EffectFade } from "swiper/modules";
import Image from "next/image";

/* ✅ Import Swiper CSS */
import "swiper/css";
import "swiper/css/pagination";
import "swiper/css/effect-fade";
import "swiper/css/autoplay";

type HeroSlide = {
    imageSrc: string;
    heading: string;
    subheading?: string;
};

type HeroCarouselProps = {
    slides: HeroSlide[];
};

export default function HeroCarousel({ slides }: HeroCarouselProps) {
    return (
        <Swiper
            modules={[Autoplay, Pagination, EffectFade]}
            effect="fade"
            pagination={{ clickable: true, dynamicBullets: true }}
            autoplay={{ delay: 5000, disableOnInteraction: false }}
            loop={true}
            className="relative w-full h-screen"
        >
            {slides.map((slide, i) => (
                <SwiperSlide key={i}>
                    <div className="relative w-full h-full">
                        {/* ✅ Burgundy Tint Overlay instead of black */}
                        <div className="absolute inset-0 bg-burgundy/40"></div>

                        <Image
                            src={slide.imageSrc}
                            alt={slide.heading}
                            layout="fill"
                            objectFit="cover"
                            className="z-0"
                        />

                        {/* ✅ Luxury Text Centered */}
                        <div className="absolute inset-0 flex flex-col justify-center items-center text-center z-10 px-6">
                            <h2 className="text-6xl font-serif text-brandGold drop-shadow-lg">
                                {slide.heading}
                            </h2>

                            {slide.subheading && (
                                <p className="text-2xl text-platinumGray mt-4 max-w-3xl drop-shadow-lg">
                                    {slide.subheading}
                                </p>
                            )}
                        </div>
                    </div>
                </SwiperSlide>
            ))}
        </Swiper>
    );
}""import HeroCarousel from "../components/HeroCarousel";
import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import ProductCard from "../components/ProductCard";
import { jwtVerify } from "jose";

// ✅ Fetch Products and Wishlist Securely
export async function getServerSideProps(context) {
    let userId = null;
    let wishlist = [];

    try {
        // ✅ Securely Parse Session Token
        const rawCookie = context.req.headers.cookie || "";
        let match =
            rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
            rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

        if (match) {
            const secret = process.env.NEXTAUTH_SECRET || "";
            const tokenStr = decodeURIComponent(match[1]);

            try {
                const { payload: decoded } = await jwtVerify(
                    tokenStr,
                    new TextEncoder().encode(secret)
                );
                if (decoded && typeof decoded === "object" && decoded.id) {
                    userId = Number(decoded.id);
                }
            } catch (tokenError) {
                console.warn("⚠ Token verification failed:", tokenError);
            }
        }

        console.log("✅ Fetching homepage data...");
        // ✅ Fetch Featured Products
        const featuredProducts = await prisma.product.findMany({
            include: { translations: true, variations: true },
            take: 6,
        });

        // ✅ Fetch Wishlist If User Logged In
        if (userId) {
            const wishlistItems = await prisma.wishlist.findMany({
                where: { userId },
                select: { productId: true },
            });
            wishlist = wishlistItems.map((item) => item.productId);
        }

        return {
            props: {
                products: JSON.parse(JSON.stringify(featuredProducts)),
                wishlist: JSON.parse(JSON.stringify(wishlist)),
                locale: context.locale || "en",
            },
        };
    } catch (error) {
        console.error("❌ Homepage Data Fetch Error:", error);
        return { props: { products: [], wishlist: [], locale: context.locale || "en" } };
    }
}

// ✅ Hero Carousel Data
const slides = [

    {
        videoSrc: "/videos/Red Diamond Elegance_simple_compose.mp4",
        heading: "Red Diamond Elegance",
        subheading: "A captivating video showcasing our finest collection.",
    }
];

export default function HomePage({ products, wishlist, locale }) {
    return (
        <>
            <NextSeo
                title="Diamant-Rouge | Luxury French Jewelry"
                description="Discover handcrafted bespoke luxury jewelry at Diamant-Rouge."
            />

            {/* Hero Section */}
            <HeroCarousel slides={slides} />

            {/* Exclusive Creations Section (Light) */}
            <motion.section
                className="section-light py-16 px-6 text-center"
                initial={{ opacity: 0, y: 50 }}
                whileInView={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                <h2 className="text-5xl font-serif text-brandGold mb-10">
                    Exclusive Creations
                </h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-6xl mx-auto">
                    <Link href="/collections/bespoke" className="card hover-scale">
                        <h3 className="text-3xl text-brandGold">Bespoke Creations</h3>
                        <p className="text-platinumGray mt-3">
                            Custom luxury jewelry tailored to your vision.
                        </p>
                    </Link>

                    <Link href="/appointments" className="card hover-scale">
                        <h3 className="text-3xl text-brandGold">
                            Private Showroom Experience
                        </h3>
                        <p className="text-platinumGray mt-3">
                            Book a one-on-one consultation with our artisans.
                        </p>
                    </Link>
                </div>
            </motion.section>

            {/* Featured Products */}
            <motion.section
                className="section-light py-16 px-6"
                initial={{ opacity: 0, y: 50 }}
                whileInView={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                <h2 className="text-5xl font-serif text-center text-brandGold mb-10">
                    Featured Jewelry
                </h2>
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 max-w-7xl mx-auto">
                    {products.map((product) => (
                        <ProductCard
                            key={product.id}
                            product={product}
                            locale={locale}
                            isWishlisted={wishlist.includes(product.id)}
                        />
                    ))}
                </div>
            </motion.section>

            {/* Newsletter */}
            <section className="section-light py-12 px-6 text-center">
                <h2 className="text-3xl font-serif text-brandGold mb-4">
                    Join Le Cercle Rouge
                </h2>
                <p className="text-platinumGray mb-4">
                    Exclusive previews, private sales, and early access.
                </p>
                <form className="max-w-md mx-auto flex">
                    <input
                        type="email"
                        placeholder="Your Email"
                        className="input-field flex-1"
                    />
                    <button
                        type="submit"
                        className="bg-burgundy hover:bg-brandGold text-brandIvory px-4 rounded-r-lg transition duration-300"
                    >
                        Subscribe
                    </button>
                </form>
            </section>
        </>
    );
}
" this is just a sculpture that is not desired .feel free to change everything make it wealthy content and design 

Below is a refreshed index.tsx example that delivers a wealthy, luxurious French-language experience. It leverages your existing HeroCarousel component while infusing royal-inspired content, refined transitions, and French copywriting aligned with Dynastie, Héritage, Intemporalité, and Luxe. Feel free to adjust the text, product queries, or visuals to match your final vision.

// pages/index.tsx

import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import ProductCard from "../components/ProductCard";
import HeroCarousel from "../components/HeroCarousel";
import { jwtVerify } from "jose";

/* 
  ------------------------------------------------------
  ✅ Server-Side Data Fetching for Products & Wishlist
  ------------------------------------------------------
*/
export async function getServerSideProps(context: any) {
  let userId: number | null = null;
  let wishlist: number[] = [];

  try {
    // 🏷️ Securely parse session token from cookies
    const rawCookie = context.req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

    if (match) {
      const secret = process.env.NEXTAUTH_SECRET || "";
      const tokenStr = decodeURIComponent(match[1]);

      try {
        const { payload: decoded } = await jwtVerify(
          tokenStr,
          new TextEncoder().encode(secret)
        );
        if (decoded && typeof decoded === "object" && decoded.id) {
          userId = Number(decoded.id);
        }
      } catch (tokenError) {
        console.warn("⚠ Token verification failed:", tokenError);
      }
    }

    // 🏷️ Fetch some featured products for the homepage
    const featuredProducts = await prisma.product.findMany({
      include: { translations: true, variations: true },
      take: 6,
    });

    // 🏷️ If logged in, fetch user's wishlist
    if (userId) {
      const wishlistItems = await prisma.wishlist.findMany({
        where: { userId },
        select: { productId: true },
      });
      wishlist = wishlistItems.map((item) => item.productId);
    }

    return {
      props: {
        products: JSON.parse(JSON.stringify(featuredProducts)),
        wishlist,
        locale: context.locale || "fr",
      },
    };
  } catch (error) {
    console.error("❌ Homepage Data Fetch Error:", error);
    return {
      props: { products: [], wishlist: [], locale: context.locale || "fr" },
    };
  }
}

/* 
  ------------------------------------------------------
  ✅ Hero Carousel Data (Slides)
     - We'll use the imageSrc field from HeroCarousel
     - Provide multiple slides for a richer experience
  ------------------------------------------------------
*/
const slides = [
  {
    imageSrc: "/images/parures-colliers-or-bijouterie-casablanca-maroc-825.jpg",
    heading: "Diamant Rouge",
    subheading: "L’Art Joaillier Hérité à Travers les Siècles",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg",
    heading: "Éclat de Royauté",
    subheading: "Sublimez chaque instant avec nos créations d'exception",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-dimant-rouge-464.jpg",
    heading: "Héritage & Intemporalité",
    subheading: "Quand le savoir-faire ancestral rencontre la modernité",
  },
];

export default function HomePage({
  products,
  wishlist,
  locale,
}: {
  products: any[];
  wishlist: number[];
  locale: string;
}) {
  return (
    <>
      {/* 
        ----------------------------------------------------
        ✅ SEO Tags 
        ----------------------------------------------------
      */}
      <NextSeo
        title="Diamant Rouge | Joaillerie de Luxe"
        description="Découvrez la haute joaillerie Diamant Rouge : pièces uniques, héritage intemporel et raffinement absolu."
      />

      {/* 
        ----------------------------------------------------
        ✅ Hero Carousel Section
        ----------------------------------------------------
      */}
      <HeroCarousel slides={slides} />

      {/* 
        ----------------------------------------------------
        ✅ Section: À la Une (Créations Royales)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-6 text-center"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.7 }}
        viewport={{ once: true }}
      >
        <h2 className="text-5xl font-serif text-brandGold mb-6">
          Créations Royales
        </h2>
        <p className="text-lg md:text-xl text-platinumGray max-w-2xl mx-auto mb-12">
          Une sélection de pièces d’exception, façonnées pour célébrer vos
          moments les plus précieux.
        </p>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-6xl mx-auto">
          <Link href="/collections/tresors" className="card hover-scale">
            <h3 className="text-3xl text-brandGold mb-2">Trésors Ancestraux</h3>
            <p className="text-platinumGray">
              Des bijoux intemporels inspirés par l’héritage royal marocain.
            </p>
          </Link>

          <Link href="/collections/haute-joaillerie" className="card hover-scale">
            <h3 className="text-3xl text-brandGold mb-2">Haute Joaillerie</h3>
            <p className="text-platinumGray">
              Des chefs-d’œuvre exclusifs, réalisés à la main par nos maîtres
              artisans.
            </p>
          </Link>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ✅ Section: Pièces Incontournables (Featured Products)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-6"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.7 }}
        viewport={{ once: true }}
      >
        <h2 className="text-5xl font-serif text-center text-brandGold mb-8">
          Pièces Incontournables
        </h2>
        <p className="text-center text-platinumGray max-w-2xl mx-auto mb-12">
          Découvrez nos plus belles créations, plébiscitées par les amoureux de
          la haute joaillerie.
        </p>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 max-w-7xl mx-auto">
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
              locale={locale}
              isWishlisted={wishlist.includes(product.id)}
            />
          ))}
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ✅ Section: Héritage & Artisanat
        ----------------------------------------------------
      */}
      <motion.section
        className="section-dark py-16 px-6 text-center"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.7 }}
        viewport={{ once: true }}
      >
        <h2 className="text-4xl font-serif text-brandGold mb-6">
          Héritage & Artisanat
        </h2>
        <p className="text-lg max-w-3xl mx-auto text-brandIvory leading-relaxed mb-10">
          Chaque création Diamant Rouge est le fruit d’un savoir-faire ancestral
          transmis de génération en génération. Notre maison puise sa force dans
          l’amour des gemmes, la précision du geste et la passion de la beauté
          intemporelle.
        </p>
        <Link href="/about">
          <button className="button-primary hover-scale">
            En savoir plus
          </button>
        </Link>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ✅ Section: Événement Exclusif ou Promotions
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-6 text-center"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.7 }}
        viewport={{ once: true }}
      >
        <h3 className="text-3xl font-serif text-brandGold mb-4">
          Événement Diamant Rouge
        </h3>
        <p className="text-lg text-platinumGray mb-6 max-w-2xl mx-auto">
          Participez à notre prochain gala privé et découvrez en avant-première
          notre nouvelle collection « Dynastie Éblouissante ».
        </p>
        <Link href="/appointments">
          <button className="button-secondary hover-scale">
            Réserver votre place
          </button>
        </Link>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ✅ Section: Newsletter (Le Cercle Diamant Rouge)
        ----------------------------------------------------
      */}
      <section className="section-light py-12 px-6 text-center">
        <h3 className="text-3xl font-serif text-brandGold mb-4">
          Rejoignez Le Cercle Diamant Rouge
        </h3>
        <p className="text-lg text-platinumGray max-w-xl mx-auto mb-6">
          Recevez nos invitations privées, découvrez nos nouveautés en avant-première 
          et bénéficiez d’offres exclusives.
        </p>
        <form className="max-w-md mx-auto flex">
          <input
            type="email"
            placeholder="Entrez votre adresse e-mail"
            className="input-field flex-1 rounded-r-none"
          />
          <button
            type="submit"
            className="bg-burgundy hover:bg-brandGold text-brandIvory hover:text-richEbony px-4 py-2 rounded-r-lg transition duration-300"
          >
            S’abonner
          </button>
        </form>
      </section>
    </>
  );
}

Key Changes & Highlights

    All-French Copy & Luxury Wording
        Sections are named and labeled to evoke Dynastie, Héritage, and Luxe:
            Créations Royales, Pièces Incontournables, Héritage & Artisanat, Événement Diamant Rouge, etc.

    Multiple Hero Slides
        The slides array has been expanded to feature multiple image-based slides.
        Each slide includes a heading/subheading in French to immerse visitors in your world.

    Refined Section Flow
        À la Une (Créations Royales) → Pièces Incontournables → Héritage & Artisanat → Événement Exclusif → Newsletter
        The narrative gently pulls users deeper into your brand story.

    Subtle Motion & Animations
        Each section uses framer-motion’s initial / whileInView to fade up content as it enters the viewport.
        Keeps the experience elegant without overwhelming movement.

    Newsletter CTA
        Encourages visitors to join “Le Cercle Diamant Rouge” with exclusive benefits.
        Aligns with the privileged, insider feeling of a luxury brand.

    Adaptable to Additional Needs
        You can easily add a video in the hero (just as you did in your initial snippet) or any other brand assets.
        Integrate custom components for deeper brand storytelling if desired.

Next Steps

    Replace or adjust images (.imageSrc) in the hero slides to your preferred visuals or a hero video.
    Fine-tune the text for each collection or event so it best matches your brand narrative.
    Add any localization logic if you support multiple languages (French/Arabic/English).
    Validate that your Prisma queries and data mappings reflect your actual product and wishlist schema.

This revamped homepage sets a resolutely premium tone with rich storytelling, French luxury copy, and captivating visuals. Feel free to refine further, and let me know if you want to focus on any other component or page next!
You said:
i don't like how everything is centred ,need to enhance the section to section harmony by emphasizing on hig quality pictures whenever possible  , also the text shouldn't be imposing , let the pictures the most attractive thing on te website 

Below is a streamlined homepage layout in French that puts high-quality images front and center while keeping text minimal and less imposing. Each section leverages left-aligned or split layouts to maintain visual harmony, letting the photography shine. Feel free to adjust images, text, or product fetch logic as needed.

// pages/index.tsx

import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import { jwtVerify } from "jose";

import HeroCarousel from "../components/HeroCarousel";
import ProductCard from "../components/ProductCard";

// ----------------------------------------------------------
// 1. Server-Side Data Fetching
// ----------------------------------------------------------
export async function getServerSideProps(context: any) {
  let userId: number | null = null;
  let wishlist: number[] = [];

  try {
    // 1️⃣ Parse session token
    const rawCookie = context.req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

    if (match) {
      const secret = process.env.NEXTAUTH_SECRET || "";
      const tokenStr = decodeURIComponent(match[1]);

      try {
        const { payload: decoded } = await jwtVerify(
          tokenStr,
          new TextEncoder().encode(secret)
        );
        if (decoded && typeof decoded === "object" && decoded.id) {
          userId = Number(decoded.id);
        }
      } catch (tokenError) {
        console.warn("⚠ Token verification failed:", tokenError);
      }
    }

    // 2️⃣ Fetch featured products
    const featuredProducts = await prisma.product.findMany({
      include: { translations: true, variations: true },
      take: 6,
    });

    // 3️⃣ If user logged in, fetch wishlist
    if (userId) {
      const wishlistItems = await prisma.wishlist.findMany({
        where: { userId },
        select: { productId: true },
      });
      wishlist = wishlistItems.map((item) => item.productId);
    }

    return {
      props: {
        products: JSON.parse(JSON.stringify(featuredProducts)),
        wishlist,
        locale: context.locale || "fr",
      },
    };
  } catch (error) {
    console.error("❌ Homepage Data Fetch Error:", error);
    return {
      props: { products: [], wishlist: [], locale: context.locale || "fr" },
    };
  }
}

// ----------------------------------------------------------
// 2. Hero Carousel Slides
//    Keep text short & minimal, with strong imagery
// ----------------------------------------------------------
const slides = [
  {
    imageSrc: "/images/parures-colliers-or-bijouterie-casablanca-maroc-825.jpg",
    heading: "Diamant Rouge",
    subheading: "L’Éclat Suprême de la Joaillerie",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg",
    heading: "Une Signature Royale",
    subheading: "Des pièces conçues pour sublimer chaque instant",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-dimant-rouge-464.jpg",
    heading: "Héritage Éternel",
    subheading: "La tradition marocaine au cœur de nos créations",
  },
];

export default function HomePage({
  products,
  wishlist,
  locale,
}: {
  products: any[];
  wishlist: number[];
  locale: string;
}) {
  return (
    <>
      <NextSeo
        title="Diamant Rouge | Joaillerie de Luxe"
        description="Découvrez la haute joaillerie Diamant Rouge : photos intemporelles, héritage royal, et raffinement absolu."
      />

      {/* 
        ----------------------------------------------------
        🏰 HERO CAROUSEL
        - Minimal text overlays, large imagery
        - Let images captivate user attention
        ----------------------------------------------------
      */}
      <HeroCarousel slides={slides} />

      {/* 
        ----------------------------------------------------
        🔱 CRÉATIONS ROYALES (Split Layout)
        - Left: large image
        - Right: minimal text
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-4 md:px-12"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row gap-8 items-center">
          {/* Large Image */}
          <div className="w-full md:w-1/2 overflow-hidden rounded-lg shadow-luxury hover-scale">
            <Image
              src="/images/showroom.jpg"
              alt="Showroom Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full"
            />
          </div>
          {/* Minimal Text */}
          <div className="w-full md:w-1/2 flex flex-col justify-center">
            <h2 className="text-3xl font-serif text-brandGold mb-4 text-left">
              Créations Royales
            </h2>
            <p className="text-platinumGray text-left mb-6">
              Découvrez l’essence même de Diamant Rouge : un art joaillier
              façonné par des générations de passionnés, pour qui chaque pierre
              est un joyau de l’âme.
            </p>
            <Link href="/collections/tresors" className="text-left">
              <button className="button-primary">
                Voir nos Collections
              </button>
            </Link>
          </div>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        💎 PIÈCES INCONTOURNABLES (Featured Products)
        - Focus on product images
        - Minimal headings, left-aligned
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-4 md:px-12"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <h2 className="text-3xl font-serif text-brandGold mb-4 text-left">
          Pièces Incontournables
        </h2>
        <p className="text-platinumGray text-left mb-8">
          Des œuvres intemporelles qui ont déjà conquis les connaisseurs.
        </p>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6">
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
              locale={locale}
              isWishlisted={wishlist.includes(product.id)}
            />
          ))}
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ⚜️ HÉRITAGE & ARTISANAT (Another Split Layout)
        - Let a big image speak for itself
        - Keep text minimal
        ----------------------------------------------------
      */}
      <motion.section
        className="section-dark py-16 px-4 md:px-12"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row gap-8 items-center">
          {/* Big Image on the left in dark mode */}
          <div className="w-full md:w-1/2 overflow-hidden rounded-lg shadow-luxury hover-scale">
            <Image
              src="/images/gemologist.jpg"
              alt="Artisanat Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full"
            />
          </div>

          {/* Minimal text on the right */}
          <div className="w-full md:w-1/2 flex flex-col justify-center text-left">
            <h3 className="text-3xl font-serif text-brandGold mb-4">
              Héritage & Artisanat
            </h3>
            <p className="text-brandIvory mb-6">
              Chaque bijou Diamant Rouge est l’aboutissement d’un geste noble,
              d’une tradition séculaire. Nos ateliers préservent le meilleur de
              l’artisanat marocain, enrichi d’une touche contemporaine unique.
            </p>
            <Link href="/about">
              <button className="button-secondary">
                Notre Histoire
              </button>
            </Link>
          </div>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        🌹 ÉVÉNEMENT EXCLUSIF (Wide Image Banner)
        - Emphasize a large background image, minimal text
        - Encourage a call to action
        ----------------------------------------------------
      */}
      <motion.section
        className="relative py-16 px-4 md:px-12 overflow-hidden"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        {/* Large BG Image */}
        <div className="absolute inset-0 z-0">
          <Image
            src="/images/emerald-ring.png"
            alt="Événement Diamant Rouge"
            fill
            className="object-cover"
          />
          <div className="absolute inset-0 bg-burgundy/40" />
        </div>

        {/* Minimal text overlay, left-aligned */}
        <div className="relative z-10 max-w-3xl">
          <h3 className="text-3xl font-serif text-brandGold mb-4 text-left">
            Événement Exclusif
          </h3>
          <p className="text-platinumGray text-left mb-6">
            Participez à notre soirée privée pour découvrir la nouvelle
            collection « Dynastie Éblouissante ».
          </p>
          <Link href="/appointments">
            <button className="button-primary">Réserver</button>
          </Link>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ✨ NEWSLETTER (Minimal, not center-dominant)
        ----------------------------------------------------
      */}
      <section className="section-light py-12 px-4 md:px-12">
        <div className="max-w-2xl">
          <h4 className="text-2xl font-serif text-brandGold mb-4 text-left">
            Rejoignez Le Cercle Diamant Rouge
          </h4>
          <p className="text-platinumGray text-left mb-6">
            Recevez nos invitations privées et découvrez nos créations en
            avant-première.
          </p>

          <form className="flex">
            <input
              type="email"
              placeholder="Votre adresse e-mail"
              className="input-field flex-1 rounded-r-none"
            />
            <button
              type="submit"
              className="bg-burgundy hover:bg-brandGold text-brandIvory hover:text-richEbony px-4 py-2 rounded-r-lg transition duration-300"
            >
              S’inscrire
            </button>
          </form>
        </div>
      </section>
    </>
  );
}

Key Modifications & Design Rationale

    Layouts That Let Photos Shine
        Split Layouts (flex row with a large image on one side and minimal text on the other) ensure visual dominance by the pictures.
        HeroCarousel remains at full-width, but textual overlays are kept concise.

    Left-Aligned Text
        Replaced most text-center with text-left for a more editorial, high-end style that doesn’t impose large text blocks on images.

    Minimal, Suggestive Copy
        Short headlines and brief paragraphs that evoke luxury without overshadowing visuals.
        Each section uses just enough text to drive curiosity and direct user actions.

    Large, High-Quality Images
        We place images in prominent positions using Tailwind classes like object-cover w-full h-full for a crisp look.
        The code references existing placeholders (.jpg, .png)—replace them with your highest quality brand photos.

    Motion Animations, But Subtle
        Kept framer-motion fade-ups for each major section.
        This gentle movement creates a modern, premium vibe without feeling “busy.”

    Reduced Visual Centering
        Headlines, calls-to-action, and paragraphs are mostly left-aligned, preserving a sleek editorial style often seen in high-end magazines.

    Dark vs. Light Sections
        Alternating backgrounds (light .section-light and dark .section-dark) maintain visual flow while highlighting the photography even more.

    Burgundy Overlay
        Where a background image might need a subtle darkening, we use a burgundy tint (bg-burgundy/40) instead of black. This aligns with your brand color scheme.

Next Steps

    Replace Placeholder Images
        Ensure each section features a striking, high-quality product or lifestyle shot.
        Optimize them with next/image for the best performance.

    Fine-Tune Text
        Adjust the French copy to perfectly reflect your brand’s tone and each product’s story.

    Check Responsiveness
        Test on multiple devices. For smaller screens, images may stack vertically, ensuring your visuals still shine.

    Iterate on Animations
        If you want even more subtlety, reduce the motion or remove it from certain sections entirely.

With these changes, your homepage visually emphasizes grand, luxury images while using minimal, refined text to guide the user. Let me know if you’d like further tweaks or if we should tackle another component or page next!
You said:
 don't said to get everything in left either . all i am asking for is diversification , where centred where let where right stragically and based on pictured 

Below is an updated homepage layout that varies text alignment (center, left, right) strategically, ensuring high-quality images remain the primary focal point and that text is present yet not overpowering. The structure we’ll use:

    Hero Carousel – Centered text overlay for maximum impact.
    Créations Royales – Split layout: text on the left, image on the right.
    Pièces Incontournables – Centered headings, grid of products.
    Héritage & Artisanat – Split layout with image left, text right.
    Événement Exclusif – Full-width background, text aligned to the right.
    Newsletter – Centered CTA, minimal.

Use this as a template; tweak images and text for the exact brand narrative you desire.

// pages/index.tsx

import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import { jwtVerify } from "jose";

import HeroCarousel from "../components/HeroCarousel";
import ProductCard from "../components/ProductCard";

/* ----------------------------------------------------------
   1. Server-Side Data Fetching
   ---------------------------------------------------------- */
export async function getServerSideProps(context: any) {
  let userId: number | null = null;
  let wishlist: number[] = [];

  try {
    // Parse session token
    const rawCookie = context.req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

    if (match) {
      const secret = process.env.NEXTAUTH_SECRET || "";
      const tokenStr = decodeURIComponent(match[1]);

      try {
        const { payload: decoded } = await jwtVerify(
          tokenStr,
          new TextEncoder().encode(secret)
        );
        if (decoded && typeof decoded === "object" && decoded.id) {
          userId = Number(decoded.id);
        }
      } catch (tokenError) {
        console.warn("⚠ Token verification failed:", tokenError);
      }
    }

    // Fetch featured products
    const featuredProducts = await prisma.product.findMany({
      include: { translations: true, variations: true },
      take: 6,
    });

    // If user is logged in, fetch their wishlist
    if (userId) {
      const wishlistItems = await prisma.wishlist.findMany({
        where: { userId },
        select: { productId: true },
      });
      wishlist = wishlistItems.map((item) => item.productId);
    }

    return {
      props: {
        products: JSON.parse(JSON.stringify(featuredProducts)),
        wishlist,
        locale: context.locale || "fr",
      },
    };
  } catch (error) {
    console.error("❌ Homepage Data Fetch Error:", error);
    return {
      props: { products: [], wishlist: [], locale: context.locale || "fr" },
    };
  }
}

/* ----------------------------------------------------------
   2. Hero Carousel Slides
   ---------------------------------------------------------- */
const slides = [
  {
    imageSrc: "/images/parures-colliers-or-bijouterie-casablanca-maroc-825.jpg",
    heading: "Diamant Rouge",
    subheading: "Éclat Royal & Héritage Intemporel",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg",
    heading: "L’Essence de la Joaillerie",
    subheading: "Des pièces taillées pour sublimer chaque moment",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-dimant-rouge-464.jpg",
    heading: "Héritage Vivant",
    subheading: "La tradition à travers les siècles, pour vous",
  },
];

export default function HomePage({
  products,
  wishlist,
  locale,
}: {
  products: any[];
  wishlist: number[];
  locale: string;
}) {
  return (
    <>
      <NextSeo
        title="Diamant Rouge | Joaillerie de Luxe"
        description="Découvrez la joaillerie Diamant Rouge : des pièces intemporelles, un héritage royal et un artisanat d’exception."
      />

      {/* 
        ----------------------------------------------------
        ✨ 1. HERO CAROUSEL (centered text)
        ----------------------------------------------------
      */}
      <HeroCarousel slides={slides} />

      {/* 
        ----------------------------------------------------
        🔶 2. CRÉATIONS ROYALES (split: text left, image right)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-4 md:px-12"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row items-center gap-10">
          {/* Text (Left) */}
          <div className="w-full md:w-1/2">
            <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
              Créations Royales
            </h2>
            <p className="text-platinumGray mb-6 leading-relaxed">
              Des joyaux inspirés par la splendeur d’autrefois, façonnés pour
              briller aujourd’hui. Chaque pièce raconte une histoire de passion
              et de noblesse.
            </p>
            <Link href="/collections/tresors">
              <button className="button-primary">Découvrir Nos Trésors</button>
            </Link>
          </div>
          {/* Image (Right) */}
          <div className="w-full md:w-1/2 relative overflow-hidden rounded-xl shadow-luxury">
            <Image
              src="/images/showroom.jpg"
              alt="Showroom Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full hover-scale"
            />
          </div>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        💎 3. PIÈCES INCONTOURNABLES (centered headings, grid)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-4 md:px-12 text-center"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-2">
          Pièces Incontournables
        </h2>
        <p className="text-platinumGray max-w-2xl mx-auto mb-8">
          Sélectionnées par les connaisseurs, ces créations incarnent le meilleur
          de Diamant Rouge.
        </p>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 max-w-7xl mx-auto">
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
              locale={locale}
              isWishlisted={wishlist.includes(product.id)}
            />
          ))}
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        ⚜️ 4. HÉRITAGE & ARTISANAT (split: image left, text right)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-dark py-16 px-4 md:px-12"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row items-center gap-10">
          {/* Image (Left) */}
          <div className="w-full md:w-1/2 overflow-hidden rounded-xl shadow-luxury relative">
            <Image
              src="/images/gemologist.jpg"
              alt="Atelier Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full hover-scale"
            />
          </div>
          {/* Text (Right) */}
          <div className="w-full md:w-1/2 text-right">
            <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
              Héritage & Artisanat
            </h3>
            <p className="text-brandIvory leading-relaxed mb-6">
              Les secrets d’une tradition séculaire se révèlent dans chaque
              détail. Nos artisans perpétuent un savoir-faire d’exception pour
              offrir des bijoux uniques, reflet d’une passion inaltérable.
            </p>
            <Link href="/about">
              <button className="button-secondary">En Savoir Plus</button>
            </Link>
          </div>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        🎉 5. ÉVÉNEMENT EXCLUSIF (full-width bg, text right)
        ----------------------------------------------------
      */}
      <motion.section
        className="relative py-16 px-4 md:px-12 overflow-hidden"
        initial={{ opacity: 0, x: 50 }}
        whileInView={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        {/* Background Image */}
        <div className="absolute inset-0 z-0">
          <Image
            src="/images/emerald-ring.png"
            alt="Événement Diamant Rouge"
            fill
            className="object-cover object-center"
          />
          {/* Burgundy Tint */}
          <div className="absolute inset-0 bg-burgundy/40" />
        </div>

        {/* Text (Right-Aligned) */}
        <div className="relative z-10 flex flex-col items-end max-w-4xl ml-auto">
          <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
            Événement Exclusif
          </h3>
          <p className="text-platinumGray mb-6 max-w-md">
            Participez à notre gala privé et découvrez la nouvelle collection
            « Dynastie Éblouissante » avant tout le monde.
          </p>
          <Link href="/appointments">
            <button className="button-primary">Réserver</button>
          </Link>
        </div>
      </motion.section>

      {/* 
        ----------------------------------------------------
        📨 6. NEWSLETTER (centered CTA, minimal text)
        ----------------------------------------------------
      */}
      <section className="section-light py-12 px-4 md:px-12 text-center">
        <h4 className="text-2xl md:text-3xl font-serif text-brandGold mb-4">
          Rejoignez Le Cercle Diamant Rouge
        </h4>
        <p className="text-platinumGray max-w-xl mx-auto mb-6">
          Recevez nos invitations privées et découvrez nos nouveautés en
          avant-première.
        </p>
        <form className="max-w-md mx-auto flex">
          <input
            type="email"
            placeholder="Votre adresse e-mail"
            className="input-field flex-1 rounded-r-none"
          />
          <button
            type="submit"
            className="bg-burgundy hover:bg-brandGold text-brandIvory hover:text-richEbony px-4 py-2 rounded-r-lg transition duration-300"
          >
            S’inscrire
          </button>
        </form>
      </section>
    </>
  );
}

Explanation of the Layout & Alignment Strategy

    Hero (Center-Aligned Text)
        Powerful images in the background.
        Minimal text in the center for an immediate, impactful brand impression.

    Créations Royales (Text Left, Image Right)
        Showcases a split layout. Text is aligned left (natural reading flow), while the large image is on the right to draw attention.

    Pièces Incontournables (Center-Aligned Heading & Grid)
        Headings and subheadings are centered to unify the product grid.
        Product images remain the main focus.

    Héritage & Artisanat (Image Left, Text Right-Aligned)
        Inverts the layout to keep the design dynamic.
        Right-aligned text can visually balance the left image.

    Événement Exclusif (Background Image, Right-Aligned Text)
        Full-width background, minimal copy on the right to avoid overshadowing the image.
        Creates an elegant emphasis on the visual while guiding the eye to the CTA.

    Newsletter (Center-Aligned CTA)
        Concludes the page with a straightforward call to action.
        Minimal copy, center alignment for simplicity and clarity.

Additional Tips

    Use High-Resolution Images: The bigger and crisper your images, the more they shine.
    Keep Copy Minimal & Evocative: In a luxury setting, less text often conveys exclusivity.
    Ensure Responsive Testing: On narrow screens, the image/text splits will stack vertically—test to ensure the alignment still looks strategic.
    Adjust Animations: If you want less motion, reduce or remove the framer-motion transitions. If you want more variety, add subtle slides, fades, or custom durations.

This layout balances varied text alignment (center/left/right) with strong photography front and center, giving your site a luxurious, visually driven identity. Let me know if you’d like further changes or want to refine any specific section!
You said:
now let's move on working on the header ""use client";
import { useState, useEffect } from "react";
import Link from "next/link";
import { useCart } from "../contexts/CartContext";
import { useWishlist } from "../contexts/WishlistContext";
import {
    ShoppingCart,
    Heart,
    User,
    Calendar,
    LogOut,
    MessageCircle,
    Menu,
    X,
    ChevronDown,
    Sun,
    Moon,
    ShieldCheck, // or any other Lucide icon for admin
} from "lucide-react";
import { signOut, useSession } from "next-auth/react";
import Image from "next/image";

export default function Header() {
    const [isScrolled, setIsScrolled] = useState(false);
    const [menuOpen, setMenuOpen] = useState(false);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);

    // ========== THEME STATE ==========
    // By default, let's check localStorage or fallback to false (light mode)
    const [isDarkMode, setIsDarkMode] = useState(false);

    const { cart } = useCart();
    const { wishlist } = useWishlist();
    const { data: session } = useSession();

    // Track scroll to change header style
    useEffect(() => {
        const handleScroll = () => setIsScrolled(window.scrollY > 50);
        window.addEventListener("scroll", handleScroll);
        return () => window.removeEventListener("scroll", handleScroll);
    }, []);

    // On mount, check if we have a saved theme
    useEffect(() => {
        const savedTheme = localStorage.getItem("diamantrouge-theme");
        if (savedTheme === "dark") {
            setIsDarkMode(true);
            document.documentElement.classList.add("dark");
        } else {
            setIsDarkMode(false);
            document.documentElement.classList.remove("dark");
        }
    }, []);

    // Toggle theme function
    const handleThemeToggle = () => {
        setIsDarkMode((prev) => {
            const newTheme = !prev;
            if (newTheme) {
                document.documentElement.classList.add("dark");
                localStorage.setItem("diamantrouge-theme", "dark");
            } else {
                document.documentElement.classList.remove("dark");
                localStorage.setItem("diamantrouge-theme", "light");
            }
            return newTheme;
        });
    };

    return (
        <header
            className={
        fixed top-0 w-full z-50 transition-all duration-500
        ${
                isScrolled
                    ? "bg-brandIvory/90 shadow-luxury backdrop-blur-md"
                    : "bg-transparent"
            }
      }
        >
            {/* ====== Top Bar ====== */}
            <div className="w-full bg-brandIvory/80 py-3 border-b border-platinumGray">
                <div className="container mx-auto flex items-center justify-between px-6">
                    {/* Left side: WhatsApp + Appointment */}
                    <div className="flex items-center gap-4 text-richEbony">
                        <a
                            href="https://wa.me/YOUR_WHATSAPP_NUMBER"
                            target="_blank"
                            rel="noopener noreferrer"
                            className="hover:text-burgundy hover-scale transition duration-300"
                        >
                            <MessageCircle size={24} />
                        </a>
                        <Link
                            href="/appointments"
                            className="flex items-center gap-1 hover:text-brandGold transition duration-300"
                        >
                            <Calendar size={20} />
                            <span className="hidden md:inline">Prendre Rendez-vous</span>
                        </Link>
                    </div>

                    {/* Logo in the center */}
                    <Link href="/" className="flex items-center justify-center">
                        <div className="relative w-[333px] h-[111px] hover-scale transition-transform duration-500">
                            {/* Ensure your logo asset has burgundy & gold colors */}
                            <Image
                                src="/images/1/diamant-rouge-logo.svg"
                                alt="Diamant Rouge"
                                fill
                                className="object-contain"
                            />
                        </div>
                    </Link>

                    {/* Right side: user icons + Theme Toggle */}
                    <div className="flex items-center gap-5">
                        {/* Wishlist Icon */}
                        <Link
                            href="/wishlist"
                            className="relative hover-scale transition-transform duration-300"
                        >
                            <Heart className="text-brandGold" size={26} />
                            {wishlist.length > 0 && (
                                <span className="absolute -top-1 -right-1 bg-burgundy text-brandIvory text-xs px-2 py-1 rounded-full">
                  {wishlist.length}
                </span>
                            )}
                        </Link>

                        {/* Cart Icon */}
                        <Link
                            href="/cart"
                            className="relative hover-scale transition-transform duration-300"
                        >
                            <ShoppingCart className="text-brandGold" size={26} />
                            {cart.length > 0 && (
                                <span className="absolute -top-1 -right-1 bg-burgundy text-brandIvory text-xs px-2 py-1 rounded-full">
                  {cart.length}
                </span>
                            )}
                        </Link>

                        {/* Admin Icon - only if user is admin */}
                        {session?.user?.role === "admin" && (
                            <Link
                                href="/admin"
                                className="hover-scale transition-transform duration-300 hover:text-brandGold"
                            >
                                <ShieldCheck className="text-brandGold" size={26} />
                            </Link>
                        )}

                        {/* Auth Icons */}
                        {session ? (
                            <>
                                <Link
                                    href="/profile"
                                    className="hover:text-brandGold transition duration-300"
                                >
                                    <User className="text-brandGold" size={26} />
                                </Link>
                                <button
                                    onClick={() => signOut()}
                                    className="text-brandGold hover:text-burgundy transition duration-300"
                                >
                                    <LogOut size={26} />
                                </button>
                            </>
                        ) : (
                            <Link
                                href="/auth"
                                className="hover:text-brandGold transition duration-300"
                            >
                                <User className="text-brandGold" size={26} />
                            </Link>
                        )}

                        {/* Dark/Light Mode Toggle Button */}
                        <button
                            onClick={handleThemeToggle}
                            className="text-brandGold hover:text-burgundy transition duration-300"
                        >
                            {isDarkMode ? <Sun size={22} /> : <Moon size={22} />}
                        </button>

                        {/* Mobile Menu Toggle (Burger Icon) */}
                        <button
                            onClick={() => setMenuOpen(!menuOpen)}
                            className="md:hidden text-brandGold hover:text-burgundy transition duration-300"
                        >
                            {menuOpen ? <X size={26} /> : <Menu size={26} />}
                        </button>
                    </div>
                </div>
            </div>

            {/* ====== Second Bar: Main Nav ====== */}
            <div
                className={hidden md:block w-full bg-brandIvory transition-all duration-500 ${
                    isScrolled ? "shadow-subtle" : ""
                }}
            >
                <nav className="container mx-auto py-2 flex justify-center space-x-10">
                    {/* Each nav link */}
                    <Link
                        href="/"
                        className="text-richEbony hover:text-brandGold transition duration-300"
                    >
                        Home
                    </Link>

                    {/* Creations Dropdown */}
                    <div
                        className="relative flex items-center gap-1 text-richEbony hover:text-brandGold transition duration-300"
                        onMouseEnter={() => setIsDropdownOpen(true)}
                        onMouseLeave={() => setIsDropdownOpen(false)}
                    >
                        <button className="flex items-center gap-1">
                            Creations
                            <ChevronDown size={18} />
                        </button>
                        <div
                            className={dropdown-menu ${
                                isDropdownOpen ? "dropdown-menu-active" : ""
                            } left-1/2 -translate-x-1/2}
                        >
                            <Link
                                href="/collections/rings"
                                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
                            >
                                Rings
                            </Link>
                            <Link
                                href="/collections/bracelets"
                                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
                            >
                                Bracelets
                            </Link>
                            <Link
                                href="/collections/necklaces"
                                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
                            >
                                Necklaces
                            </Link>
                            <Link
                                href="/collections/bespoke"
                                className="block px-5 py-3 bg-brandGold text-richEbony font-medium transition duration-300"
                            >
                                Bespoke Creations
                            </Link>
                        </div>
                    </div>

                    <Link
                        href="/appointments"
                        className="text-richEbony hover:text-brandGold transition duration-300"
                    >
                        Appointments
                    </Link>
                    <Link
                        href="/the-house"
                        className="text-richEbony hover:text-brandGold transition duration-300"
                    >
                        The House
                    </Link>
                    <Link
                        href="/contact"
                        className="text-richEbony hover:text-brandGold transition duration-300"
                    >
                        Contact
                    </Link>
                </nav>
            </div>

            {/* ====== Mobile Nav Menu ====== */}
            {menuOpen && (
                <div className="mobile-menu md:hidden bg-brandIvory p-4 border-t border-platinumGray">
                    <Link
                        href="/"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Home
                    </Link>
                    <Link
                        href="/collections/rings"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Rings
                    </Link>
                    <Link
                        href="/collections/bracelets"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Bracelets
                    </Link>
                    <Link
                        href="/collections/necklaces"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Necklaces
                    </Link>
                    <Link
                        href="/collections/bespoke"
                        className="block py-3 text-brandGold font-medium hover:text-brandIvory transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Bespoke Creations
                    </Link>
                    <Link
                        href="/appointments"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Appointments
                    </Link>
                    <Link
                        href="/the-house"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        The House
                    </Link>
                    <Link
                        href="/contact"
                        className="block py-3 text-richEbony hover:text-brandGold transition duration-300"
                        onClick={() => setMenuOpen(false)}
                    >
                        Contact
                    </Link>
                </div>
            )}
        </header>
    );
}
"  this is just a first unwanted header placeholder. feel free to change it to the over all Diamant Rouge brand vision and identity 

Below is an updated Header component in French, aligned with the Diamant Rouge brand identity. The design emphasizes luxury, heritage, and refined quality, introducing:

    A top bar referencing Conciergerie and Rendez-vous for a higher-end feel.
    Subtle brand elements in the middle (logo).
    A nav with French labels, lightly rebranded items (e.g., La Maison instead of The House).
    Icons for cart, wishlist, etc., carefully integrated.
    Session-based admin link and sign-in/out logic.
    A dark/light mode toggle (optional but included).

Feel free to rename links or refine text for your final brand narrative.

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useCart } from "../contexts/CartContext";
import { useWishlist } from "../contexts/WishlistContext";
import {
  ShoppingCart,
  Heart,
  User,
  Calendar,
  LogOut,
  MessageCircle,
  Menu,
  X,
  ChevronDown,
  Sun,
  Moon,
  ShieldCheck,
} from "lucide-react";
import { signOut, useSession } from "next-auth/react";
import Image from "next/image";

/* 
  ---------------------------------------------------
  ✅ HEADER COMPONENT
  ---------------------------------------------------
*/
export default function Header() {
  const [isScrolled, setIsScrolled] = useState(false);
  const [menuOpen, setMenuOpen] = useState(false);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  // ========== THEME STATE ==========
  const [isDarkMode, setIsDarkMode] = useState(false);

  const { cart } = useCart();
  const { wishlist } = useWishlist();
  const { data: session } = useSession();

  // Track scrolling to apply sticky styling
  useEffect(() => {
    const handleScroll = () => setIsScrolled(window.scrollY > 50);
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  // On mount, check if we have a saved theme
  useEffect(() => {
    const savedTheme = localStorage.getItem("diamantrouge-theme");
    if (savedTheme === "dark") {
      setIsDarkMode(true);
      document.documentElement.classList.add("dark");
    } else {
      setIsDarkMode(false);
      document.documentElement.classList.remove("dark");
    }
  }, []);

  // Toggle theme
  const handleThemeToggle = () => {
    setIsDarkMode((prev) => {
      const newTheme = !prev;
      if (newTheme) {
        document.documentElement.classList.add("dark");
        localStorage.setItem("diamantrouge-theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("diamantrouge-theme", "light");
      }
      return newTheme;
    });
  };

  return (
    <header
      className={`
        fixed top-0 w-full z-50 transition-all duration-500 
        ${
          isScrolled
            ? "bg-brandIvory/90 shadow-luxury backdrop-blur-md"
            : "bg-transparent"
        }
      `}
    >
      {/* 
        ------------------------------------
        🏷️ 1) TOP BAR 
          - Simple references to "Conciergerie" & "Rendez-vous"
        ------------------------------------
      */}
      <div className="w-full bg-brandIvory/80 py-2 border-b border-platinumGray">
        <div className="container mx-auto flex items-center justify-between px-4 md:px-6">
          {/* Left side: Conciergerie & Rendez-vous */}
          <div className="flex items-center gap-4 text-richEbony">
            {/* Optionally, a phone or chat link */}
            <a
              href="https://wa.me/YOUR_WHATSAPP_NUMBER"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:text-burgundy hover-scale transition duration-300"
            >
              <MessageCircle size={22} />
            </a>
            {/* Rendez-vous link */}
            <Link
              href="/appointments"
              className="flex items-center gap-1 hover:text-brandGold transition duration-300"
            >
              <Calendar size={20} />
              <span className="hidden md:inline">Rendez-vous Privé</span>
            </Link>
          </div>

          {/* Right side: Could contain short brand statement or a small tagline */}
          <div className="text-sm text-richEbony italic hidden md:block">
            <span>Luxe • Héritage • Intemporalité</span>
          </div>
        </div>
      </div>

      {/* 
        ------------------------------------
        🏷️ 2) MAIN HEADER (Logo + Icons)
        ------------------------------------
      */}
      <div
        className={`w-full transition-all duration-500 ${
          isScrolled ? "shadow-subtle bg-brandIvory/90" : "bg-brandIvory/80"
        }`}
      >
        <div className="container mx-auto flex items-center justify-between px-4 md:px-6 py-3">
          {/* Logo */}
          <Link href="/" className="relative w-[240px] h-[70px] hover-scale">
            <Image
              src="/images/logo_center.png"
              alt="Logo Diamant Rouge"
              fill
              className="object-contain"
            />
          </Link>

          {/* Right group: icons & mobile menu toggle */}
          <div className="flex items-center gap-5">
            {/* Wishlist */}
            <Link
              href="/wishlist"
              className="relative hover-scale transition-transform duration-300"
            >
              <Heart className="text-brandGold" size={24} />
              {wishlist.length > 0 && (
                <span className="absolute -top-1 -right-2 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {wishlist.length}
                </span>
              )}
            </Link>

            {/* Cart */}
            <Link
              href="/cart"
              className="relative hover-scale transition-transform duration-300"
            >
              <ShoppingCart className="text-brandGold" size={24} />
              {cart.length > 0 && (
                <span className="absolute -top-1 -right-2 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {cart.length}
                </span>
              )}
            </Link>

            {/* Admin Panel if user is admin */}
            {session?.user?.role === "admin" && (
              <Link
                href="/admin"
                className="hover-scale transition-transform duration-300"
              >
                <ShieldCheck className="text-brandGold" size={24} />
              </Link>
            )}

            {/* Auth Icons */}
            {session ? (
              <>
                <Link
                  href="/profile"
                  className="hover-scale transition-transform duration-300"
                >
                  <User className="text-brandGold" size={24} />
                </Link>
                <button
                  onClick={() => signOut()}
                  className="text-brandGold hover:text-burgundy transition duration-300"
                  title="Se déconnecter"
                >
                  <LogOut size={24} />
                </button>
              </>
            ) : (
              <Link
                href="/auth"
                className="hover-scale transition-transform duration-300"
                title="Se connecter"
              >
                <User className="text-brandGold" size={24} />
              </Link>
            )}

            {/* Dark/Light Mode Toggle */}
            <button
              onClick={handleThemeToggle}
              className="text-brandGold hover:text-burgundy transition duration-300"
            >
              {isDarkMode ? <Sun size={22} /> : <Moon size={22} />}
            </button>

            {/* Mobile Menu Toggle */}
            <button
              onClick={() => setMenuOpen(!menuOpen)}
              className="md:hidden text-brandGold hover:text-burgundy transition duration-300"
            >
              {menuOpen ? <X size={24} /> : <Menu size={24} />}
            </button>
          </div>
        </div>
      </div>

      {/* 
        ------------------------------------
        🏷️ 3) MAIN NAV (Desktop)
        ------------------------------------
      */}
      <div
        className={`hidden md:block w-full bg-brandIvory transition-all duration-300 ${
          isScrolled ? "shadow-subtle" : ""
        }`}
      >
        <nav className="container mx-auto py-2 flex justify-center space-x-10 text-sm font-medium">
          {/* Accueil */}
          <Link
            href="/"
            className="text-richEbony hover:text-brandGold transition duration-300"
          >
            Accueil
          </Link>

          {/* Collections/Créations Dropdown */}
          <div
            className="relative flex items-center gap-1 text-richEbony hover:text-brandGold transition duration-300"
            onMouseEnter={() => setIsDropdownOpen(true)}
            onMouseLeave={() => setIsDropdownOpen(false)}
          >
            <button className="flex items-center gap-1">
              Collections
              <ChevronDown size={16} />
            </button>
            <div
              className={`dropdown-menu ${
                isDropdownOpen ? "dropdown-menu-active" : ""
              } left-1/2 -translate-x-1/2`}
            >
              <Link
                href="/collections/bagues"
                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
              >
                Bagues
              </Link>
              <Link
                href="/collections/bracelets"
                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
              >
                Bracelets
              </Link>
              <Link
                href="/collections/colliers"
                className="block px-5 py-3 hover:bg-burgundy hover:text-brandIvory transition duration-300"
              >
                Colliers
              </Link>
              <Link
                href="/collections/sur-mesure"
                className="block px-5 py-3 bg-brandGold text-richEbony font-medium transition duration-300"
              >
                Sur Mesure
              </Link>
            </div>
          </div>

          {/* Rendez-vous */}
          <Link
            href="/appointments"
            className="text-richEbony hover:text-brandGold transition duration-300"
          >
            Rendez-vous
          </Link>

          {/* La Maison */}
          <Link
            href="/the-house"
            className="text-richEbony hover:text-brandGold transition duration-300"
          >
            La Maison
          </Link>

          {/* Contact */}
          <Link
            href="/contact"
            className="text-richEbony hover:text-brandGold transition duration-300"
          >
            Contact
          </Link>
        </nav>
      </div>

      {/* 
        ------------------------------------
        🏷️ 4) MOBILE NAV
        ------------------------------------
      */}
      {menuOpen && (
        <div className="mobile-menu md:hidden bg-brandIvory p-5 border-t border-platinumGray">
          {/* Mobile Nav Links */}
          <Link
            href="/"
            className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
            onClick={() => setMenuOpen(false)}
          >
            Accueil
          </Link>

          {/* Collections sub-links */}
          <div className="py-2 border-t border-platinumGray mt-2">
            <Link
              href="/collections/bagues"
              className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
              onClick={() => setMenuOpen(false)}
            >
              Bagues
            </Link>
            <Link
              href="/collections/bracelets"
              className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
              onClick={() => setMenuOpen(false)}
            >
              Bracelets
            </Link>
            <Link
              href="/collections/colliers"
              className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
              onClick={() => setMenuOpen(false)}
            >
              Colliers
            </Link>
            <Link
              href="/collections/sur-mesure"
              className="block py-2 text-brandGold font-medium hover:text-brandIvory transition duration-300"
              onClick={() => setMenuOpen(false)}
            >
              Sur Mesure
            </Link>
          </div>

          <Link
            href="/appointments"
            className="block py-2 mt-2 text-richEbony hover:text-brandGold transition duration-300"
            onClick={() => setMenuOpen(false)}
          >
            Rendez-vous
          </Link>
          <Link
            href="/the-house"
            className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
            onClick={() => setMenuOpen(false)}
          >
            La Maison
          </Link>
          <Link
            href="/contact"
            className="block py-2 text-richEbony hover:text-brandGold transition duration-300"
            onClick={() => setMenuOpen(false)}
          >
            Contact
          </Link>
        </div>
      )}
    </header>
  );
}

Highlights & Design Rationale

    French Brand Lexicon
        Menu items: Accueil, Collections (with Bagues, Bracelets, Colliers, Sur Mesure), Rendez-vous, La Maison, Contact.
        Maintains an elegant, localized tone.

    Top Bar = Conciergerie Vibe
        Minimal references to private appointments (Rendez-vous Privé) and a quick link to contact (WhatsApp/Message).

    Luxury Minimalism
        Clean layout with subtle brand color usage (burgundy/gold).
        Avoids clutter while showcasing key icons (cart, wishlist, user).

    Logo Front & Center
        Located in the middle row, sized suitably for a premium brand.
        Retains the signature Diamant Rouge identity.

    Dropdown Menu for Collections
        Bagues, Bracelets, Colliers, etc.
        Sur Mesure is highlighted with a gold background in the dropdown to draw attention to custom creations.

    Admin Role Support
        If session?.user?.role === "admin", show the admin icon.
        Maintains a consistent approach to role-based UI.

    Dark/Light Mode Toggle
        With a simple button, toggling the entire site’s theme, stored in local storage.
        Matches the brand’s desire for a refined experience across both themes.

    Mobile Menu
        Expands from the top with the burger (<Menu />) and close (<X />) icon.
        Menu links replicate the main nav but stacked vertically.

Next Steps

    Refine Link Routes & Names
        If you have different or more specific collections, rename them (e.g., Colliers de Mariée, Bracelets Royaux, etc.).

    Adjust Branding Copy
        Insert any brand slogans or short taglines that reinforce your heritage and luxury values.

    Test Responsiveness
        Ensure the header transitions smoothly on devices from mobile to large desktop.

    Validate Theme & Colors
        Tweak color classes to ensure the header always remains elegant in both light and dark modes.

With these changes, you have a refined, French-oriented header that captures Diamant Rouge’s luxury and heritage identity, while offering a clean, user-friendly navigation experience. Feel free to adapt further for your brand’s visual or textual preferences!
You said:
This header is all messy.  the logo shifted to left and lack indentation
3/3

Below is a clean, modernized Header component in French for Diamant Rouge, ensuring:

    Centered logo in its own dedicated row
    Well-indented structure so elements aren’t “messy” or off-aligned
    Top bar referencing Conciergerie or a quick link (optional)
    Responsive layout for both desktop & mobile
    Minimal brand coloring to preserve a refined, luxury feel

Feel free to adjust links, icons, brand text, or styling to your exact needs.

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { signOut, useSession } from "next-auth/react";
import { useCart } from "../contexts/CartContext";
import { useWishlist } from "../contexts/WishlistContext";
import {
  ShoppingCart,
  Heart,
  User,
  LogOut,
  Calendar,
  MessageCircle,
  ShieldCheck,
  Menu,
  X,
  Sun,
  Moon,
} from "lucide-react";

export default function Header() {
  const { cart } = useCart();
  const { wishlist } = useWishlist();
  const { data: session } = useSession();

  // Track whether we’ve scrolled to apply a “sticky” style
  const [isScrolled, setIsScrolled] = useState(false);
  useEffect(() => {
    const handleScroll = () => setIsScrolled(window.scrollY > 50);
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  // ========== THEME STATE ==========
  const [isDarkMode, setIsDarkMode] = useState(false);
  useEffect(() => {
    const savedTheme = localStorage.getItem("diamantrouge-theme");
    if (savedTheme === "dark") {
      setIsDarkMode(true);
      document.documentElement.classList.add("dark");
    } else {
      setIsDarkMode(false);
      document.documentElement.classList.remove("dark");
    }
  }, []);
  const handleThemeToggle = () => {
    setIsDarkMode((prev) => {
      const newVal = !prev;
      if (newVal) {
        document.documentElement.classList.add("dark");
        localStorage.setItem("diamantrouge-theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("diamantrouge-theme", "light");
      }
      return newVal;
    });
  };

  // ========== MOBILE NAV ==========
  const [mobileNavOpen, setMobileNavOpen] = useState(false);

  return (
    <header
      className={`fixed w-full z-50 transition-all duration-500 ${
        isScrolled
          ? "bg-brandIvory/90 shadow-luxury backdrop-blur-md"
          : "bg-transparent"
      }`}
    >
      {/* 
        ──────────────────────────────────────────────
        1) TOP BAR (optional "Conciergerie / Rendez-vous")
        ──────────────────────────────────────────────
      */}
      <div className="w-full bg-brandIvory/80 border-b border-platinumGray py-2 hidden md:block">
        <div className="max-w-screen-xl mx-auto px-4 flex items-center justify-between">
          <div className="flex items-center gap-4 text-richEbony">
            {/* Example: Chat / WhatsApp link */}
            <a
              href="https://wa.me/212555000111"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:text-burgundy hover-scale transition duration-300"
            >
              <MessageCircle size={20} />
            </a>
            <Link
              href="/appointments"
              className="flex items-center gap-1 hover:text-brandGold transition duration-300"
            >
              <Calendar size={18} />
              <span>Rendez-vous Privé</span>
            </Link>
          </div>
          <div className="text-sm text-richEbony italic">
            <span>Conciergerie de Luxe • Héritage Intemporel</span>
          </div>
        </div>
      </div>

      {/* 
        ──────────────────────────────────────────────
        2) LOGO ROW (centered logo)
        ──────────────────────────────────────────────
      */}
      <div
        className={`w-full ${
          isScrolled ? "bg-brandIvory/90 shadow-subtle" : "bg-brandIvory/80"
        }`}
      >
        <div className="max-w-screen-xl mx-auto px-4 py-3 flex justify-center">
          {/* 
            - The logo is strictly centered 
            - Use "relative" + "object-contain" to keep it crisp
          */}
          <Link href="/" className="relative w-[230px] h-[70px] hover-scale">
            <Image
              src="/images/logo_center.png"
              alt="Diamant Rouge"
              fill
              className="object-contain"
            />
          </Link>
        </div>
      </div>

      {/* 
        ──────────────────────────────────────────────
        3) MAIN NAV + ICONS (desktop)
        - Left: Nav items
        - Right: Icons (cart, wishlist, user, etc.)
        ──────────────────────────────────────────────
      */}
      <div
        className={`hidden md:block w-full ${
          isScrolled ? "bg-brandIvory/90" : "bg-brandIvory/80"
        }`}
      >
        <nav className="max-w-screen-xl mx-auto px-4 py-2 flex items-center justify-between">
          {/* 
            ── Nav Links (left) ── 
            Adjust to your brand pages
          */}
          <div className="flex items-center space-x-8 text-sm font-medium">
            <Link
              href="/"
              className="text-richEbony hover:text-brandGold transition duration-300"
            >
              Accueil
            </Link>
            <Link
              href="/collections"
              className="text-richEbony hover:text-brandGold transition duration-300"
            >
              Collections
            </Link>
            <Link
              href="/appointments"
              className="text-richEbony hover:text-brandGold transition duration-300"
            >
              Rendez-vous
            </Link>
            <Link
              href="/the-house"
              className="text-richEbony hover:text-brandGold transition duration-300"
            >
              La Maison
            </Link>
            <Link
              href="/contact"
              className="text-richEbony hover:text-brandGold transition duration-300"
            >
              Contact
            </Link>
          </div>

          {/* 
            ── Icons (right) ──
            Cart, wishlist, user, admin, theme
          */}
          <div className="flex items-center gap-5 text-richEbony">
            {/* Wishlist */}
            <Link href="/wishlist" className="relative hover-scale">
              <Heart className="text-brandGold" size={24} />
              {wishlist.length > 0 && (
                <span className="absolute -top-2 -right-2 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {wishlist.length}
                </span>
              )}
            </Link>
            {/* Cart */}
            <Link href="/cart" className="relative hover-scale">
              <ShoppingCart className="text-brandGold" size={24} />
              {cart.length > 0 && (
                <span className="absolute -top-2 -right-2 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {cart.length}
                </span>
              )}
            </Link>
            {/* Admin icon if role=admin */}
            {session?.user?.role === "admin" && (
              <Link
                href="/admin"
                className="hover-scale transition-transform duration-300"
              >
                <ShieldCheck className="text-brandGold" size={24} />
              </Link>
            )}
            {/* User Profile / Auth */}
            {session ? (
              <>
                <Link href="/profile" className="hover-scale">
                  <User className="text-brandGold" size={24} />
                </Link>
                <button
                  onClick={() => signOut()}
                  className="hover-scale text-brandGold"
                  title="Se déconnecter"
                >
                  <LogOut size={24} />
                </button>
              </>
            ) : (
              <Link href="/auth" className="hover-scale" title="Se connecter">
                <User className="text-brandGold" size={24} />
              </Link>
            )}
            {/* Theme Toggle */}
            <button
              onClick={handleThemeToggle}
              className="hover-scale text-brandGold"
            >
              {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
            </button>
          </div>
        </nav>
      </div>

      {/* 
        ──────────────────────────────────────────────
        4) MOBILE NAV (hamburger in the nav would reveal this)
        ──────────────────────────────────────────────
      */}
      <div className="md:hidden">
        {/* 
          - We place a "burger" in the main nav if you prefer, 
            or next to the logo row if that’s more convenient
          - For simplicity, let's place it floating in the top-right
        */}
        <button
          className={`absolute top-2 right-4 text-brandGold ${
            mobileNavOpen ? "hidden" : "block"
          }`}
          onClick={() => setMobileNavOpen(true)}
        >
          <Menu size={24} />
        </button>

        {/* Mobile Nav Drawer */}
        {mobileNavOpen && (
          <div className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 flex">
            <div className="w-3/4 max-w-[260px] bg-brandIvory h-full p-5 flex flex-col">
              {/* Close Button */}
              <button
                onClick={() => setMobileNavOpen(false)}
                className="self-end mb-5 text-richEbony hover:text-brandGold"
              >
                <X size={24} />
              </button>

              {/* Nav Links */}
              <Link
                href="/"
                className="py-2 text-richEbony hover:text-brandGold"
                onClick={() => setMobileNavOpen(false)}
              >
                Accueil
              </Link>
              <Link
                href="/collections"
                className="py-2 text-richEbony hover:text-brandGold"
                onClick={() => setMobileNavOpen(false)}
              >
                Collections
              </Link>
              <Link
                href="/appointments"
                className="py-2 text-richEbony hover:text-brandGold"
                onClick={() => setMobileNavOpen(false)}
              >
                Rendez-vous
              </Link>
              <Link
                href="/the-house"
                className="py-2 text-richEbony hover:text-brandGold"
                onClick={() => setMobileNavOpen(false)}
              >
                La Maison
              </Link>
              <Link
                href="/contact"
                className="py-2 text-richEbony hover:text-brandGold"
                onClick={() => setMobileNavOpen(false)}
              >
                Contact
              </Link>

              <div className="mt-5 border-t border-platinumGray pt-5 flex flex-col gap-3">
                {/* Wishlist & Cart */}
                <Link href="/wishlist" className="flex items-center gap-2">
                  <Heart className="text-brandGold" size={20} />
                  <span>Wishlist</span>
                  {wishlist.length > 0 && (
                    <span className="ml-auto bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                      {wishlist.length}
                    </span>
                  )}
                </Link>
                <Link href="/cart" className="flex items-center gap-2">
                  <ShoppingCart className="text-brandGold" size={20} />
                  <span>Panier</span>
                  {cart.length > 0 && (
                    <span className="ml-auto bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                      {cart.length}
                    </span>
                  )}
                </Link>

                {/* If Admin */}
                {session?.user?.role === "admin" && (
                  <Link href="/admin" className="flex items-center gap-2">
                    <ShieldCheck className="text-brandGold" size={20} />
                    <span>Admin</span>
                  </Link>
                )}

                {/* Auth / Profile */}
                {session ? (
                  <>
                    <Link
                      href="/profile"
                      className="flex items-center gap-2"
                      onClick={() => setMobileNavOpen(false)}
                    >
                      <User className="text-brandGold" size={20} />
                      <span>Mon Profil</span>
                    </Link>
                    <button
                      onClick={() => {
                        signOut();
                        setMobileNavOpen(false);
                      }}
                      className="flex items-center gap-2 text-richEbony"
                    >
                      <LogOut className="text-brandGold" size={20} />
                      <span>Se Déconnecter</span>
                    </button>
                  </>
                ) : (
                  <Link
                    href="/auth"
                    className="flex items-center gap-2"
                    onClick={() => setMobileNavOpen(false)}
                  >
                    <User className="text-brandGold" size={20} />
                    <span>Se Connecter</span>
                  </Link>
                )}

                {/* Theme Toggle */}
                <button
                  onClick={handleThemeToggle}
                  className="flex items-center gap-2"
                >
                  {isDarkMode ? (
                    <Sun className="text-brandGold" size={20} />
                  ) : (
                    <Moon className="text-brandGold" size={20} />
                  )}
                  <span>Mode {isDarkMode ? "Clair" : "Sombre"}</span>
                </button>
              </div>
            </div>

            {/* Click outside to close */}
            <div
              className="flex-1"
              onClick={() => setMobileNavOpen(false)}
            ></div>
          </div>
        )}
      </div>
    </header>
  );
}

Explanation & Key Points

    Three Distinct Rows for a polished layout:
        Row 1 (Top Bar): Optional “Conciergerie” references, Rendez-vous link, etc. Hidden on mobile for a cleaner layout if desired.
        Row 2 (Logo in Center): The brand hallmark. The logo is strictly centered to avoid shifting left or right.
        Row 3 (Main Nav + Icons):
            On desktop: Nav links on the left, icons (wishlist, cart, user, admin, theme) on the right.
            On mobile: A burger icon floats top-right, revealing a drawer menu with nav links and icons stacked.

    Consistent Indentation & Spacing
        Using max-w-screen-xl mx-auto px-4 or px-6 ensures the layout is tidy and evenly padded.
        The logo container has w-[230px] h-[70px], so it remains neatly scaled.

    Refined French Labels
        Menu items: “Accueil”, “Collections”, “Rendez-vous”, “La Maison”, “Contact”.
        Buttons or sub-links use short, concise text.

    Color & Styling
        Uses your brand color classes (bg-brandIvory, text-brandGold, bg-burgundy, etc.).
        Minimal design ensures luxury and refined feel.

    Responsive & User-Friendly
        On desktop, everything lines up in a single row with the logo row above it.
        On mobile, the user can tap the Menu button to open a drawer from the left.
        The logo row remains centered for consistency.

    Dark/Light Mode
        Toggles site-wide theme with document.documentElement.classList.add("dark") or .remove("dark").
        Manages preference in localStorage under "diamantrouge-theme".

    Role-Based Admin Link
        If session?.user?.role === "admin", shows an icon linking to /admin.

    Well-Structured Code
        Each section is clearly commented: top bar, logo row, main nav, mobile nav.
        The user can easily rearrange or remove sections if desired.

Next Steps

    Replace /images/logo_center.png and any references (WhatsApp number, brand tagline) with your actual assets.
    Adjust any copy or link paths to match your final site structure.
    Fine-tune heights, widths, or spacing (py-2, py-3, etc.) to your brand’s preference.

With this layout, the logo stays centered, the nav is tidy, and the indentation across sections is clean and readable, matching the Diamant Rouge luxury experience.
You said:
the header should be on first row, the logo centered the appointment and whatsapp icons at left , and the wishlist , cart account and others icons at right. then the second row embed the navigaitions  efficiently 

Below is a streamlined two-row header in French for Diamant Rouge that meets your specifications:

    First Row:
        Left: WhatsApp & Rendez-vous icons/links
        Center: Logo
        Right: Wishlist, Cart, User, (Admin if applicable), Theme Toggle

    Second Row:
        Navigation (Accueil, Collections, Rendez-vous, La Maison, Contact)

It also includes a mobile-friendly layout with a hamburger menu for the second row. Adjust branding, links, or icons as needed.

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { signOut, useSession } from "next-auth/react";
import { useCart } from "../contexts/CartContext";
import { useWishlist } from "../contexts/WishlistContext";
import {
  ShoppingCart,
  Heart,
  User,
  LogOut,
  Calendar,
  MessageCircle,
  ShieldCheck,
  Menu,
  X,
  Sun,
  Moon,
} from "lucide-react";

export default function Header() {
  const { cart } = useCart();
  const { wishlist } = useWishlist();
  const { data: session } = useSession();

  // Track scroll to apply sticky style
  const [isScrolled, setIsScrolled] = useState(false);
  useEffect(() => {
    const handleScroll = () => setIsScrolled(window.scrollY > 50);
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  // ========== THEME STATE ==========
  const [isDarkMode, setIsDarkMode] = useState(false);
  useEffect(() => {
    const savedTheme = localStorage.getItem("diamantrouge-theme");
    if (savedTheme === "dark") {
      setIsDarkMode(true);
      document.documentElement.classList.add("dark");
    } else {
      setIsDarkMode(false);
      document.documentElement.classList.remove("dark");
    }
  }, []);
  const handleThemeToggle = () => {
    setIsDarkMode((prev) => {
      const newVal = !prev;
      if (newVal) {
        document.documentElement.classList.add("dark");
        localStorage.setItem("diamantrouge-theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("diamantrouge-theme", "light");
      }
      return newVal;
    });
  };

  // ========== MOBILE NAV FOR 2ND ROW (NAV LINKS) ==========
  const [navOpen, setNavOpen] = useState(false);

  return (
    <header
      className={`fixed top-0 w-full z-50 transition-all duration-500 ${
        isScrolled
          ? "bg-brandIvory/90 shadow-luxury backdrop-blur-md"
          : "bg-transparent"
      }`}
    >
      {/* 
        ─────────────────────────────────────────
        1) FIRST ROW: Left(WhatsApp/RendezVous) - Center(Logo) - Right(Icons)
        ─────────────────────────────────────────
      */}
      <div
        className={`w-full ${
          isScrolled ? "bg-brandIvory/80 shadow-subtle" : "bg-brandIvory/70"
        }`}
      >
        <div className="max-w-screen-xl mx-auto px-4 py-2 flex items-center justify-between">
          {/* LEFT: WhatsApp & Rendez-vous */}
          <div className="flex items-center gap-4">
            {/* WhatsApp link */}
            <a
              href="https://wa.me/212555000111"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:text-burgundy hover-scale transition duration-300 text-richEbony"
              title="Contacter via WhatsApp"
            >
              <MessageCircle size={22} />
            </a>
            {/* Rendez-vous link */}
            <Link
              href="/appointments"
              className="flex items-center gap-1 text-richEbony hover:text-brandGold transition duration-300"
            >
              <Calendar size={18} />
              <span className="hidden sm:inline">Rendez-vous</span>
            </Link>
          </div>

          {/* CENTER: Logo */}
          <Link
            href="/"
            className="relative w-[200px] h-[60px] hover-scale transition-transform"
          >
            <Image
              src="/images/logo_center.png"
              alt="Diamant Rouge"
              fill
              className="object-contain"
            />
          </Link>

          {/* RIGHT: Icons (Wishlist, Cart, Admin, User, Theme) */}
          <div className="flex items-center gap-4">
            {/* Wishlist */}
            <Link href="/wishlist" className="relative hover-scale">
              <Heart className="text-brandGold" size={22} />
              {wishlist.length > 0 && (
                <span className="absolute -top-2 -right-3 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {wishlist.length}
                </span>
              )}
            </Link>
            {/* Cart */}
            <Link href="/cart" className="relative hover-scale">
              <ShoppingCart className="text-brandGold" size={22} />
              {cart.length > 0 && (
                <span className="absolute -top-2 -right-3 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {cart.length}
                </span>
              )}
            </Link>
            {/* Admin link (if role=admin) */}
            {session?.user?.role === "admin" && (
              <Link href="/admin" className="hover-scale">
                <ShieldCheck className="text-brandGold" size={22} />
              </Link>
            )}
            {/* Auth */}
            {session ? (
              <>
                <Link href="/profile" className="hover-scale">
                  <User className="text-brandGold" size={22} />
                </Link>
                <button
                  onClick={() => signOut()}
                  className="hover-scale text-brandGold"
                  title="Se déconnecter"
                >
                  <LogOut size={22} />
                </button>
              </>
            ) : (
              <Link href="/auth" className="hover-scale" title="Se connecter">
                <User className="text-brandGold" size={22} />
              </Link>
            )}
            {/* Theme Toggle */}
            <button
              onClick={handleThemeToggle}
              className="hover-scale text-brandGold"
              title="Basculer le thème"
            >
              {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
            </button>
          </div>
        </div>
      </div>

      {/* 
        ─────────────────────────────────────────
        2) SECOND ROW: Navigation (Desktop)
           Mobile toggled by burger icon
        ─────────────────────────────────────────
      */}
      <div
        className={`${
          isScrolled ? "bg-brandIvory/90 shadow-subtle" : "bg-brandIvory/70"
        } hidden md:block`}
      >
        <nav className="max-w-screen-xl mx-auto px-4 py-2 flex items-center space-x-8 text-sm font-medium text-richEbony">
          <Link href="/" className="hover:text-brandGold transition duration-300">
            Accueil
          </Link>
          <Link
            href="/collections"
            className="hover:text-brandGold transition duration-300"
          >
            Collections
          </Link>
          <Link
            href="/appointments"
            className="hover:text-brandGold transition duration-300"
          >
            Rendez-vous
          </Link>
          <Link
            href="/the-house"
            className="hover:text-brandGold transition duration-300"
          >
            La Maison
          </Link>
          <Link
            href="/contact"
            className="hover:text-brandGold transition duration-300"
          >
            Contact
          </Link>
        </nav>
      </div>

      {/* Mobile Nav Toggle Button (Hamburger) - visible on small screens */}
      <button
        className={`md:hidden absolute top-3 right-4 text-brandGold transition-transform ${
          navOpen ? "scale-0" : "scale-100"
        }`}
        onClick={() => setNavOpen(true)}
      >
        <Menu size={24} />
      </button>

      {/* 
        MOBILE NAV OVERLAY 
      */}
      {navOpen && (
        <div className="md:hidden fixed inset-0 bg-black/40 backdrop-blur-sm z-50 flex">
          {/* Drawer */}
          <div className="bg-brandIvory w-3/4 max-w-xs h-full p-5 flex flex-col">
            {/* Close button */}
            <button
              onClick={() => setNavOpen(false)}
              className="self-end text-richEbony hover:text-brandGold mb-4"
            >
              <X size={24} />
            </button>
            {/* Nav Items */}
            <Link
              href="/"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Accueil
            </Link>
            <Link
              href="/collections"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Collections
            </Link>
            <Link
              href="/appointments"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Rendez-vous
            </Link>
            <Link
              href="/the-house"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              La Maison
            </Link>
            <Link
              href="/contact"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Contact
            </Link>
          </div>

          {/* Click outside to close */}
          <div className="flex-1" onClick={() => setNavOpen(false)}></div>
        </div>
      )}
    </header>
  );
}

Explanation & Layout Details

    First Row (Single container):
        Left: WhatsApp + Rendez-vous
        Center: Logo (fixed width/height, strictly centered by justify-between with equal items on each side)
        Right: Wishlist, Cart, Admin, User/Auth, Theme Toggle

    Second Row (Navigation):
        Desktop: Shown by default with md:block (hidden on mobile)
        Mobile: Hidden by default, triggered by the hamburger (<Menu />) button which sets navOpen.

    Mobile Nav:
        An overlay dims the background, with a drawer from the left side.
        Contains the same nav links (Accueil, Collections, Rendez-vous, etc.).

    Scrolling Effect:
        When the user scrolls, isScrolled toggles background styles: bg-brandIvory/90, shadow-subtle, and a slight backdrop-blur-md.

    Theme Toggle:
        A simple button toggling Sun <-> Moon icons.
        Persists user’s choice in localStorage.

    Other Implementation Notes:
        The brand colors (bg-brandIvory, text-brandGold, bg-burgundy) come from your Tailwind config or globals.css.
        The icons each have a hover-scale effect for subtle, luxurious interactivity.
        Admin link only shows if session?.user?.role === "admin".

Further Customizations

    Replace the placeholder phone number (https://wa.me/212555000111) with your actual WhatsApp or remove if not needed.
    Adjust logo sizing or row paddings (px-4, py-2, etc.) to your brand’s comfort.
    Translate or rename links as you see fit (e.g., “La Maison” → “Notre Maison”, “Rendez-vous” → “Entretien Privé”, etc.).
    Test mobile thoroughly to ensure the layout maintains a refined look at all breakpoints.

With this final structure, you have a clean two-row header, centered logo in the first row, concise left and right blocks, and an efficient navigation row. This layout clearly showcases the Diamant Rouge identity and offers a user-friendly experience.
You said:
he second row navigation s aren't centred 

Below is a revised two-row header in French, ensuring that the first row (icons + logo + icons) remains the same while the second row navigation is perfectly centered on desktop. Only a small change is needed—adding justify-center to the nav container. The rest of the layout (mobile menu, theme toggle, etc.) remains intact.

"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import Image from "next/image";
import { signOut, useSession } from "next-auth/react";
import { useCart } from "../contexts/CartContext";
import { useWishlist } from "../contexts/WishlistContext";
import {
  ShoppingCart,
  Heart,
  User,
  LogOut,
  Calendar,
  MessageCircle,
  ShieldCheck,
  Menu,
  X,
  Sun,
  Moon,
} from "lucide-react";

export default function Header() {
  const { cart } = useCart();
  const { wishlist } = useWishlist();
  const { data: session } = useSession();

  // Track scroll to apply sticky style
  const [isScrolled, setIsScrolled] = useState(false);
  useEffect(() => {
    const handleScroll = () => setIsScrolled(window.scrollY > 50);
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  // ========== THEME STATE ==========
  const [isDarkMode, setIsDarkMode] = useState(false);
  useEffect(() => {
    const savedTheme = localStorage.getItem("diamantrouge-theme");
    if (savedTheme === "dark") {
      setIsDarkMode(true);
      document.documentElement.classList.add("dark");
    } else {
      setIsDarkMode(false);
      document.documentElement.classList.remove("dark");
    }
  }, []);
  const handleThemeToggle = () => {
    setIsDarkMode((prev) => {
      const newVal = !prev;
      if (newVal) {
        document.documentElement.classList.add("dark");
        localStorage.setItem("diamantrouge-theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("diamantrouge-theme", "light");
      }
      return newVal;
    });
  };

  // ========== MOBILE NAV FOR 2ND ROW (NAV LINKS) ==========
  const [navOpen, setNavOpen] = useState(false);

  return (
    <header
      className={`fixed top-0 w-full z-50 transition-all duration-500 ${
        isScrolled
          ? "bg-brandIvory/90 shadow-luxury backdrop-blur-md"
          : "bg-transparent"
      }`}
    >
      {/* 
        ─────────────────────────────────────────
        1) FIRST ROW: Left(WhatsApp/RendezVous) - Center(Logo) - Right(Icons)
        ─────────────────────────────────────────
      */}
      <div
        className={`w-full ${
          isScrolled ? "bg-brandIvory/80 shadow-subtle" : "bg-brandIvory/70"
        }`}
      >
        <div className="max-w-screen-xl mx-auto px-4 py-2 flex items-center justify-between">
          {/* LEFT: WhatsApp & Rendez-vous */}
          <div className="flex items-center gap-4">
            {/* WhatsApp link */}
            <a
              href="https://wa.me/212555000111"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:text-burgundy hover-scale transition duration-300 text-richEbony"
              title="Contacter via WhatsApp"
            >
              <MessageCircle size={22} />
            </a>
            {/* Rendez-vous link */}
            <Link
              href="/appointments"
              className="flex items-center gap-1 text-richEbony hover:text-brandGold transition duration-300"
            >
              <Calendar size={18} />
              <span className="hidden sm:inline">Rendez-vous</span>
            </Link>
          </div>

          {/* CENTER: Logo */}
          <Link
            href="/"
            className="relative w-[200px] h-[60px] hover-scale transition-transform"
          >
            <Image
              src="/images/logo_center.png"
              alt="Diamant Rouge"
              fill
              className="object-contain"
            />
          </Link>

          {/* RIGHT: Icons (Wishlist, Cart, Admin, User, Theme) */}
          <div className="flex items-center gap-4">
            {/* Wishlist */}
            <Link href="/wishlist" className="relative hover-scale">
              <Heart className="text-brandGold" size={22} />
              {wishlist.length > 0 && (
                <span className="absolute -top-2 -right-3 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {wishlist.length}
                </span>
              )}
            </Link>
            {/* Cart */}
            <Link href="/cart" className="relative hover-scale">
              <ShoppingCart className="text-brandGold" size={22} />
              {cart.length > 0 && (
                <span className="absolute -top-2 -right-3 bg-burgundy text-brandIvory text-xs px-2 py-0.5 rounded-full">
                  {cart.length}
                </span>
              )}
            </Link>
            {/* Admin link (if role=admin) */}
            {session?.user?.role === "admin" && (
              <Link href="/admin" className="hover-scale">
                <ShieldCheck className="text-brandGold" size={22} />
              </Link>
            )}
            {/* Auth */}
            {session ? (
              <>
                <Link href="/profile" className="hover-scale">
                  <User className="text-brandGold" size={22} />
                </Link>
                <button
                  onClick={() => signOut()}
                  className="hover-scale text-brandGold"
                  title="Se déconnecter"
                >
                  <LogOut size={22} />
                </button>
              </>
            ) : (
              <Link href="/auth" className="hover-scale" title="Se connecter">
                <User className="text-brandGold" size={22} />
              </Link>
            )}
            {/* Theme Toggle */}
            <button
              onClick={handleThemeToggle}
              className="hover-scale text-brandGold"
              title="Basculer le thème"
            >
              {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
            </button>
          </div>
        </div>
      </div>

      {/* 
        ─────────────────────────────────────────
        2) SECOND ROW: Navigation (Desktop)
           Centered content, mobile hidden.
        ─────────────────────────────────────────
      */}
      <div
        className={`${
          isScrolled ? "bg-brandIvory/90 shadow-subtle" : "bg-brandIvory/70"
        } hidden md:block`}
      >
        <nav className="max-w-screen-xl mx-auto px-4 py-2 flex items-center justify-center space-x-8 text-sm font-medium text-richEbony">
          <Link href="/" className="hover:text-brandGold transition duration-300">
            Accueil
          </Link>
          <Link
            href="/collections"
            className="hover:text-brandGold transition duration-300"
          >
            Collections
          </Link>
          <Link
            href="/appointments"
            className="hover:text-brandGold transition duration-300"
          >
            Rendez-vous
          </Link>
          <Link
            href="/the-house"
            className="hover:text-brandGold transition duration-300"
          >
            La Maison
          </Link>
          <Link
            href="/contact"
            className="hover:text-brandGold transition duration-300"
          >
            Contact
          </Link>
        </nav>
      </div>

      {/* Mobile Nav Toggle Button (Hamburger) - visible on small screens */}
      <button
        className={`md:hidden absolute top-3 right-4 text-brandGold transition-transform ${
          navOpen ? "scale-0" : "scale-100"
        }`}
        onClick={() => setNavOpen(true)}
      >
        <Menu size={24} />
      </button>

      {/* 
        MOBILE NAV OVERLAY 
      */}
      {navOpen && (
        <div className="md:hidden fixed inset-0 bg-black/40 backdrop-blur-sm z-50 flex">
          {/* Drawer */}
          <div className="bg-brandIvory w-3/4 max-w-xs h-full p-5 flex flex-col">
            {/* Close button */}
            <button
              onClick={() => setNavOpen(false)}
              className="self-end text-richEbony hover:text-brandGold mb-4"
            >
              <X size={24} />
            </button>
            {/* Nav Items */}
            <Link
              href="/"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Accueil
            </Link>
            <Link
              href="/collections"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Collections
            </Link>
            <Link
              href="/appointments"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Rendez-vous
            </Link>
            <Link
              href="/the-house"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              La Maison
            </Link>
            <Link
              href="/contact"
              className="py-2 text-richEbony hover:text-brandGold"
              onClick={() => setNavOpen(false)}
            >
              Contact
            </Link>
          </div>

          {/* Click outside to close */}
          <div className="flex-1" onClick={() => setNavOpen(false)}></div>
        </div>
      )}
    </header>
  );
}

What Changed?

    Second Row Nav
        The desktop navigation row (<nav>...</nav>) now has justify-center, which centers the navigation links horizontally.
        The container remains max-w-screen-xl mx-auto px-4 to keep your site neatly structured.

    First Row
        Left: WhatsApp + Rendez-vous
        Center: Logo (width 200px, height 60px to keep it balanced)
        Right: Wishlist, Cart, Admin (if applicable), User/Auth, Theme

    Styling & Spacing
        Subtle backgrounds: bg-brandIvory/70 or bg-brandIvory/90 if scrolled.
        Proper space-x-8 for nav links, ensuring they’re not crammed.

    Mobile Menu
        On small screens, the second row is hidden (hidden md:block).
        The Menu button (top-right) toggles a drawer from the left.

With this approach, your logo remains centered in the first row, while the second row navigation is also centered on desktop. This clean, two-row header design meets your brand’s luxury and user-friendly objectives.
You said:
let's move on now building the collections page where our Products are well displayed and an efficient divers filters if needed to enhance the product table from the database do so 
Reasoned for a second

Below is a Collections page example in Next.js + Tailwind that fetches products from your Prisma database and displays them in a flexible, filterable grid layout. The design prioritizes an elegant, luxury feel, integrating minimal text and letting product images and filters shine. You can customize filter fields (e.g., price ranges, categories, materials) to reflect your database schema.

// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import ProductCard from "../../components/ProductCard";
import { useState } from "react";
import { Product } from "@prisma/client"; // or your custom product type
import { motion } from "framer-motion";

type CollectionPageProps = {
  products: Product[];
  categories: string[]; // or any type as per your schema
  materials: string[];  // optional filter
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  try {
    // 1) Fetch all products
    // Adjust to your schema if you store categories, materials, etc.
    const products = await prisma.product.findMany({
      include: { translations: true, variations: true },
    });

    // 2) Fetch distinct categories or material from your DB 
    // (assuming you store 'category' or 'material' in the product schema)
    const categories = await prisma.product.findMany({
      distinct: ["category"],
      select: { category: true },
    });
    const materials = await prisma.product.findMany({
      distinct: ["material"],
      select: { material: true },
    });

    return {
      props: {
        products: JSON.parse(JSON.stringify(products)),
        categories: categories.map((c) => c.category).filter(Boolean),
        materials: materials.map((m) => m.material).filter(Boolean),
      },
    };
  } catch (error) {
    console.error("❌ Error fetching collections:", error);
    return {
      props: { products: [], categories: [], materials: [] },
    };
  }
};

export default function CollectionsPage({
  products,
  categories,
  materials,
}: CollectionPageProps) {
  // ---------- FILTER STATE ----------
  const [selectedCategory, setSelectedCategory] = useState<string>("");
  const [selectedMaterial, setSelectedMaterial] = useState<string>("");
  const [maxPrice, setMaxPrice] = useState<number | "">("");

  // ---------- FILTERED PRODUCTS ----------
  const filteredProducts = products.filter((product) => {
    // 1) Category filter
    if (selectedCategory && product.category !== selectedCategory) {
      return false;
    }
    // 2) Material filter
    if (selectedMaterial && product.material !== selectedMaterial) {
      return false;
    }
    // 3) Price filter
    if (maxPrice !== "" && product.price > Number(maxPrice)) {
      return false;
    }

    return true;
  });

  return (
    <div className="min-h-screen bg-brandIvory text-richEbony">
      {/* HEAD / TITLE / META */}
      <header className="py-16 text-center">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Nos Collections
        </h1>
        <p className="text-platinumGray">
          Découvrez nos pièces intemporelles, façonnées dans l’excellence.
        </p>
      </header>

      {/* FILTERS SECTION */}
      <section className="max-w-screen-xl mx-auto px-4 py-8">
        <div className="flex flex-col md:flex-row items-center md:items-end md:justify-between gap-6">
          {/* Category Filter */}
          <div className="flex flex-col">
            <label htmlFor="category" className="text-sm mb-1 text-platinumGray">
              Catégorie
            </label>
            <select
              id="category"
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              className="input-field w-48"
            >
              <option value="">Toutes</option>
              {categories.map((cat) => (
                <option key={cat} value={cat}>
                  {cat}
                </option>
              ))}
            </select>
          </div>

          {/* Material Filter (Optional) */}
          <div className="flex flex-col">
            <label
              htmlFor="material"
              className="text-sm mb-1 text-platinumGray"
            >
              Matériau
            </label>
            <select
              id="material"
              value={selectedMaterial}
              onChange={(e) => setSelectedMaterial(e.target.value)}
              className="input-field w-48"
            >
              <option value="">Tous</option>
              {materials.map((mat) => (
                <option key={mat} value={mat}>
                  {mat}
                </option>
              ))}
            </select>
          </div>

          {/* Price Filter (max price) */}
          <div className="flex flex-col">
            <label htmlFor="price" className="text-sm mb-1 text-platinumGray">
              Prix Max (MAD)
            </label>
            <input
              type="number"
              id="price"
              placeholder="ex: 50000"
              value={maxPrice}
              onChange={(e) => setMaxPrice(e.target.value ? Number(e.target.value) : "")}
              className="input-field w-48"
            />
          </div>
        </div>
      </section>

      {/* PRODUCTS GRID */}
      <motion.section
        className="max-w-screen-xl mx-auto px-4 py-8"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        {filteredProducts.length === 0 ? (
          <div className="text-center py-16 text-platinumGray">
            <h2 className="text-2xl font-serif text-brandGold mb-4">
              Aucun produit trouvé
            </h2>
            <p className="text-platinumGray">
              Essayez d’ajuster vos filtres ou revenez plus tard.
            </p>
          </div>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-6">
            {filteredProducts.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>
        )}
      </motion.section>
    </div>
  );
}

Key Points & Best Practices

    Fetching Data
        Server-Side Rendering (getServerSideProps) fetches products, categories, and materials (or any other data needed for filters).
        If you store categories in a separate table, you could query that table directly.
        For more advanced filtering (by brand, stone type, etc.), fetch those fields accordingly.

    Filtering Logic
        We keep the filter state in the client (using useState).
        The filteredProducts array is derived from the original products.
        For truly large databases, consider server-side or client-side pagination, or an API-based filter approach to keep performance optimal.

    Elegant, Minimal UI
        The filter bar is kept simple: a few <select> dropdowns and an <input> for price.
        The product grid uses Tailwind classes (e.g., grid-cols-3 for a clean, symmetrical display).

    ProductCard
        We assume you have a <ProductCard /> component that handles the display (image, name, price, etc.).
        The snippet references <ProductCard key={product.id} product={product} />.

    Styling & Branding
        The page uses your brand’s variables:
            bg-brandIvory, text-richEbony, text-brandGold, text-platinumGray, etc.
        .input-field is a custom class from your globals.css or ProductFilters styling.
        You can add fancy hover transitions for product images, shadows, or more to evoke the luxury brand feel.

    Localization & Copy
        Text is in French, but adapt if you’re also supporting Arabic/English.
        For example, “Catégorie,” “Matériau,” “Prix Max,” “Toutes,” etc.

    Framer Motion
        Adds a subtle fade/slide-in animation for the product grid.
        You can animate filters too, or add more transitions for a refined, pleasing effect.

Possible Enhancements

    Price Range Slider
        Instead of a single “max price” text field, you can implement a range slider (e.g., [0, 100000]) for a smoother user experience.

    Pagination or Infinite Scroll
        If you have hundreds or thousands of products, consider paginating them.
        You could fetch data client-side with an API route if you want real-time filter updates.

    Additional Filters
        Stone types (e.g., diamond, emerald, sapphire).
        Color or metal type (gold, silver, platinum).
        Sorting (e.g., by price ascending/descending, new arrivals, best sellers).

    Search Bar
        Add a text-based search for product names or tags.

With this structure, you have a flexible Collections page that merges an elegant layout with practical filtering, highlighting your Diamant Rouge products. Let me know if you’d like more advanced filtering features or a different layout style!
You said:
heres the database schema , is it conforme ? : "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String // hashed password stored here
  name      String?
  role      String   @default("customer") // can be 'admin' or 'customer'
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"

Overall, your Prisma schema looks solid and conforms to standard Next.js + Prisma best practices. The relationships are well-defined (one-to-many, many-to-many through relation tables), and the choice of Decimal, DateTime, String[] types is appropriate for an e-commerce setting. Below are a few observations and potential improvements you might consider:
1. Product Model

Current Setup

model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
}

    Price Field vs. basePrice
        If you ever need promotional price or dynamic pricing (beyond variations), consider adding additional fields or logic. Currently, basePrice is your main price reference.

    Material & Other Attributes
        You’ve mentioned “material” or other potential product attributes in your design discussions. Right now, “material” can be stored under ProductVariation.variationType/variationValue if you like. Alternatively, if you want a dedicated field for material in the Product table, you can add something like:

        material String?

        This is optional and depends on how flexible you want your data model for product attributes.

    Images
        Storing an array of image URLs (String[]) is perfectly fine. If you plan on more complex image metadata or transformations, you might end up referencing a dedicated Media table or using third-party storage services.

2. Category & Translations

model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

This is a clean setup. You’re decoupling CategoryTranslation for i18n, similar to your ProductTranslation approach. Make sure your code consistently references the correct translated fields when you display category names on the front-end.
3. Product Variations

model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

    Variation Types
        You can store ring sizes, gem types, metals, etc. If you want to keep adding more dimension types, it’s flexible.
    Inventory
        Handy for tracking stock of specific variations. If you need multiple fields (e.g., ring size + metal color combos), you might eventually store these as separate columns or a single JSON. But this current approach is perfectly valid.

4. User, Orders, and OrderItems

model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING")
  paymentMethod String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

    You have a good foundation for basic e-commerce.
    If you ever need refunds, partial shipments, or coupons, consider adding new fields or tables.
    The status field is a simple string; you might eventually switch to an enum if you want stricter typed states.

5. Wishlist & Appointments

model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId])
}

    Wishlist is straightforward, with a unique constraint preventing duplicates.

model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}

    Simple for now. If you want to link appointments to a user, you could add a userId foreign key.

6. General Observations

    Relationships
        You’ve used many one-to-many relations with clear fields referencing the id of the parent. This is exactly how Prisma recommends structuring.
    Data Consistency
        Because onDelete: Cascade is used in the wishlist table, removing a product or user can automatically delete relevant wishlist rows. That’s good for cleaning up stale references.
    Localized Fields
        You rely on translation sub-models, which is consistent for multi-language setups. Make sure your front-end queries the correct language for each user’s locale.
    Decimal
        For pricing, Decimal is correct. Ensure your queries are cast to the proper number type on the front-end if needed.

Conclusion & Recommendations

    Your schema is well-structured and conformant with typical Next.js + Prisma e-commerce patterns.
    The biggest question is whether you want to store material, gemstone, etc., as explicit columns in Product or rely on ProductVariation. Both approaches are valid, but may affect how you filter queries (especially if you plan to do large-scale advanced filtering).
    For expansions (coupons, sub-orders, custom designs, etc.), you can always add more models or columns.

In short, the schema is already production-ready for a luxury jewelry store. Just be sure to keep an eye on any advanced requirements (inventory logic, advanced filters, multi-currency, etc.) and refine as your store grows!
You said:
so why i get : "TypeError: The "payload" argument must be of type object. Received null
    at cloneSourceMapV3 (node:internal/source_map/source_map:365:3)
    at new SourceMap (node:internal/source_map/source_map:145:21)
    at findSourceMap (node:internal/source_map/source_map_cache:339:17)
    at getSourcemappedFrameIfPossible (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/patch-error-inspect.js:163:90)
    at parseAndSourceMap (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/patch-error-inspect.js:265:39)
    at sourceMapError (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/patch-error-inspect.js:288:22)
    at <unknown> (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/patch-error-inspect.js:306:30)
    at AsyncLocalStorage.exit (node:async_hooks:354:14)
    at errorConstructor.<computed> (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/patch-error-inspect.js:305:67)
    at formatValue (node:internal/util/inspect:809:19)
    at inspect (node:internal/util/inspect:368:10)
    at formatWithOptionsInternal (node:internal/util/inspect:2307:40)
    at formatWithOptions (node:internal/util/inspect:2169:10)
    at console.value (node:internal/console/constructor:350:14)
    at console.warn (node:internal/console/constructor:383:61)
    at getServerSideProps (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/.next/server/chunks/ssr/[root of the server]__d81b2e._.js:1218:17)
    at async renderToHTMLImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/compiled/next-server/pages.runtime.dev.js:33:168)
    at async doRender (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:1528:38)
    at async responseGenerator (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:1822:28)
    at async DevServer.renderToResponseWithComponentsImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:1832:28)
    at async DevServer.renderPageComponent (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:2259:24)
    at async DevServer.renderToResponseImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:2297:32)
    at async DevServer.pipeImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:959:25)
    at async NextNodeServer.handleCatchallRenderRequest (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/next-server.js:281:17)
    at async DevServer.handleRequestImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/base-server.js:853:17)
    at async (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/dev/next-dev-server.js:371:20)
    at async Span.traceAsyncFn (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/trace/trace.js:153:20)
    at async DevServer.handleRequest (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/dev/next-dev-server.js:368:24)
    at async invokeRender (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/lib/router-server.js:230:21)
    at async handleRequest (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/lib/router-server.js:408:24)
    at async requestHandlerImpl (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/lib/router-server.js:432:13)
    at async Server.requestListener (file:///home/dr_house/Documents/pro/diamant-rouge/diamant-rouge/node_modules/next/dist/server/lib/start-server.js:146:13)"  on the category page : "// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import ProductCard from "../../components/ProductCard";
import { useState } from "react";
import { Product } from "@prisma/client"; // or your custom product type
import { motion } from "framer-motion";

type CollectionPageProps = {
    products: Product[];
    categories: string[]; // or any type as per your schema
    materials: string[];  // optional filter
};

export const getServerSideProps: GetServerSideProps = async (context) => {
    try {
        // 1) Fetch all products
        // Adjust to your schema if you store categories, materials, etc.
        const products = await prisma.product.findMany({
            include: { translations: true, variations: true },
        });

        // 2) Fetch distinct categories or material from your DB
        // (assuming you store 'category' or 'material' in the product schema)
        const categories = await prisma.product.findMany({
            distinct: ["category"],
            select: { category: true },
        });
        const materials = await prisma.product.findMany({
            distinct: ["material"],
            select: { material: true },
        });

        return {
            props: {
                products: JSON.parse(JSON.stringify(products)),
                categories: categories.map((c) => c.category).filter(Boolean),
                materials: materials.map((m) => m.material).filter(Boolean),
            },
        };
    } catch (error) {
        console.error("❌ Error fetching collections:", error);
        return {
            props: { products: [], categories: [], materials: [] },
        };
    }
};

export default function CollectionsPage({
                                            products,
                                            categories,
                                            materials,
                                        }: CollectionPageProps) {
    // ---------- FILTER STATE ----------
    const [selectedCategory, setSelectedCategory] = useState<string>("");
    const [selectedMaterial, setSelectedMaterial] = useState<string>("");
    const [maxPrice, setMaxPrice] = useState<number | "">("");

    // ---------- FILTERED PRODUCTS ----------
    const filteredProducts = products.filter((product) => {
        // 1) Category filter
        if (selectedCategory && product.category !== selectedCategory) {
            return false;
        }
        // 2) Material filter
        if (selectedMaterial && product.material !== selectedMaterial) {
            return false;
        }
        // 3) Price filter
        if (maxPrice !== "" && product.price > Number(maxPrice)) {
            return false;
        }

        return true;
    });

    return (
        <div className="min-h-screen bg-brandIvory text-richEbony">
            {/* HEAD / TITLE / META */}
            <header className="py-16 text-center">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Nos Collections
                </h1>
                <p className="text-platinumGray">
                    Découvrez nos pièces intemporelles, façonnées dans l’excellence.
                </p>
            </header>

            {/* FILTERS SECTION */}
            <section className="max-w-screen-xl mx-auto px-4 py-8">
                <div className="flex flex-col md:flex-row items-center md:items-end md:justify-between gap-6">
                    {/* Category Filter */}
                    <div className="flex flex-col">
                        <label htmlFor="category" className="text-sm mb-1 text-platinumGray">
                            Catégorie
                        </label>
                        <select
                            id="category"
                            value={selectedCategory}
                            onChange={(e) => setSelectedCategory(e.target.value)}
                            className="input-field w-48"
                        >
                            <option value="">Toutes</option>
                            {categories.map((cat) => (
                                <option key={cat} value={cat}>
                                    {cat}
                                </option>
                            ))}
                        </select>
                    </div>

                    {/* Material Filter (Optional) */}
                    <div className="flex flex-col">
                        <label
                            htmlFor="material"
                            className="text-sm mb-1 text-platinumGray"
                        >
                            Matériau
                        </label>
                        <select
                            id="material"
                            value={selectedMaterial}
                            onChange={(e) => setSelectedMaterial(e.target.value)}
                            className="input-field w-48"
                        >
                            <option value="">Tous</option>
                            {materials.map((mat) => (
                                <option key={mat} value={mat}>
                                    {mat}
                                </option>
                            ))}
                        </select>
                    </div>

                    {/* Price Filter (max price) */}
                    <div className="flex flex-col">
                        <label htmlFor="price" className="text-sm mb-1 text-platinumGray">
                            Prix Max (MAD)
                        </label>
                        <input
                            type="number"
                            id="price"
                            placeholder="ex: 50000"
                            value={maxPrice}
                            onChange={(e) => setMaxPrice(e.target.value ? Number(e.target.value) : "")}
                            className="input-field w-48"
                        />
                    </div>
                </div>
            </section>

            {/* PRODUCTS GRID */}
            <motion.section
                className="max-w-screen-xl mx-auto px-4 py-8"
                initial={{ opacity: 0, y: 30 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5 }}
            >
                {filteredProducts.length === 0 ? (
                    <div className="text-center py-16 text-platinumGray">
                        <h2 className="text-2xl font-serif text-brandGold mb-4">
                            Aucun produit trouvé
                        </h2>
                        <p className="text-platinumGray">
                            Essayez d’ajuster vos filtres ou revenez plus tard.
                        </p>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-6">
                        {filteredProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                )}
            </motion.section>
        </div>
    );
}
"

The root cause here is that your code attempts to fetch (and then filter by) fields (category, material) which do not actually exist in your Product model. In your Prisma schema, a Product has these relevant fields:

model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  categoryId   Int?
  category     Category?            @relation(fields: [categoryId], references: [id])
  ...
}

But there is no category: String nor material: String column in Product. Instead, you have a relation to a Category model (not a plain string). Hence, the lines:

const categories = await prisma.product.findMany({
  distinct: ["category"],
  select: { category: true },
});

…and

const materials = await prisma.product.findMany({
  distinct: ["material"],
  select: { material: true },
});

…are invalid because category and material columns do not exist. That typically leads to a failing query or undefined data that can trigger the odd “payload must be of type object” error when Next.js tries to parse the sourcemap for the thrown error.
How to Fix It

You have two main options:
Option 1: Store Category & Material as Direct Fields

If you really want product.category (a string) or product.material (a string) in the Product table, you must add those columns in your Prisma schema. For instance:

model Product {
  id           Int       @id @default(autoincrement())
  sku          String    @unique
  basePrice    Decimal   @default(0.0)
  category     String?   // <-- newly added if you want a direct string category
  material     String?   // <-- newly added if you want a direct string material
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  images       String[]  @default([])
  // ...
}

Then you could do:

// distinct category strings
const categories = await prisma.product.findMany({
  distinct: ["category"],
  select: { category: true },
});

// distinct material strings
const materials = await prisma.product.findMany({
  distinct: ["material"],
  select: { material: true },
});

And your filter code referencing product.category or product.material would work:

// if (selectedCategory && product.category !== selectedCategory) { ... }

However, this bypasses your more advanced Category model with translations.
Option 2: Use Your Existing Category Relation

Currently, Product references a Category record via:

categoryId   Int?
category     Category?  @relation(fields: [categoryId], references: [id])

But there is no plain string column named category in Product. Instead, if you want all the distinct categories, you should query the Category table itself, for example:

// Distinct categories from the Category table
const categoryRecords = await prisma.category.findMany({
  select: { id: true, slug: true }, // or translations if needed
});

Then you can pass the slugs/names to the props:

const categories = categoryRecords.map((cat) => cat.slug);

On the front end, you could display these slugs in a dropdown. But in your filter logic, you’d need to do a join or an include so that each Product has its Category’s slug. For instance:

const products = await prisma.product.findMany({
  include: {
    category: {
      select: { slug: true },
    },
    translations: true,
    variations: true,
  },
});

Then each product might look like:

{
  "id": 1001,
  "sku": "XYZ123",
  "basePrice": "599.00",
  "category": {
    "slug": "bagues"
  },
  ...
}

So your filter would become:

if (selectedCategory && product.category?.slug !== selectedCategory) {
  return false;
}

Similarly, if you want “materials” or “metals,” you could store them in the ProductVariation model (e.g., variationType = "metal", variationValue = "or"). But that’s more advanced. If you want a direct material column, just add it to the schema as well.
In Summary

    Your error arises because Prisma can’t do distinct: ["category"] on a field that doesn’t exist, or Next.js is blowing up when it sees invalid fields.

    Decide whether you want simple string columns (category, material) or if you want to leverage your Category model relation.

    Adjust your code accordingly:
        If storing a plain string: add category String? (and material String?) to Product.
        If using the Category model: query the Category table, then use product.category?.slug for filtering.

Once you fix the mismatch between your filters and your actual Prisma fields, that “payload must be of type object” error will disappear.
You said:
let's go for the second option 

Below is an updated collections/index.tsx example that uses your existing Category relation rather than a non-existent product.category string field. It demonstrates how to:

    Fetch categories from the Category table (using slug or any unique field).
    Include each product’s category (so you can filter by product.category?.slug).
    Adjust references to basePrice (rather than price) if you want to filter by price.

Feel free to remove or adapt any references to “material” if you’re not actually storing materials anywhere. We’ll omit “material” in this snippet for clarity.

// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import { useState } from "react";
import { motion } from "framer-motion";
import ProductCard from "../../components/ProductCard";

// Replace with your actual Product type if you have a custom TS interface
import type { Product } from "@prisma/client";

type CollectionPageProps = {
  products: Array<Product & { category?: { slug: string } | null }>;
  categories: string[];
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  try {
    // 1) Fetch categories from the Category table
    const categoryRecords = await prisma.category.findMany({
      select: { slug: true },
    });

    // 2) Fetch all products, including the Category slug
    const products = await prisma.product.findMany({
      include: {
        translations: true,
        variations: true,
        category: {
          select: { slug: true },
        },
      },
    });

    // 3) Convert to JSON for Next.js
    return {
      props: {
        products: JSON.parse(JSON.stringify(products)),
        categories: categoryRecords.map((cat) => cat.slug),
      },
    };
  } catch (error) {
    console.error("❌ Error fetching collections:", error);
    return {
      props: { products: [], categories: [] },
    };
  }
};

export default function CollectionsPage({
  products,
  categories,
}: CollectionPageProps) {
  // ----- FILTER STATE -----
  const [selectedCategory, setSelectedCategory] = useState<string>("");
  const [maxPrice, setMaxPrice] = useState<number | "">("");

  // ----- FILTERED PRODUCTS -----
  // Remember your product's price is stored in `product.basePrice`, not `product.price`.
  const filteredProducts = products.filter((product) => {
    // 1) Category filter (check product.category?.slug)
    if (selectedCategory && product.category?.slug !== selectedCategory) {
      return false;
    }
    // 2) Price filter (assuming basePrice is numeric)
    if (maxPrice !== "") {
      // Convert basePrice to number if it's returned as a string
      const basePriceNum = Number(product.basePrice);
      if (basePriceNum > Number(maxPrice)) {
        return false;
      }
    }
    return true;
  });

  return (
    <div className="min-h-screen bg-brandIvory text-richEbony">
      {/* PAGE HEADER */}
      <header className="py-16 text-center">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Nos Collections
        </h1>
        <p className="text-platinumGray">
          Découvrez nos pièces intemporelles, façonnées dans l’excellence.
        </p>
      </header>

      {/* FILTERS SECTION */}
      <section className="max-w-screen-xl mx-auto px-4 py-8">
        <div className="flex flex-col md:flex-row items-center md:items-end md:justify-between gap-6">
          {/* Category Filter */}
          <div className="flex flex-col">
            <label
              htmlFor="category"
              className="text-sm mb-1 text-platinumGray"
            >
              Catégorie
            </label>
            <select
              id="category"
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              className="input-field w-48"
            >
              <option value="">Toutes</option>
              {categories.map((catSlug) => (
                <option key={catSlug} value={catSlug}>
                  {catSlug}
                </option>
              ))}
            </select>
          </div>

          {/* Price Filter (max price) */}
          <div className="flex flex-col">
            <label htmlFor="price" className="text-sm mb-1 text-platinumGray">
              Prix Max (MAD)
            </label>
            <input
              type="number"
              id="price"
              placeholder="ex: 50000"
              value={maxPrice}
              onChange={(e) =>
                setMaxPrice(e.target.value ? Number(e.target.value) : "")
              }
              className="input-field w-48"
            />
          </div>
        </div>
      </section>

      {/* PRODUCTS GRID */}
      <motion.section
        className="max-w-screen-xl mx-auto px-4 py-8"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        {filteredProducts.length === 0 ? (
          <div className="text-center py-16 text-platinumGray">
            <h2 className="text-2xl font-serif text-brandGold mb-4">
              Aucun produit trouvé
            </h2>
            <p className="text-platinumGray">
              Essayez d’ajuster vos filtres ou revenez plus tard.
            </p>
          </div>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-6">
            {filteredProducts.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>
        )}
      </motion.section>
    </div>
  );
}

How It Works

    Use the Existing Category Relation
        We fetch categories from the Category table (rather than a nonexistent category column in Product).
        Each Product includes its related category.slug.

    Filter by product.category?.slug
        The user picks a category slug from the dropdown, and we compare it to the product’s category?.slug.
        If it doesn’t match, we exclude that product.

    Base Price
        In your schema, you have basePrice (type Decimal) in Product, so we reference product.basePrice instead of product.price.
        We do Number(product.basePrice) inside the filter for numeric comparisons.

    Removed “Material”
        Since there’s no material in your Product table or a separate “material” reference, we keep it simple. Add it back if you store “material” in ProductVariation or if you add a material String? column to Product.

    Potential Translations
        If your Category has translations and you want a “name” in French, you’d query them in include or do a separate fetch from CategoryTranslation. For example:

        include: {
          translations: {
            where: { language: "fr" }
          }
        }

        Then display that name in the dropdown. But as a basic approach, using the slug is enough.

Next Steps

    Enhance the Category Slug
        Use a more user-friendly label for the dropdown (e.g., “Bagues” instead of “rings”), possibly from CategoryTranslation.

    Add Additional Filters
        If you store “material” or “gemstone” in ProductVariation, you could do a second query for distinct variationValue where variationType = 'material'. Then filter on the front-end by checking each product’s variations array.

    UI/UX Touches
        Style the dropdown more elegantly, or use a Tailwind UI select menu for a fancier look.
        Add a range slider for price instead of a single “max” input.

With these changes, you’ll no longer get errors about a missing category field, and your collections page can properly filter by the Category table’s slug.
You said:
 wont a  more relevant and efficient filters where we filter by materials where a product can hae multiple materials, by event or by  price or any other erelevent filter where user can filter many

Below is a broader, more robust filtering approach for your Collections page, supporting multi-select filters (e.g., multiple materials, events, or any other relevant attributes), price range, and category. We’ll cover two main parts:

    Database Schema Adjustments – How to store multi-value attributes (materials, events) effectively.
    Next.js Filter Implementation – A dynamic approach where users can choose multiple filters simultaneously.

1. Database Schema Adjustments
A) Using Array Fields in Product

If each Product can have multiple materials/events, the quickest approach is to store them as array fields (like String[]) within Product. For example:

model Product {
  id           Int        @id @default(autoincrement())
  sku          String     @unique
  basePrice    Decimal    @default(0.0)
  materials    String[]   @default([]) // 🏆 multi materials
  events       String[]   @default([]) // 🏆 e.g. "Mariage", "Fiançailles", "Cérémonie", etc.
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  images       String[]   @default([])

  // ... existing fields & relations ...
}

    Then you can query with where: { materials: { hasSome: ['Gold', 'Silver'] } } or hasEvery depending on your logic.
    The same approach works for events (e.g., where: { events: { has: 'Mariage' } }).

B) Many-to-Many Relationship for Materials/Events

If you want to store detailed info about materials or events (like translations, descriptions), you can create dedicated Material and Event models:

model Material {
  id        Int        @id @default(autoincrement())
  name      String     @unique
  products  Product[]  @relation("ProductMaterials")
}

model Event {
  id        Int        @id @default(autoincrement())
  name      String     @unique
  products  Product[]  @relation("ProductEvents")
}

model Product {
  id           Int        @id @default(autoincrement())
  sku          String     @unique
  basePrice    Decimal    @default(0.0)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // M2M for materials
  materials    Material[] @relation("ProductMaterials")

  // M2M for events
  events       Event[]    @relation("ProductEvents")

  // ... rest of your fields ...
}

Then you’d have join tables automatically created by Prisma. You can filter with something like:

where: {
  materials: {
    some: {
      name: { in: ['Or', 'Argent'] },
    },
  },
  events: {
    some: {
      name: { in: ['Mariage', 'Baptême'] },
    },
  },
},

Either approach is valid. Array fields are simpler to maintain if you don’t need separate tables for materials/events. Many-to-many is more flexible for expansions (translations, advanced data).
2. Next.js Filter Implementation

Below is an example collections/index.tsx with multiple filters:

    Category (string, from your existing Category relation).
    Materials (array or M2M).
    Events (array or M2M).
    Price Range (min & max).

For simplicity, let’s assume you chose array fields in your schema:

model Product {
  id         Int       @id @default(autoincrement())
  sku        String    @unique
  basePrice  Decimal   @default(0.0)
  materials  String[]  @default([])
  events     String[]  @default([])
  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id])
  // ...
}

A) Server-Side Data Fetching

We’ll fetch:

    Distinct category slugs (from Category).
    Distinct materials (from all products) by flattening product materials arrays.
    Distinct events (same approach).

Then we include the category relation in the products so we can filter on the front end or do it server side.

// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import { useState } from "react";
import { motion } from "framer-motion";
import ProductCard from "../../components/ProductCard";

// If you have a Product type with array fields:
import type { Product } from "@prisma/client";

type FullProduct = Product & {
  category?: { slug: string } | null;
};

type CollectionsProps = {
  products: FullProduct[];
  categories: string[];
  materials: string[];
  events: string[];
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  // 1) Get all categories
  const categoryRecords = await prisma.category.findMany({
    select: { slug: true },
  });
  const categories = categoryRecords.map((cat) => cat.slug);

  // 2) Get all products (with included category)
  const productRecords = await prisma.product.findMany({
    include: {
      category: { select: { slug: true } },
    },
  });

  // 3) Derive distinct materials / events by flattening arrays
  const allMaterials = new Set<string>();
  const allEvents = new Set<string>();

  productRecords.forEach((p) => {
    p.materials.forEach((m) => allMaterials.add(m));
    p.events.forEach((e) => allEvents.add(e));
  });

  return {
    props: {
      products: JSON.parse(JSON.stringify(productRecords)),
      categories,
      materials: Array.from(allMaterials),
      events: Array.from(allEvents),
    },
  };
};

export default function CollectionsPage({
  products,
  categories,
  materials,
  events,
}: CollectionsProps) {
  // ----- FILTER STATES -----
  const [selectedCategory, setSelectedCategory] = useState("");
  const [selectedMaterials, setSelectedMaterials] = useState<string[]>([]);
  const [selectedEvents, setSelectedEvents] = useState<string[]>([]);
  const [minPrice, setMinPrice] = useState<number | "">("");
  const [maxPrice, setMaxPrice] = useState<number | "">("");

  // ----- HANDLERS -----
  const handleMaterialToggle = (mat: string) => {
    setSelectedMaterials((prev) =>
      prev.includes(mat)
        ? prev.filter((m) => m !== mat)
        : [...prev, mat]
    );
  };

  const handleEventToggle = (evt: string) => {
    setSelectedEvents((prev) =>
      prev.includes(evt) ? prev.filter((e) => e !== evt) : [...prev, evt]
    );
  };

  // ----- FILTERED PRODUCTS -----
  const filteredProducts = products.filter((product) => {
    // Category filter
    if (selectedCategory && product.category?.slug !== selectedCategory) {
      return false;
    }
    // Materials multi-select
    if (selectedMaterials.length > 0) {
      // If the product MUST have ALL selected materials => check every
      // If it can have ANY of them => check some
      // We'll do "any" example (some):
      const hasSome = selectedMaterials.some((mat) =>
        product.materials.includes(mat)
      );
      if (!hasSome) return false;
    }
    // Events multi-select
    if (selectedEvents.length > 0) {
      const hasSome = selectedEvents.some((evt) =>
        product.events.includes(evt)
      );
      if (!hasSome) return false;
    }
    // Price filter
    const priceNum = Number(product.basePrice);
    if (minPrice !== "" && priceNum < minPrice) {
      return false;
    }
    if (maxPrice !== "" && priceNum > maxPrice) {
      return false;
    }
    return true;
  });

  return (
    <div className="min-h-screen bg-brandIvory text-richEbony">
      {/* HEADER */}
      <header className="py-16 text-center">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Nos Collections
        </h1>
        <p className="text-platinumGray">
          Trouvez la pièce idéale parmi nos multiples matériaux et événements.
        </p>
      </header>

      {/* FILTERS SECTION */}
      <section className="max-w-screen-xl mx-auto px-4 py-8">
        {/* Layout your filters in a flexible grid or columns */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
          {/* Category Filter */}
          <div className="space-y-2">
            <h3 className="text-lg font-bold">Catégorie</h3>
            <select
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              className="input-field w-full"
            >
              <option value="">Toutes</option>
              {categories.map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>

          {/* Materials Multi-Select */}
          <div className="space-y-2">
            <h3 className="text-lg font-bold">Matériaux</h3>
            <div className="flex flex-wrap gap-2">
              {materials.map((mat) => {
                const isSelected = selectedMaterials.includes(mat);
                return (
                  <button
                    key={mat}
                    onClick={() => handleMaterialToggle(mat)}
                    className={`px-3 py-1 rounded-full ${
                      isSelected
                        ? "bg-brandGold text-richEbony"
                        : "bg-transparent border border-brandGold text-brandGold"
                    }`}
                  >
                    {mat}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Events Multi-Select */}
          <div className="space-y-2">
            <h3 className="text-lg font-bold">Événements</h3>
            <div className="flex flex-wrap gap-2">
              {events.map((evt) => {
                const isSelected = selectedEvents.includes(evt);
                return (
                  <button
                    key={evt}
                    onClick={() => handleEventToggle(evt)}
                    className={`px-3 py-1 rounded-full ${
                      isSelected
                        ? "bg-brandGold text-richEbony"
                        : "bg-transparent border border-brandGold text-brandGold"
                    }`}
                  >
                    {evt}
                  </button>
                );
              })}
            </div>
          </div>

          {/* Price Range */}
          <div className="space-y-2">
            <h3 className="text-lg font-bold">Prix</h3>
            <div className="flex items-center gap-2">
              <input
                type="number"
                className="input-field w-24"
                placeholder="Min"
                value={minPrice === "" ? "" : minPrice}
                onChange={(e) =>
                  setMinPrice(e.target.value ? Number(e.target.value) : "")
                }
              />
              <span>-</span>
              <input
                type="number"
                className="input-field w-24"
                placeholder="Max"
                value={maxPrice === "" ? "" : maxPrice}
                onChange={(e) =>
                  setMaxPrice(e.target.value ? Number(e.target.value) : "")
                }
              />
            </div>
          </div>
        </div>
      </section>

      {/* PRODUCTS GRID */}
      <motion.section
        className="max-w-screen-xl mx-auto px-4 py-8"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        {filteredProducts.length === 0 ? (
          <div className="text-center py-16 text-platinumGray">
            <h2 className="text-2xl font-serif text-brandGold mb-4">
              Aucun produit trouvé
            </h2>
            <p className="text-platinumGray">
              Essayez d’ajuster vos filtres ou revenez plus tard.
            </p>
          </div>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-6">
            {filteredProducts.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>
        )}
      </motion.section>
    </div>
  );
}

Key Observations

    Multiple Material & Event Selections
        The user can click multiple material buttons (e.g., “Or,” “Platine,” “Argent”). We do a multi-select approach using a local selectedMaterials array.
        The same approach for events (like “Mariage,” “Fiançailles,” etc.).

    Filtering Logic
        We filter on the client side (in the filteredProducts array). If you have thousands of products, you might prefer server-side filtering with query strings.
        For each product, we check if it has any (some) of the selected materials or events. If you want a product to have all selected materials, use selectedMaterials.every(...).

    Min & Max Price
        We allow the user to set both a minimum and maximum. If the field is empty, we skip that check.

    categoryId vs. “slug”**
        We store categories by slug in the DB. A product includes category: { slug: ... }.
        We match the user’s selection (selectedCategory) with product.category?.slug.

    Responsive Layout
        The filters are placed in a simple grid grid-cols-1 md:grid-cols-4 gap-6. You can rearrange or style them differently.

Server-Side vs. Client-Side Filtering

    Client-Side: You fetch all products, then filter them in the browser. Good for small-to-medium product sets.
    Server-Side: You’d parse filter queries (like ?category=bagues&material=gold&material=silver) in getServerSideProps, then do a Prisma where clause. This is more scalable for huge product catalogs.

Server-Side Example

If you want advanced server-side filtering, you might do:

// parse query from context
const { category, materials, events, minPrice, maxPrice } = context.query;

// Build the where object dynamically
const whereClause: any = {};

// category filter
if (typeof category === "string") {
  whereClause.category = { slug: category };
}
// materials multi
if (materials) {
  // if user selects multiple materials => ?materials=Or&materials=Argent
  const arr = Array.isArray(materials) ? materials : [materials];
  whereClause.materials = { hasSome: arr };
}
// events multi
if (events) {
  const arr = Array.isArray(events) ? events : [events];
  whereClause.events = { hasSome: arr };
}

// price range
if (minPrice) {
  whereClause.basePrice = { gte: Number(minPrice) };
}
if (maxPrice) {
  whereClause.basePrice = {
    ...whereClause.basePrice,
    lte: Number(maxPrice),
  };
}

// Then query
const products = await prisma.product.findMany({
  where: whereClause,
  include: {
    category: { select: { slug: true } },
  },
});

This approach requires your front-end to build the query string and navigate/refresh. But it’s more scalable for large catalogs.
Conclusion

    By storing materials and events in a manner that supports multiple values per product (whether arrays or many-to-many relations), you can build a rich filtering UI.
    The snippet above provides client-side multi-filter logic with minimal code changes.
    For performance on large data sets, consider server-side filtering with dynamic where clauses, passing user-selected filters in query strings.

With this approach, your customers can refine their search by category, multiple materials, multiple events, price range, or any other dimension you add in the future—helping them find the perfect piece in your Diamant Rouge collection.
You said:
Now let's rework this product card component , first it's french based language , then get the product card to have no background and no borders, make the shape of the picture spanning full width and the text starting from left and the favorite button on the right side of the title : "// components/ProductCard.tsx
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";

type ProductCardProps = {
    product: {
        id: number;
        sku: string;
        basePrice: string;
        images: string[];
        translations: {
            language: string;
            name: string;
        }[];
    };
    locale: string;
};

export default function ProductCard({ product, locale }: ProductCardProps) {
    const { wishlist, addToWishlist, removeFromWishlist } = useWishlist();
    const [hovered, setHovered] = useState(false);

    // Determine the product name based on the current locale
    const productTranslation =
        product.translations.find((t) => t.language === locale) ||
        product.translations.find((t) => t.language === "en");

    // Check if product is in the user's wishlist
    const isInWishlist = wishlist.some((item) => item.productId === product.id);

    // Toggle wishlist status
    async function handleWishlist() {
        if (isInWishlist) {
            await removeFromWishlist(product.id);
        } else {
            await addToWishlist(product.id);
        }
    }

    return (
        <div
            className="card hover-scale relative overflow-hidden"
            onMouseEnter={() => setHovered(true)}
            onMouseLeave={() => setHovered(false)}
        >
            {/* Wishlist Button */}
            <button
                onClick={handleWishlist}
                className={absolute top-3 right-3 p-2 rounded-full transition-all shadow-luxury z-10
          ${isInWishlist ? "bg-burgundy text-brandIvory" : "bg-brandIvory text-richEbony"}
        }
            >
                {isInWishlist ? "❤️" : "🤍"}
            </button>

            {/* Product Image & Quick View Overlay */}
            <Link href={/products/${product.id}} passHref>
                <div className="relative w-full h-[320px] cursor-pointer rounded-lg overflow-hidden">
                    <Image
                        src={
                            product.images.length > 0
                                ? product.images[0]
                                : "/images/placeholder.jpg"
                        }
                        layout="fill"
                        objectFit="cover"
                        alt={productTranslation?.name || "Luxury Jewelry"}
                        className="rounded-lg"
                    />
                    {hovered && (
                        <div className="absolute inset-0 bg-burgundy/40 flex items-center justify-center text-brandIvory text-lg font-medium">
                            Quick View
                        </div>
                    )}
                </div>
            </Link>

            {/* Product Info */}
            <div className="p-4 text-center">
                <h3 className="text-lg font-serif text-brandGold">
                    {productTranslation?.name}
                </h3>
                <p className="text-platinumGray mt-1">
                    Starting at €{parseFloat(product.basePrice).toFixed(2)}
                </p>
            </div>
        </div>
    );
}
"

Below is a cleaner, French-based ProductCard component that:

    Removes the card background and borders.
    Makes the image span the full width, with no surrounding card shape.
    Places the favorite (wishlist) button to the right of the product title.
    Uses French text for labels like “Aperçu Rapide” and “À partir de”.
    Displays text left-aligned.

Feel free to adjust the sizing, French wording, or styling to your exact preferences.

// components/ProductCard.tsx
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";

type ProductTranslation = {
  language: string;
  name: string;
};

type ProductCardProps = {
  product: {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
  };
  locale: string;
};

export default function ProductCard({ product, locale }: ProductCardProps) {
  const { wishlist, addToWishlist, removeFromWishlist } = useWishlist();
  const [hovered, setHovered] = useState(false);

  // Determine product name based on the current locale
  const productTranslation =
    product.translations.find((t) => t.language === locale) ||
    product.translations.find((t) => t.language === "fr") || // fallback to French
    product.translations.find((t) => t.language === "en");   // final fallback to English

  // Check if product is in the user's wishlist
  const isInWishlist = wishlist.some((item) => item.productId === product.id);

  // Toggle wishlist status
  async function handleWishlist() {
    if (isInWishlist) {
      await removeFromWishlist(product.id);
    } else {
      await addToWishlist(product.id);
    }
  }

  return (
    <div
      className="relative overflow-hidden hover-scale transition-transform duration-300"
      onMouseEnter={() => setHovered(true)}
      onMouseLeave={() => setHovered(false)}
    >
      {/* ---------- Product Image ---------- */}
      <Link href={`/products/${product.id}`} passHref>
        <div className="relative w-full h-[320px] cursor-pointer">
          <Image
            src={
              product.images.length > 0
                ? product.images[0]
                : "/images/placeholder.jpg"
            }
            alt={productTranslation?.name || "Bijou de luxe"}
            fill
            className="object-cover"
          />

          {/* Hover Overlay */}
          {hovered && (
            <div className="absolute inset-0 bg-burgundy/40 flex items-center justify-center text-brandIvory text-lg font-medium">
              Aperçu Rapide
            </div>
          )}
        </div>
      </Link>

      {/* ---------- Text & Favorite Button ---------- */}
      <div className="mt-2 px-2 text-left">
        <div className="flex items-center justify-between">
          {/* Product Title */}
          <h3 className="text-base font-serif text-richEbony">
            {productTranslation?.name}
          </h3>

          {/* Wishlist Button */}
          <button
            onClick={handleWishlist}
            className={`p-1 rounded-full transition-all duration-300
              ${
                isInWishlist
                  ? "bg-burgundy text-brandIvory"
                  : "bg-brandIvory text-burgundy border border-burgundy"
              }
            `}
            title="Ajouter aux favoris"
          >
            {isInWishlist ? "❤️" : "🤍"}
          </button>
        </div>

        {/* Price */}
        <p className="text-sm text-platinumGray mt-1">
          À partir de {parseFloat(product.basePrice).toFixed(2)} MAD
        </p>
      </div>
    </div>
  );
}

Changes & Rationale

    No Background/Border
        Removed the .card styling and replaced it with a simple div using relative overflow-hidden.
        The image now spans the full width with no card box around it.

    Title & Favorite Button on Same Line
        Used a flex container with justify-between to keep the title on the left and the button on the right.

    French Wording
        Hover overlay: “Aperçu Rapide”.
        Price: “À partir de ... MAD”.
        Title: Fallback to French translation if found, otherwise to English.

    No “Center” Alignment
        Text is left-aligned with text-left. The name is text-base font-serif text-richEbony.

    Subtle Hover Scale
        Entire component uses hover-scale for a slight scale-up on hover.
        The overlay is a simple burgundy tint on image hover.

    Wishlist Button
        Now placed in-line with the product name.
        Has a distinct style if the product is already in the wishlist (a filled burgundy heart vs. an empty white heart).

With this setup, your product card will look clean, focusing on the image, minimal text, and an unobtrusive wishlist button to the right of the title—perfect for a luxury jewelry brand.
You said:
add a see creating button bellow the card 

Below is the updated ProductCard component featuring a “Voir la création” button below the price. It links to the product details page (/products/${product.id}) while maintaining a clean, luxurious style in French:

// components/ProductCard.tsx
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";

type ProductTranslation = {
  language: string;
  name: string;
};

type ProductCardProps = {
  product: {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
  };
  locale: string;
};

export default function ProductCard({ product, locale }: ProductCardProps) {
  const { wishlist, addToWishlist, removeFromWishlist } = useWishlist();
  const [hovered, setHovered] = useState(false);

  // Determine product name based on current locale
  const productTranslation =
    product.translations.find((t) => t.language === locale) ||
    product.translations.find((t) => t.language === "fr") || // fallback to French
    product.translations.find((t) => t.language === "en");   // fallback to English

  // Check if product is in the user's wishlist
  const isInWishlist = wishlist.some((item) => item.productId === product.id);

  // Toggle wishlist status
  async function handleWishlist() {
    if (isInWishlist) {
      await removeFromWishlist(product.id);
    } else {
      await addToWishlist(product.id);
    }
  }

  return (
    <div
      className="relative overflow-hidden hover-scale transition-transform duration-300"
      onMouseEnter={() => setHovered(true)}
      onMouseLeave={() => setHovered(false)}
    >
      {/* ---------- Product Image ---------- */}
      <Link href={`/products/${product.id}`} passHref>
        <div className="relative w-full h-[320px] cursor-pointer">
          <Image
            src={
              product.images.length > 0
                ? product.images[0]
                : "/images/placeholder.jpg"
            }
            alt={productTranslation?.name || "Bijou de luxe"}
            fill
            className="object-cover"
          />

          {/* Hover Overlay */}
          {hovered && (
            <div className="absolute inset-0 bg-burgundy/40 flex items-center justify-center text-brandIvory text-lg font-medium">
              Aperçu Rapide
            </div>
          )}
        </div>
      </Link>

      {/* ---------- Text & Favorite Button ---------- */}
      <div className="mt-2 px-2 text-left">
        <div className="flex items-center justify-between">
          {/* Product Title */}
          <h3 className="text-base font-serif text-richEbony">
            {productTranslation?.name}
          </h3>

          {/* Wishlist Button */}
          <button
            onClick={handleWishlist}
            className={`p-1 rounded-full transition-all duration-300
              ${
                isInWishlist
                  ? "bg-burgundy text-brandIvory"
                  : "bg-brandIvory text-burgundy border border-burgundy"
              }
            `}
            title="Ajouter aux favoris"
          >
            {isInWishlist ? "❤️" : "🤍"}
          </button>
        </div>

        {/* Price */}
        <p className="text-sm text-platinumGray mt-1">
          À partir de {parseFloat(product.basePrice).toFixed(2)} MAD
        </p>

        {/* ---------- "Voir la création" Button ---------- */}
        <div className="mt-3">
          <Link href={`/products/${product.id}`} passHref>
            <button className="button-primary w-full py-2 text-sm">
              Voir la création
            </button>
          </Link>
        </div>
      </div>
    </div>
  );
}

Key Adjustments

    “Voir la création” Button
        Placed below the price (<p>).
        Uses .button-primary (or whichever custom class you have for primary CTAs).
        Stretches full width (w-full) for a bold call-to-action.

    French Wording
        “Voir la création” for the CTA.
        “Aperçu Rapide” overlay on hover.
        “À partir de X MAD” for the price.

    No Background or Border
        The card is simply a container (div) with a hover-scale effect, and the image spans the full width.

    Wishlist Icon
        Right-aligned in the title row.
        Filled heart (“❤️”) if in wishlist, empty (“🤍”) if not.

This refined layout highlights the product image and ensures a clear CTA so customers can easily explore each jewelry piece in more detail.
You said:
remove the overlay from the product picture when on hover , also make the button better minimalistically elegant and centred padded 

Below is a streamlined ProductCard component in French that:

    Removes the hover overlay from the product image (no burgundy tint).
    Retains a subtle hover scale on the entire card for a touch of luxury.
    Places a minimalist, centered CTA button (“Voir la création”) with elegant styling and padding.

Feel free to tweak the colors, padding, or typography to match your exact brand identity.

// components/ProductCard.tsx
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";

type ProductTranslation = {
  language: string;
  name: string;
};

type ProductCardProps = {
  product: {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
  };
  locale: string;
};

export default function ProductCard({ product, locale }: ProductCardProps) {
  const { wishlist, addToWishlist, removeFromWishlist } = useWishlist();
  const [hovered, setHovered] = useState(false);

  // Determine product name based on current locale
  const productTranslation =
    product.translations.find((t) => t.language === locale) ||
    product.translations.find((t) => t.language === "fr") || // fallback to French
    product.translations.find((t) => t.language === "en");   // fallback to English

  // Check if product is in the user's wishlist
  const isInWishlist = wishlist.some((item) => item.productId === product.id);

  // Toggle wishlist status
  async function handleWishlist() {
    if (isInWishlist) {
      await removeFromWishlist(product.id);
    } else {
      await addToWishlist(product.id);
    }
  }

  return (
    <div
      className="relative overflow-hidden hover-scale transition-transform duration-300"
      onMouseEnter={() => setHovered(true)}
      onMouseLeave={() => setHovered(false)}
    >
      {/* ---------- Product Image ---------- */}
      <Link href={`/products/${product.id}`} passHref>
        <div className="relative w-full h-[320px] cursor-pointer">
          <Image
            src={
              product.images.length > 0
                ? product.images[0]
                : "/images/placeholder.jpg"
            }
            alt={productTranslation?.name || "Bijou de luxe"}
            fill
            className="object-cover"
          />
        </div>
      </Link>

      {/* ---------- Text & Favorite Button ---------- */}
      <div className="mt-2 px-2 text-left">
        <div className="flex items-center justify-between">
          {/* Product Title */}
          <h3 className="text-base font-serif text-richEbony">
            {productTranslation?.name}
          </h3>

          {/* Wishlist Button */}
          <button
            onClick={handleWishlist}
            className={`p-1 rounded-full transition-all duration-300
              ${
                isInWishlist
                  ? "bg-burgundy text-brandIvory"
                  : "bg-brandIvory text-burgundy border border-burgundy"
              }
            `}
            title="Ajouter aux favoris"
          >
            {isInWishlist ? "❤️" : "🤍"}
          </button>
        </div>

        {/* Price */}
        <p className="text-sm text-platinumGray mt-1">
          À partir de {parseFloat(product.basePrice).toFixed(2)} MAD
        </p>

        {/* ---------- "Voir la création" Button ---------- */}
        <div className="mt-4 flex justify-center">
          <Link href={`/products/${product.id}`} passHref>
            <button
              className={`
                px-6 py-2 text-sm 
                border border-brandGold text-brandGold 
                hover:bg-brandGold hover:text-richEbony
                rounded-full transition duration-300
              `}
            >
              Voir la création
            </button>
          </Link>
        </div>
      </div>
    </div>
  );
}

Key Updates

    No Hover Overlay
        The burgundy tint overlay has been removed. No additional text on hover.
        A subtle scale effect still occurs on hover for a refined, luxurious impression.

    Minimalist, Centered CTA
        The “Voir la création” button is placed in a flex container (flex justify-center) with border styling.
        Rounded edges (rounded-full) and a subtle hover color change (hover:bg-brandGold).

    Left-Aligned Title & Wishlist
        The product name is on the left, while the wishlist heart is on the right (within the same row).

    Paddings & Distances
        Added mt-4 before the CTA button for a bit more vertical space from the price.
        The rest is kept simple and clean, letting the product image shine.

This minimalistic design ensures your jewelry images remain the focus, with a tasteful CTA for customers to explore each piece in more detail.
You said:
Now, let's move on rework the product detail page where i wont the the overall text starting from left , get the title then the price then separate by a line then description then material details then the personalisation depending on variation as the diamond shape the carat central , the quality of the diamond , la coupe, the color of the metal and the size of the finger , then a summary of the selecitons then a shipment receive delais a month after the current date then two buttons , the try on showroom button then next to it add to cart  with the price on it , and above the next to cart button Paiment securise message with visa and mastercard icons : "import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";

type ProductProps = {
    productData: {
        id: number;
        sku: string;
        basePrice: string;
        images: string[];
        translations: {
            language: string;
            name: string;
            description: string;
        }[];
        variations: {
            id: number;
            variationType: string;
            variationValue: string;
            additionalPrice: string;
        }[];
    } | null;
    locale: string;
};

export default function ProductPage({ productData, locale }: ProductProps) {
    const { addToCart } = useCart();
    const [selectedVariation, setSelectedVariation] = useState<number | null>(null);
    const [selectedImage, setSelectedImage] = useState(
        productData?.images[0] || "/images/placeholder.jpg"
    );
    const [isModalOpen, setIsModalOpen] = useState(false);

    if (!productData) {
        return (
            <section className="py-12 text-center section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Exclusive Masterpiece Not Found
                </h1>
                <p className="text-platinumGray">
                    The bespoke creation you seek is no longer available.
                </p>
            </section>
        );
    }

    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "en");

    const basePrice = parseFloat(productData.basePrice);
    const additionalPrice = selectedVariation
        ? parseFloat(
            productData.variations.find((v) => v.id === selectedVariation)?.additionalPrice || "0"
        )
        : 0;
    const totalPrice = basePrice + additionalPrice;

    return (
        <>
            <NextSeo
                title={Diamant-Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant-Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/* Main Section */}
            <motion.section
                className="py-16 px-6 max-w-7xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-16"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* 📸 Image Showcase */}
                <div className="relative">
                    <div
                        className="relative group cursor-pointer"
                        onClick={() => setIsModalOpen(true)}
                    >
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name}
                            className="rounded-lg shadow-luxury transition-transform duration-300 hover:scale-105"
                        />
                        {/* Light burgundy overlay on hover instead of Ebony */}
                        <div className="absolute inset-0 bg-burgundy/20 opacity-0 group-hover:opacity-100 transition duration-300 rounded-lg"></div>
                    </div>

                    {/* 🔍 Thumbnails */}
                    <div className="flex gap-3 mt-4">
                        {productData.images.map((image, index) => {
                            const isSelected = selectedImage === image;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(image)}
                                    className="rounded-lg overflow-hidden"
                                >
                                    <Image
                                        src={image}
                                        width={90}
                                        height={90}
                                        alt={Thumbnail ${index}}
                                        className={cursor-pointer transition ${
                                            isSelected
                                                ? "border-4 border-brandGold"
                                                : "opacity-80 hover:opacity-100"
                                        }}
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* 🏷 Product Details */}
                <div>
                    <h1 className="text-5xl font-serif text-brandGold mb-4">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-lg text-platinumGray mb-6">
                        {productTranslation?.description}
                    </p>

                    {/* 💳 Secure Payment Block */}
                    <div className="bg-burgundy/10 p-4 rounded-lg text-richEbony mb-6">
                        <h3 className="text-lg font-semibold text-brandGold mb-2">
                            Secure & Confidential Transactions
                        </h3>
                        <div className="flex items-center gap-4">
                            <Image
                                src="/images/icons/img.icons8.png"
                                width={40}
                                height={24}
                                alt="Visa"
                            />
                            <Image
                                src="/images/icons/mastercard-old.svg"
                                width={40}
                                height={24}
                                alt="Mastercard"
                            />
                            <p className="text-sm text-platinumGray">
                                Guaranteed authenticity & privacy
                            </p>
                        </div>
                    </div>

                    {/* 🎨 Variations */}
                    {productData.variations.length > 0 && (
                        <div className="mb-6">
                            <label className="block mb-2 text-richEbony font-semibold">
                                Select Customization
                            </label>
                            <div className="flex flex-wrap gap-4">
                                {productData.variations.map((variation) => {
                                    const isActive = selectedVariation === variation.id;
                                    return (
                                        <button
                                            key={variation.id}
                                            onClick={() => setSelectedVariation(variation.id)}
                                            className={px-4 py-2 rounded font-medium transition duration-300
                        ${
                                                isActive
                                                    ? "bg-burgundy text-brandIvory"
                                                    : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                                            }}
                                        >
                                            {variation.variationValue}
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {/* 💰 Price Display */}
                    <p className="text-3xl font-bold text-brandGold mb-6">
                        {selectedVariation
                            ? Customized Price: €${totalPrice.toFixed(2)}
                            : Starting at €${totalPrice.toFixed(2)}}
                    </p>

                    {/* 🛒 Add to Cart */}
                    <button
                        onClick={() =>
                            addToCart({
                                image: selectedImage,
                                productId: productData.id,
                                variationId: selectedVariation || undefined,
                                sku: productData.sku,
                                name: productTranslation?.name || "Unknown",
                                price: totalPrice,
                                quantity: 1,
                            })
                        }
                        className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full font-medium transition duration-300 w-full"
                    >
                        Add to Cart
                    </button>

                    {/* ✨ Book a Private Viewing (No Ebony in light mode) */}
                    <Link href="/appointments" passHref>
                        <button className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full font-medium transition duration-300 mt-4 w-full">
                            Try in Showroom
                        </button>
                    </Link>
                </div>
            </motion.section>
        </>
    );
}

// ✅ Fetch product securely & Convert Decimal Fields to String
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true, // ✅ Ensure variations are always included
        },
    });

    if (!product) return { notFound: true };

    return {
        props: {
            productData: {
                ...JSON.parse(JSON.stringify(product)),
                basePrice: product.basePrice.toString(), // ✅ Convert Decimal to String
                variations: product.variations.map((variation) => ({
                    ...variation,
                    additionalPrice: variation.additionalPrice.toString(), // ✅ Convert Decimal to String
                })),
            },
            locale: context.locale || "en",
        },
    };
};
'

Below is a French-localized product detail page that follows your specifications:

    Text starts from the left (no center alignment).
    Title → Price → Horizontal line → Description → Material details → Personalization (shape, carat, quality, cut, metal color, ring size) → Summary of selections → Shipping estimate (1 month from now) → Two buttons side-by-side: Try in Showroom + Add to Cart (with the updated total price).
    A “Paiement sécurisé” message (with Visa & Mastercard icons) above the Add to Cart button.

Feel free to adapt class names, styling, or layout to match your exact brand identity. Comments indicate where you can further customize.

// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";

type ProductTranslation = {
  language: string;
  name: string;
  description: string;
};

type ProductVariation = {
  id: number;
  variationType: string;      // e.g. "diamondShape", "carat"
  variationValue: string;     // e.g. "round", "1.5"
  additionalPrice: string;    // store as string, convert to number
};

type ProductData = {
  id: number;
  sku: string;
  basePrice: string;          // store as string, convert in code
  images: string[];
  translations: ProductTranslation[];
  variations: ProductVariation[];
};

type ProductPageProps = {
  productData: ProductData | null;
  locale: string;
};

export default function ProductPage({ productData, locale }: ProductPageProps) {
  const { addToCart } = useCart();

  // ----- Basic Checks -----
  if (!productData) {
    return (
      <section className="py-12 px-6 section-dark">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Création Introuvable
        </h1>
        <p className="text-platinumGray">
          La pièce que vous recherchez n’est plus disponible.
        </p>
      </section>
    );
  }

  // ----- Determine translation -----
  const productTranslation =
    productData.translations.find((t) => t.language === locale) ||
    productData.translations.find((t) => t.language === "fr") ||
    productData.translations.find((t) => t.language === "en");

  // ----- State for Variation Selections -----
  // For each type (shape, carat, quality, cut, metal color, ring size) you could store them separately
  // Here, we create a single object keyed by variationType => variationValue
  const [selectedVariations, setSelectedVariations] = useState<{
    [key: string]: ProductVariation;
  }>({});

  const updateVariation = (variation: ProductVariation) => {
    setSelectedVariations((prev) => ({
      ...prev,
      [variation.variationType]: variation,
    }));
  };

  // ----- Compute Total Price -----
  const basePriceNum = parseFloat(productData.basePrice || "0");
  const additionalPriceSum = useMemo(() => {
    let sum = 0;
    Object.values(selectedVariations).forEach((v) => {
      sum += parseFloat(v.additionalPrice || "0");
    });
    return sum;
  }, [selectedVariations]);

  const totalPrice = basePriceNum + additionalPriceSum;

  // ----- Selected Image -----
  const [selectedImage, setSelectedImage] = useState(
    productData.images[0] || "/images/placeholder.jpg"
  );

  // ----- Shipping: 1 Month from Now -----
  const currentDate = new Date();
  const shippingDate = new Date(
    currentDate.setMonth(currentDate.getMonth() + 1)
  ); // +1 month
  const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  // ----- Summary of Selections -----
  // e.g. diamondShape = "Ovale", carat = "1.5", metalColor = "Or Blanc" ...
  const selectionSummary = Object.values(selectedVariations)
    .map((v) => `${v.variationType}: ${v.variationValue}`)
    .join(" | ");

  // ----- Add to Cart -----
  const handleAddToCart = () => {
    addToCart({
      image: selectedImage,
      productId: productData.id,
      // We can store variation IDs as an array if needed
      variationId: undefined,
      sku: productData.sku,
      name: productTranslation?.name || "Bijou personnalisé",
      price: totalPrice,
      quantity: 1,
    });
  };

  return (
    <>
      <NextSeo
        title={`Diamant Rouge | ${productTranslation?.name}`}
        description={productTranslation?.description}
        openGraph={{
          title: `Diamant Rouge | ${productTranslation?.name}`,
          description: productTranslation?.description,
        }}
      />

      <motion.section
        className="py-16 px-6 max-w-screen-xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
      >
        {/* ------------------------------------------
            LEFT COLUMN: Image Showcase
        ------------------------------------------ */}
        <div>
          {/* Main Image */}
          <div className="relative w-full h-auto mb-4">
            <Image
              src={selectedImage}
              width={700}
              height={700}
              alt={productTranslation?.name || "Bijou Diamant Rouge"}
              className="rounded-lg shadow-luxury"
            />
          </div>

          {/* Thumbnails */}
          <div className="flex gap-3 overflow-x-auto">
            {productData.images.map((img, index) => {
              const isSelected = selectedImage === img;
              return (
                <button
                  key={index}
                  onClick={() => setSelectedImage(img)}
                  className={`border rounded-lg overflow-hidden ${
                    isSelected ? "border-brandGold" : "border-transparent"
                  }`}
                >
                  <Image
                    src={img}
                    width={80}
                    height={80}
                    alt={`Miniature ${index}`}
                    className="object-cover"
                  />
                </button>
              );
            })}
          </div>
        </div>

        {/* ------------------------------------------
            RIGHT COLUMN: Info & Customization
        ------------------------------------------ */}
        <div>
          {/* Title */}
          <h1 className="text-4xl font-serif text-richEbony mb-2">
            {productTranslation?.name}
          </h1>

          {/* Price */}
          <p className="text-2xl text-brandGold font-bold mb-2">
            {totalPrice.toFixed(2)} MAD
          </p>

          {/* Divider Line */}
          <hr className="border-platinumGray mb-4" />

          {/* Description */}
          <div className="text-platinumGray mb-6">
            {productTranslation?.description}
          </div>

          {/* Material Details (example) */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Détails du Matériau
            </h3>
            <p className="text-platinumGray text-sm">
              Chaque création Diamant Rouge est façonnée à partir de métaux
              nobles et de pierres précieuses soigneusement sélectionnées.
            </p>
          </div>

          {/* Personalization Options */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Personnalisation
            </h3>

            {/* Example Variation Types:
                - diamondShape
                - carat
                - quality
                - coupe
                - metalColor
                - ringSize
               We'll group them by variationType. 
            */}
            {["diamondShape", "carat", "quality", "coupe", "metalColor", "ringSize"].map(
              (type) => {
                // Filter from productData.variations by variationType
                const variationGroup = productData.variations.filter(
                  (v) => v.variationType === type
                );
                if (variationGroup.length === 0) return null;

                return (
                  <div key={type} className="mb-4">
                    <p className="font-medium text-sm text-richEbony mb-1">
                      {getVariationLabel(type)}
                    </p>
                    <div className="flex flex-wrap gap-3">
                      {variationGroup.map((variation) => {
                        const isSelected =
                          selectedVariations[type]?.id === variation.id;
                        return (
                          <button
                            key={variation.id}
                            onClick={() => updateVariation(variation)}
                            className={`px-3 py-1 rounded-full border transition
                              ${
                                isSelected
                                  ? "bg-burgundy text-brandIvory border-burgundy"
                                  : "bg-brandIvory text-richEbony border-burgundy"
                              }
                            `}
                          >
                            {variation.variationValue}
                          </button>
                        );
                      })}
                    </div>
                  </div>
                );
              }
            )}
          </div>

          {/* Summary of Selections */}
          {selectionSummary && (
            <div className="mb-6">
              <p className="text-sm text-platinumGray">
                <strong>Votre configuration:</strong> {selectionSummary}
              </p>
            </div>
          )}

          {/* Shipping Info (1 month from now) */}
          <div className="mb-6">
            <p className="text-sm text-platinumGray">
              Livraison estimée autour du {shippingDateStr}
            </p>
          </div>

          {/* Paiement Sécurisé */}
          <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
            <p className="text-sm text-richEbony font-semibold">
              Paiement Sécurisé
            </p>
            <Image
              src="/images/icons/img.icons8.png"
              width={40}
              height={24}
              alt="Visa"
            />
            <Image
              src="/images/icons/mastercard-old.svg"
              width={40}
              height={24}
              alt="Mastercard"
            />
          </div>

          {/* Buttons: "Try in Showroom" + "Add to Cart" */}
          <div className="flex flex-wrap gap-4">
            <Link href="/appointments" passHref>
              <button
                className="
                  button-secondary 
                  px-6 py-3 
                  font-medium 
                  rounded-full 
                  transition 
                  w-full sm:w-auto
                "
              >
                Essayer en Showroom
              </button>
            </Link>

            <button
              onClick={handleAddToCart}
              className="
                button-primary 
                px-6 py-3 
                font-medium 
                rounded-full 
                transition 
                w-full sm:w-auto
              "
            >
              Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
            </button>
          </div>
        </div>
      </motion.section>
    </>
  );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
  switch (type) {
    case "diamondShape":
      return "Forme du diamant";
    case "carat":
      return "Carat";
    case "quality":
      return "Qualité";
    case "coupe":
      return "Coupe";
    case "metalColor":
      return "Couleur du métal";
    case "ringSize":
      return "Taille de bague";
    default:
      return type;
  }
}

/* -------------------------------------------------------------------
   ✅ getServerSideProps 
   Fetch product, convert decimals to strings, pass to the page
------------------------------------------------------------------- */
export const getServerSideProps: GetServerSideProps = async (context) => {
  const id = parseInt(context.params?.id as string, 10);
  if (isNaN(id)) return { notFound: true };

  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      translations: true,
      variations: true,
    },
  });

  if (!product) {
    return { notFound: true };
  }

  // Convert Decimal fields to string
  const productData = {
    ...product,
    basePrice: product.basePrice.toString(),
    variations: product.variations.map((v) => ({
      ...v,
      additionalPrice: v.additionalPrice.toString(),
    })),
  };

  return {
    props: {
      productData: JSON.parse(JSON.stringify(productData)),
      locale: context.locale || "fr",
    },
  };
};

Explanation of Key Sections

    Layout & Left-Aligned Text
        The entire section is text-left. We use a two-column (md:grid-cols-2) approach: images on the left, details on the right.

    Title → Price → Divider → Description
        Title in a large French font style, then the price in gold, then a horizontal rule (<hr>) for separation, then the description.

    Material Details
        A simple text block describing the materials used. You can expand on this or show more data if stored in the DB.

    Variations
        We loop through the variation types you specified: diamond shape, carat, quality, cut, metal color, ring size.
        For each type, we display a set of buttons (the user can pick one per type).
        If your variations are stored differently, adapt accordingly.

    Summary of Selections
        Aggregates the user’s chosen variations into a single line (e.g. “Forme du diamant: Ovale | Carat: 1.5 | Couleur du métal: Or Blanc”).

    Shipping Estimate
        We show the date exactly 1 month from the current date in the user’s locale (French format, e.g. “15 avril 2024”).

    Paiement Sécurisé
        Displays a short label plus Visa and MasterCard icons.
        Placed above the cart button.

    Buttons: “Essayer en Showroom” + “Ajouter au Panier (Price)”
        Two side-by-side buttons. On mobile, they stack (w-full), on desktop they appear side by side (sm:w-auto).
        The “Add to Cart” button includes the updated total price in parentheses.

With this layout, you get a clearly structured product detail page that visually prioritizes the images and ensures customers can see price, description, personalization, and checkout options without confusion—all in French for a luxury aesthetic.
You said:
before adjusting , let's refram the overall website dimensions  i wont the whole website content ad section to span the overall screen width minus two inchs : "// component/Layout.tsx
import { ReactNode } from "react";
import Head from "next/head";
import Header from "./Header";
import Footer from "./Footer";

type LayoutProps = {
    children: ReactNode;
    title?: string;
    description?: string;
};

export default function Layout({ children, title, description }: LayoutProps) {
    return (
        <>
            {/* ✅ Enhanced SEO Metadata */}
            <Head>
                <title>
                    {title ? ${title} | Diamant-Rouge : "Diamant-Rouge - Luxury Jewelry House"}
                </title>
                {description && <meta name="description" content={description} />}
                <meta name="viewport" content="width=device-width, initial-scale=1" />
            </Head>

            {/* Luxury Fixed Header */}
            <Header />

            {/*
        Main Content Area
        Remove bg-richEbony and text-softIvory so light mode uses your default
        brandIvory + brandGold + burgundy, and Ebony is applied only in dark mode
        via .dark body { ... } from your global CSS.
      */}
            <main className="min-h-screen pt-24 md:pt-28 transition-opacity duration-500 ease-in-out">
                {children}
            </main>

            {/* Elegant Footer */}
            <Footer />
        </>
    );
}
"  "// pages/_app.tsx
import type { AppProps } from "next/app";
import "../styles/globals.css";
import { SessionProvider } from "next-auth/react"; // ✅ Import NextAuth Session Provider
import { CartProvider } from "../contexts/CartContext";
import { WishlistProvider } from "../contexts/WishlistContext";
import { useRouter } from "next/router";
import Layout from "../components/Layout";

export default function App({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    const { locale } = useRouter();

    return (
        <SessionProvider session={session}> {/* ✅ Ensures session context is available */}
            <div dir={locale === "ar" ? "rtl" : "ltr"}>
                <CartProvider> {/* ✅ Cart is now session-aware */}
                    <WishlistProvider>
                        <Layout title="Home" description="Welcome to Diamant-Rouge, the epitome of luxury jewelry.">
                            <Component {...pageProps} />
                        </Layout>
                    </WishlistProvider>
                </CartProvider>
            </div>
        </SessionProvider>
    );
}
"

Below is an example of how you can constrain the entire site (header, main content, footer) to use all available screen width minus two inches—effectively adding about one inch of horizontal margin on each side. Note that 2in is a real CSS unit (~192px), which can be quite wide for mobile devices. If you want a more adaptive approach, see the note on responsive fallback at the end.
1. Layout.tsx

Here we add a wrapper <div> around main (and optionally the header/footer) with a width: calc(100vw - 2in) style:

// components/Layout.tsx

import { ReactNode } from "react";
import Head from "next/head";
import Header from "./Header";
import Footer from "./Footer";

type LayoutProps = {
  children: ReactNode;
  title?: string;
  description?: string;
};

export default function Layout({ children, title, description }: LayoutProps) {
  return (
    <>
      {/* Enhanced SEO Metadata */}
      <Head>
        <title>
          {title ? `${title} | Diamant-Rouge` : "Diamant-Rouge - Luxury Jewelry House"}
        </title>
        {description && <meta name="description" content={description} />}
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>

      {/* Fixed Header */}
      <Header />

      {/* 
        Wrapper that constrains the site to (viewport width - 2 inches). 
        We center it using margin: 0 auto. 
      */}
      <div
        style={{ margin: "0 auto", width: "calc(100vw - 2in)" }}
      >
        <main className="min-h-screen pt-24 md:pt-28 transition-opacity duration-500 ease-in-out">
          {children}
        </main>
      </div>

      {/* Footer */}
      <Footer />
    </>
  );
}

How it works:

    style={{ width: "calc(100vw - 2in)" }} literally reduces the page width by 2 inches from the total viewport width.
    margin: "0 auto" keeps the content centered.
    On small screens (less than 2 inches wide), the content might overflow or compress in unusual ways. See Responsive Fallback below for a solution.

2. _app.tsx

Your existing _app.tsx remains mostly the same, as it already wraps the site in Layout. No need to change anything besides verifying that Layout references are correct:

// pages/_app.tsx
import type { AppProps } from "next/app";
import "../styles/globals.css";
import { SessionProvider } from "next-auth/react";
import { CartProvider } from "../contexts/CartContext";
import { WishlistProvider } from "../contexts/WishlistContext";
import { useRouter } from "next/router";
import Layout from "../components/Layout";

export default function App({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  const { locale } = useRouter();

  return (
    <SessionProvider session={session}>
      <div dir={locale === "ar" ? "rtl" : "ltr"}>
        <CartProvider>
          <WishlistProvider>
            <Layout
              title="Home"
              description="Bienvenue chez Diamant-Rouge, la quintessence de la joaillerie de luxe."
            >
              <Component {...pageProps} />
            </Layout>
          </WishlistProvider>
        </CartProvider>
      </div>
    </SessionProvider>
  );
}

Responsive Fallback (Optional)

Using fixed inch units can be problematic on smaller screens (e.g., smartphones). If you want to ensure it never shrinks too aggressively, you can combine it with clamp or fallback:

/* Example approach in your global CSS or inline style: */
width: clamp(95%, calc(100vw - 2in), 1200px);
/* or just clamp(95%, calc(100vw - 2in), 100%) */

This ensures that on very small screens, the width is at least 95% of the viewport (or 100%). On large screens, it won’t exceed 1200px (or your chosen max) minus 2 inches. For instance:

<div
  style={{
    margin: "0 auto",
    width: "clamp(95%, calc(100vw - 2in), 1400px)",
  }}
>
  <main>...</main>
</div>

That approach gracefully handles mobile and large desktop screens.
Summary

    Layout.tsx: Wraps your content in a div with width: calc(100vw - 2in) and margin: 0 auto.
    For the strict “2-inch margin,” the snippet above suffices. If you need responsive behavior, consider the clamp or a max-width.

You said:
ven the header and footer should span this width 

Below is an updated Layout.tsx that places your header, main content, and footer all inside a wrapper with a width of calc(100vw - 2in). This ensures the entire site—header and footer included—fits two inches less than the full viewport width. Note that using exact inches can be challenging on smaller devices, so see the Responsive Note at the end.

// components/Layout.tsx

import { ReactNode } from "react";
import Head from "next/head";
import Header from "./Header";
import Footer from "./Footer";

type LayoutProps = {
  children: ReactNode;
  title?: string;
  description?: string;
};

export default function Layout({ children, title, description }: LayoutProps) {
  return (
    <>
      {/* Enhanced SEO Metadata */}
      <Head>
        <title>
          {title ? `${title} | Diamant-Rouge` : "Diamant-Rouge - Luxury Jewelry House"}
        </title>
        {description && <meta name="description" content={description} />}
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>

      {/* 
        Wrapper that applies (100vw - 2in) to the entire site 
        so Header, Main, and Footer are all within that width.
      */}
      <div
        style={{
          margin: "0 auto",
          width: "calc(100vw - 2in)",
        }}
      >
        {/* Fixed or static Header (depending on your Header.tsx) */}
        <Header />

        <main className="min-h-screen pt-24 md:pt-28 transition-opacity duration-500 ease-in-out">
          {children}
        </main>

        <Footer />
      </div>
    </>
  );
}

About the “2 inches” Constraint

    width: calc(100vw - 2in) literally subtracts 2 physical inches from the viewport width.
    On desktops, that may look fine, but on a mobile device whose screen might be only a few inches wide, this can cause the layout to shrink or scroll horizontally.

Responsive Alternative

If you’d like a more adaptive approach that never becomes too narrow on small screens, you can replace:

<div
  style={{
    margin: "0 auto",
    width: "calc(100vw - 2in)",
  }}
>
  ...
</div>

…with something like clamp:

<div
  style={{
    margin: "0 auto",
    width: "clamp(95%, calc(100vw - 2in), 1400px)"
  }}
>
  ...
</div>

    clamp(min, preferred, max) ensures the width does not drop below min (e.g., 95% for mobile) and does not exceed max (like 1400px), while still subtracting 2 inches on very large screens.

Either way, with the code above, you’ll have the header, main content, and footer all contained in a 2-inch narrower layout than the full viewport width.
You said:
Now all pages content should take the space and width : "// pages/index.tsx

import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import { jwtVerify } from "jose";

import HeroCarousel from "../components/HeroCarousel";
import ProductCard from "../components/ProductCard";

/* ----------------------------------------------------------
   1. Server-Side Data Fetching
   ---------------------------------------------------------- */
export async function getServerSideProps(context: any) {
    let userId: number | null = null;
    let wishlist: number[] = [];

    try {
        // Parse session token
        const rawCookie = context.req.headers.cookie || "";
        let match =
            rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
            rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

        if (match) {
            const secret = process.env.NEXTAUTH_SECRET || "";
            const tokenStr = decodeURIComponent(match[1]);

            try {
                const { payload: decoded } = await jwtVerify(
                    tokenStr,
                    new TextEncoder().encode(secret)
                );
                if (decoded && typeof decoded === "object" && decoded.id) {
                    userId = Number(decoded.id);
                }
            } catch (tokenError) {
                console.warn("⚠ Token verification failed:", tokenError);
            }
        }

        // Fetch featured products
        const featuredProducts = await prisma.product.findMany({
            include: { translations: true, variations: true },
            take: 6,
        });

        // If user is logged in, fetch their wishlist
        if (userId) {
            const wishlistItems = await prisma.wishlist.findMany({
                where: { userId },
                select: { productId: true },
            });
            wishlist = wishlistItems.map((item) => item.productId);
        }

        return {
            props: {
                products: JSON.parse(JSON.stringify(featuredProducts)),
                wishlist,
                locale: context.locale || "fr",
            },
        };
    } catch (error) {
        console.error("❌ Homepage Data Fetch Error:", error);
        return {
            props: { products: [], wishlist: [], locale: context.locale || "fr" },
        };
    }
}

/* ----------------------------------------------------------
   2. Hero Carousel Slides
   ---------------------------------------------------------- */
const slides = [
    {
        imageSrc: "/images/parures-colliers-or-bijouterie-casablanca-maroc-825.jpg",
        heading: "Diamant Rouge",
        subheading: "Éclat Royal & Héritage Intemporel",
    },
    {
        imageSrc: "/images/bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg",
        heading: "L’Essence de la Joaillerie",
        subheading: "Des pièces taillées pour sublimer chaque moment",
    },
    {
        imageSrc: "/images/bijouterie-casablanca-maroc-dimant-rouge-464.jpg",
        heading: "Héritage Vivant",
        subheading: "La tradition à travers les siècles, pour vous",
    },
];

export default function HomePage({
                                     products,
                                     wishlist,
                                     locale,
                                 }: {
    products: any[];
    wishlist: number[];
    locale: string;
}) {
    return (
        <>
            <NextSeo
                title="Diamant Rouge | Joaillerie de Luxe"
                description="Découvrez la joaillerie Diamant Rouge : des pièces intemporelles, un héritage royal et un artisanat d’exception."
            />

            {/*
        ----------------------------------------------------
        ✨ 1. HERO CAROUSEL (centered text)
        ----------------------------------------------------
      */}
            <HeroCarousel slides={slides} />

            {/*
        ----------------------------------------------------
        🔶 2. CRÉATIONS ROYALES (split: text left, image right)
        ----------------------------------------------------
      */}
            <motion.section
                className="section-light py-16 px-4 md:px-12"
                initial={{ opacity: 0, y: 50 }}
                whileInView={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                <div className="flex flex-col md:flex-row items-center gap-10">
                    {/* Text (Left) */}
                    <div className="w-full md:w-1/2">
                        <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
                            Créations Royales
                        </h2>
                        <p className="text-platinumGray mb-6 leading-relaxed">
                            Des joyaux inspirés par la splendeur d’autrefois, façonnés pour
                            briller aujourd’hui. Chaque pièce raconte une histoire de passion
                            et de noblesse.
                        </p>
                        <Link href="/collections/tresors">
                            <button className="button-primary">Découvrir Nos Trésors</button>
                        </Link>
                    </div>
                    {/* Image (Right) */}
                    <div className="w-full md:w-1/2 relative overflow-hidden rounded-xl shadow-luxury">
                        <Image
                            src="/images/showroom.jpg"
                            alt="Showroom Diamant Rouge"
                            width={900}
                            height={600}
                            className="object-cover w-full h-full hover-scale"
                        />
                    </div>
                </div>
            </motion.section>

            {/*
        ----------------------------------------------------
        💎 3. PIÈCES INCONTOURNABLES (centered headings, grid)
        ----------------------------------------------------
      */}
            <motion.section
                className="section-light py-16 px-4 md:px-12 text-center"
                initial={{ opacity: 0, y: 50 }}
                whileInView={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-2">
                    Pièces Incontournables
                </h2>
                <p className="text-platinumGray max-w-2xl mx-auto mb-8">
                    Sélectionnées par les connaisseurs, ces créations incarnent le meilleur
                    de Diamant Rouge.
                </p>

                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 max-w-7xl mx-auto">
                    {products.map((product) => (
                        <ProductCard
                            key={product.id}
                            product={product}
                            locale={locale}
                            isWishlisted={wishlist.includes(product.id)}
                        />
                    ))}
                </div>
            </motion.section>

            {/*
        ----------------------------------------------------
        ⚜️ 4. HÉRITAGE & ARTISANAT (split: image left, text right)
        ----------------------------------------------------
      */}
            <motion.section
                className="section-dark py-16 px-4 md:px-12"
                initial={{ opacity: 0, y: 50 }}
                whileInView={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                <div className="flex flex-col md:flex-row items-center gap-10">
                    {/* Image (Left) */}
                    <div className="w-full md:w-1/2 overflow-hidden rounded-xl shadow-luxury relative">
                        <Image
                            src="/images/gemologist.jpg"
                            alt="Atelier Diamant Rouge"
                            width={900}
                            height={600}
                            className="object-cover w-full h-full hover-scale"
                        />
                    </div>
                    {/* Text (Right) */}
                    <div className="w-full md:w-1/2 text-right">
                        <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
                            Héritage & Artisanat
                        </h3>
                        <p className="text-brandIvory leading-relaxed mb-6">
                            Les secrets d’une tradition séculaire se révèlent dans chaque
                            détail. Nos artisans perpétuent un savoir-faire d’exception pour
                            offrir des bijoux uniques, reflet d’une passion inaltérable.
                        </p>
                        <Link href="/about">
                            <button className="button-secondary">En Savoir Plus</button>
                        </Link>
                    </div>
                </div>
            </motion.section>

            {/*
        ----------------------------------------------------
        🎉 5. ÉVÉNEMENT EXCLUSIF (full-width bg, text right)
        ----------------------------------------------------
      */}
            <motion.section
                className="relative py-16 px-4 md:px-12 overflow-hidden"
                initial={{ opacity: 0, x: 50 }}
                whileInView={{ opacity: 1, x: 0 }}
                transition={{ duration: 0.6 }}
                viewport={{ once: true }}
            >
                {/* Background Image */}
                <div className="absolute inset-0 z-0">
                    <Image
                        src="/images/emerald-ring.png"
                        alt="Événement Diamant Rouge"
                        fill
                        className="object-cover object-center"
                    />
                    {/* Burgundy Tint */}
                    <div className="absolute inset-0 bg-burgundy/40" />
                </div>

                {/* Text (Right-Aligned) */}
                <div className="relative z-10 flex flex-col items-end max-w-4xl ml-auto">
                    <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
                        Événement Exclusif
                    </h3>
                    <p className="text-platinumGray mb-6 max-w-md">
                        Participez à notre gala privé et découvrez la nouvelle collection
                        « Dynastie Éblouissante » avant tout le monde.
                    </p>
                    <Link href="/appointments">
                        <button className="button-primary">Réserver</button>
                    </Link>
                </div>
            </motion.section>

            {/*
        ----------------------------------------------------
        📨 6. NEWSLETTER (centered CTA, minimal text)
        ----------------------------------------------------
      */}
            <section className="section-light py-12 px-4 md:px-12 text-center">
                <h4 className="text-2xl md:text-3xl font-serif text-brandGold mb-4">
                    Rejoignez Le Cercle Diamant Rouge
                </h4>
                <p className="text-platinumGray max-w-xl mx-auto mb-6">
                    Recevez nos invitations privées et découvrez nos nouveautés en
                    avant-première.
                </p>
                <form className="max-w-md mx-auto flex">
                    <input
                        type="email"
                        placeholder="Votre adresse e-mail"
                        className="input-field flex-1 rounded-r-none"
                    />
                    <button
                        type="submit"
                        className="bg-burgundy hover:bg-brandGold text-brandIvory hover:text-richEbony px-4 py-2 rounded-r-lg transition duration-300"
                    >
                        S’inscrire
                    </button>
                </form>
            </section>
        </>
    );
}
"

Below is an updated index.tsx HomePage that fully spans the layout’s available width (which is already constrained to calc(100vw - 2in) by your Layout.tsx). We’ve removed the old mx-auto and max-w-* classes so that everything naturally fills the available width. We’ve kept some basic horizontal padding (px-6 or px-8) for visual comfort, but feel free to adjust as you like.

// pages/index.tsx

import Link from "next/link";
import Image from "next/image";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import { prisma } from "../lib/prisma";
import { jwtVerify } from "jose";

import HeroCarousel from "../components/HeroCarousel";
import ProductCard from "../components/ProductCard";

/* ----------------------------------------------------------
   1. Server-Side Data Fetching
   ---------------------------------------------------------- */
export async function getServerSideProps(context: any) {
  let userId: number | null = null;
  let wishlist: number[] = [];

  try {
    // Parse session token
    const rawCookie = context.req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);

    if (match) {
      const secret = process.env.NEXTAUTH_SECRET || "";
      const tokenStr = decodeURIComponent(match[1]);

      try {
        const { payload: decoded } = await jwtVerify(
          tokenStr,
          new TextEncoder().encode(secret)
        );
        if (decoded && typeof decoded === "object" && decoded.id) {
          userId = Number(decoded.id);
        }
      } catch (tokenError) {
        console.warn("⚠ Token verification failed:", tokenError);
      }
    }

    // Fetch featured products
    const featuredProducts = await prisma.product.findMany({
      include: { translations: true, variations: true },
      take: 6,
    });

    // If user is logged in, fetch their wishlist
    if (userId) {
      const wishlistItems = await prisma.wishlist.findMany({
        where: { userId },
        select: { productId: true },
      });
      wishlist = wishlistItems.map((item) => item.productId);
    }

    return {
      props: {
        products: JSON.parse(JSON.stringify(featuredProducts)),
        wishlist,
        locale: context.locale || "fr",
      },
    };
  } catch (error) {
    console.error("❌ Homepage Data Fetch Error:", error);
    return {
      props: { products: [], wishlist: [], locale: context.locale || "fr" },
    };
  }
}

/* ----------------------------------------------------------
   2. Hero Carousel Slides
   ---------------------------------------------------------- */
const slides = [
  {
    imageSrc: "/images/parures-colliers-or-bijouterie-casablanca-maroc-825.jpg",
    heading: "Diamant Rouge",
    subheading: "Éclat Royal & Héritage Intemporel",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-parures-pour-mariees-75.jpg",
    heading: "L’Essence de la Joaillerie",
    subheading: "Des pièces taillées pour sublimer chaque moment",
  },
  {
    imageSrc: "/images/bijouterie-casablanca-maroc-dimant-rouge-464.jpg",
    heading: "Héritage Vivant",
    subheading: "La tradition à travers les siècles, pour vous",
  },
];

export default function HomePage({
  products,
  wishlist,
  locale,
}: {
  products: any[];
  wishlist: number[];
  locale: string;
}) {
  return (
    <>
      <NextSeo
        title="Diamant Rouge | Joaillerie de Luxe"
        description="Découvrez la joaillerie Diamant Rouge : des pièces intemporelles, un héritage royal et un artisanat d’exception."
      />

      {/*
        ----------------------------------------------------
        ✨ 1. HERO CAROUSEL
        ----------------------------------------------------
      */}
      <HeroCarousel slides={slides} />

      {/*
        ----------------------------------------------------
        🔶 2. CRÉATIONS ROYALES (split: text left, image right)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-6 md:px-8"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row items-center gap-10">
          {/* Text (Left) */}
          <div className="w-full md:w-1/2">
            <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
              Créations Royales
            </h2>
            <p className="text-platinumGray mb-6 leading-relaxed">
              Des joyaux inspirés par la splendeur d’autrefois, façonnés pour briller
              aujourd’hui. Chaque pièce raconte une histoire de passion et de noblesse.
            </p>
            <Link href="/collections/tresors">
              <button className="button-primary">Découvrir Nos Trésors</button>
            </Link>
          </div>
          {/* Image (Right) */}
          <div className="w-full md:w-1/2 relative overflow-hidden rounded-xl shadow-luxury">
            <Image
              src="/images/showroom.jpg"
              alt="Showroom Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full hover-scale"
            />
          </div>
        </div>
      </motion.section>

      {/*
        ----------------------------------------------------
        💎 3. PIÈCES INCONTOURNABLES (heading center, content fill)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-light py-16 px-6 md:px-8 text-center"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <h2 className="text-3xl md:text-4xl font-serif text-brandGold mb-2">
          Pièces Incontournables
        </h2>
        <p className="text-platinumGray max-w-2xl mx-auto mb-8">
          Sélectionnées par les connaisseurs, ces créations incarnent le meilleur
          de Diamant Rouge.
        </p>

        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 w-full">
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
              locale={locale}
              isWishlisted={wishlist.includes(product.id)}
            />
          ))}
        </div>
      </motion.section>

      {/*
        ----------------------------------------------------
        ⚜️ 4. HÉRITAGE & ARTISANAT (split: image left, text right)
        ----------------------------------------------------
      */}
      <motion.section
        className="section-dark py-16 px-6 md:px-8"
        initial={{ opacity: 0, y: 50 }}
        whileInView={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        <div className="flex flex-col md:flex-row items-center gap-10">
          {/* Image (Left) */}
          <div className="w-full md:w-1/2 overflow-hidden rounded-xl shadow-luxury relative">
            <Image
              src="/images/gemologist.jpg"
              alt="Atelier Diamant Rouge"
              width={900}
              height={600}
              className="object-cover w-full h-full hover-scale"
            />
          </div>
          {/* Text (Right) */}
          <div className="w-full md:w-1/2 text-right">
            <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
              Héritage & Artisanat
            </h3>
            <p className="text-brandIvory leading-relaxed mb-6">
              Les secrets d’une tradition séculaire se révèlent dans chaque détail.
              Nos artisans perpétuent un savoir-faire d’exception pour offrir des
              bijoux uniques, reflet d’une passion inaltérable.
            </p>
            <Link href="/about">
              <button className="button-secondary">En Savoir Plus</button>
            </Link>
          </div>
        </div>
      </motion.section>

      {/*
        ----------------------------------------------------
        🎉 5. Événement Exclusif (full-width bg, text right)
        ----------------------------------------------------
      */}
      <motion.section
        className="relative py-16 px-6 md:px-8 overflow-hidden"
        initial={{ opacity: 0, x: 50 }}
        whileInView={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.6 }}
        viewport={{ once: true }}
      >
        {/* Background Image */}
        <div className="absolute inset-0 z-0">
          <Image
            src="/images/emerald-ring.png"
            alt="Événement Diamant Rouge"
            fill
            className="object-cover object-center"
          />
          {/* Burgundy Tint */}
          <div className="absolute inset-0 bg-burgundy/40" />
        </div>

        {/* Text (Right-Aligned) */}
        <div className="relative z-10 flex flex-col items-end w-full ml-auto">
          <h3 className="text-3xl md:text-4xl font-serif text-brandGold mb-4">
            Événement Exclusif
          </h3>
          <p className="text-platinumGray mb-6 max-w-md text-right">
            Participez à notre gala privé et découvrez la nouvelle collection
            « Dynastie Éblouissante » avant tout le monde.
          </p>
          <Link href="/appointments">
            <button className="button-primary">Réserver</button>
          </Link>
        </div>
      </motion.section>

      {/*
        ----------------------------------------------------
        📨 6. NEWSLETTER (centered CTA, minimal text)
        ----------------------------------------------------
      */}
      <section className="section-light py-12 px-6 md:px-8 text-center">
        <h4 className="text-2xl md:text-3xl font-serif text-brandGold mb-4">
          Rejoignez Le Cercle Diamant Rouge
        </h4>
        <p className="text-platinumGray max-w-xl mx-auto mb-6">
          Recevez nos invitations privées et découvrez nos nouveautés en
          avant-première.
        </p>
        <form className="max-w-md mx-auto flex">
          <input
            type="email"
            placeholder="Votre adresse e-mail"
            className="input-field flex-1 rounded-r-none"
          />
          <button
            type="submit"
            className="bg-burgundy hover:bg-brandGold text-brandIvory hover:text-richEbony px-4 py-2 rounded-r-lg transition duration-300"
          >
            S’inscrire
          </button>
        </form>
      </section>
    </>
  );
}

Notable Changes

    Removed mx-auto and max-w-*
        Each section is now w-full by default, relying on the Layout (calc(100vw - 2in)) wrapper to constrain the overall width.
        For horizontal spacing, we use px-6 or px-8 to ensure the text doesn’t stick directly to the edges.

    Hero Carousel & Full-Width Sections
        Each section, including the Hero and the Événement Exclusif background image, naturally spans the available width from the layout wrapper.

    Centered vs. Left-Aligned
        We kept some headings centered (e.g., “Pièces Incontournables”) but removed any “mx-auto” constraints so the content fills the space.
        Where we have a split layout (flex-based), it’ll expand to fill the wrapper’s width, with only minimal px-* padding for breathing room.

With these changes, your homepage now fully uses the layout’s (100vw - 2in) space, maintaining some internal padding for a pleasing design. If you’d prefer even less padding, just reduce or remove the px-6/px-8 classes.
You said:
this page either should take the full width , and instead of increasin the size of elements like priduct card, get it to be more of it on the same row than increasing the size : "// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import { useState } from "react";
import { motion } from "framer-motion";
import ProductCard from "../../components/ProductCard";

// Replace with your actual Product type if you have a custom TS interface
import type { Product } from "@prisma/client";

type CollectionPageProps = {
    products: Array<Product & { category?: { slug: string } | null }>;
    categories: string[];
};

export const getServerSideProps: GetServerSideProps = async (context) => {
    try {
        // 1) Fetch categories from the Category table
        const categoryRecords = await prisma.category.findMany({
            select: { slug: true },
        });

        // 2) Fetch all products, including the Category slug
        const products = await prisma.product.findMany({
            include: {
                translations: true,
                variations: true,
                category: {
                    select: { slug: true },
                },
            },
        });

        // 3) Convert to JSON for Next.js
        return {
            props: {
                products: JSON.parse(JSON.stringify(products)),
                categories: categoryRecords.map((cat) => cat.slug),
            },
        };
    } catch (error) {
        console.error("❌ Error fetching collections:", error);
        return {
            props: { products: [], categories: [] },
        };
    }
};

export default function CollectionsPage({
                                            products,
                                            categories,
                                        }: CollectionPageProps) {
    // ----- FILTER STATE -----
    const [selectedCategory, setSelectedCategory] = useState<string>("");
    const [maxPrice, setMaxPrice] = useState<number | "">("");

    // ----- FILTERED PRODUCTS -----
    // Remember your product's price is stored in product.basePrice, not product.price.
    const filteredProducts = products.filter((product) => {
        // 1) Category filter (check product.category?.slug)
        if (selectedCategory && product.category?.slug !== selectedCategory) {
            return false;
        }
        // 2) Price filter (assuming basePrice is numeric)
        if (maxPrice !== "") {
            // Convert basePrice to number if it's returned as a string
            const basePriceNum = Number(product.basePrice);
            if (basePriceNum > Number(maxPrice)) {
                return false;
            }
        }
        return true;
    });

    return (
        <div className="min-h-screen bg-brandIvory text-richEbony">
            {/* PAGE HEADER */}
            <header className="py-16 text-center">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Nos Collections
                </h1>
                <p className="text-platinumGray">
                    Découvrez nos pièces intemporelles, façonnées dans l’excellence.
                </p>
            </header>

            {/* FILTERS SECTION */}
            <section className="max-w-screen-xl mx-auto px-4 py-8">
                <div className="flex flex-col md:flex-row items-center md:items-end md:justify-between gap-6">
                    {/* Category Filter */}
                    <div className="flex flex-col">
                        <label
                            htmlFor="category"
                            className="text-sm mb-1 text-platinumGray"
                        >
                            Catégorie
                        </label>
                        <select
                            id="category"
                            value={selectedCategory}
                            onChange={(e) => setSelectedCategory(e.target.value)}
                            className="input-field w-48"
                        >
                            <option value="">Toutes</option>
                            {categories.map((catSlug) => (
                                <option key={catSlug} value={catSlug}>
                                    {catSlug}
                                </option>
                            ))}
                        </select>
                    </div>

                    {/* Price Filter (max price) */}
                    <div className="flex flex-col">
                        <label htmlFor="price" className="text-sm mb-1 text-platinumGray">
                            Prix Max (MAD)
                        </label>
                        <input
                            type="number"
                            id="price"
                            placeholder="ex: 50000"
                            value={maxPrice}
                            onChange={(e) =>
                                setMaxPrice(e.target.value ? Number(e.target.value) : "")
                            }
                            className="input-field w-48"
                        />
                    </div>
                </div>
            </section>

            {/* PRODUCTS GRID */}
            <motion.section
                className="max-w-screen-xl mx-auto px-4 py-8"
                initial={{ opacity: 0, y: 30 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5 }}
            >
                {filteredProducts.length === 0 ? (
                    <div className="text-center py-16 text-platinumGray">
                        <h2 className="text-2xl font-serif text-brandGold mb-4">
                            Aucun produit trouvé
                        </h2>
                        <p className="text-platinumGray">
                            Essayez d’ajuster vos filtres ou revenez plus tard.
                        </p>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-6">
                        {filteredProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                )}
            </motion.section>
        </div>
    );
}
"

Below is an updated collections/index.tsx that spans the full width (minus the 2 inches from your Layout wrapper). Instead of making product cards bigger, we simply increase the number of columns for wider screens. We’ve removed max-w-screen-xl and mx-auto, ensuring the page content extends fully, just leaving a small horizontal padding. This allows more product cards per row rather than scaling up each card.

Feel free to further tweak the column breakpoints (e.g., 5 or 6 columns at XXL sizes) if you like.

// pages/collections/index.tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import { useState } from "react";
import { motion } from "framer-motion";
import ProductCard from "../../components/ProductCard";
import type { Product } from "@prisma/client";

type CollectionPageProps = {
  products: Array<Product & { category?: { slug: string } | null }>;
  categories: string[];
};

export const getServerSideProps: GetServerSideProps = async (context) => {
  try {
    // 1) Fetch categories from the Category table
    const categoryRecords = await prisma.category.findMany({
      select: { slug: true },
    });

    // 2) Fetch all products, including the Category slug
    const products = await prisma.product.findMany({
      include: {
        translations: true,
        variations: true,
        category: {
          select: { slug: true },
        },
      },
    });

    // 3) Convert to JSON for Next.js
    return {
      props: {
        products: JSON.parse(JSON.stringify(products)),
        categories: categoryRecords.map((cat) => cat.slug),
      },
    };
  } catch (error) {
    console.error("❌ Error fetching collections:", error);
    return {
      props: { products: [], categories: [] },
    };
  }
};

export default function CollectionsPage({
  products,
  categories,
}: CollectionPageProps) {
  // ---------- FILTER STATES ----------
  const [selectedCategory, setSelectedCategory] = useState<string>("");
  const [maxPrice, setMaxPrice] = useState<number | "">("");

  // ---------- FILTERED PRODUCTS ----------
  const filteredProducts = products.filter((product) => {
    // Category filter
    if (selectedCategory && product.category?.slug !== selectedCategory) {
      return false;
    }
    // Price filter
    if (maxPrice !== "") {
      const basePriceNum = Number(product.basePrice);
      if (basePriceNum > Number(maxPrice)) {
        return false;
      }
    }
    return true;
  });

  return (
    <div className="min-h-screen bg-brandIvory text-richEbony">
      {/* PAGE HEADER */}
      <header className="py-16 px-6 text-center">
        <h1 className="text-5xl font-serif text-brandGold mb-4">Nos Collections</h1>
        <p className="text-platinumGray">
          Découvrez nos pièces intemporelles, façonnées dans l’excellence.
        </p>
      </header>

      {/* FILTERS SECTION */}
      <section className="px-6 py-8">
        <div className="flex flex-col md:flex-row items-center md:items-end md:justify-between gap-6">
          {/* Category Filter */}
          <div className="flex flex-col">
            <label htmlFor="category" className="text-sm mb-1 text-platinumGray">
              Catégorie
            </label>
            <select
              id="category"
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              className="input-field w-48"
            >
              <option value="">Toutes</option>
              {categories.map((catSlug) => (
                <option key={catSlug} value={catSlug}>
                  {catSlug}
                </option>
              ))}
            </select>
          </div>

          {/* Price Filter (max price) */}
          <div className="flex flex-col">
            <label htmlFor="price" className="text-sm mb-1 text-platinumGray">
              Prix Max (MAD)
            </label>
            <input
              type="number"
              id="price"
              placeholder="ex: 50000"
              value={maxPrice}
              onChange={(e) =>
                setMaxPrice(e.target.value ? Number(e.target.value) : "")
              }
              className="input-field w-48"
            />
          </div>
        </div>
      </section>

      {/* PRODUCTS GRID */}
      <motion.section
        className="px-6 py-8"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        {filteredProducts.length === 0 ? (
          <div className="text-center py-16 text-platinumGray">
            <h2 className="text-2xl font-serif text-brandGold mb-4">
              Aucun produit trouvé
            </h2>
            <p className="text-platinumGray">
              Essayez d’ajuster vos filtres ou revenez plus tard.
            </p>
          </div>
        ) : (
          // Increase columns at larger breakpoints to fit more cards on the same row
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-6 w-full">
            {filteredProducts.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>
        )}
      </motion.section>
    </div>
  );
}

Key Adjustments

    Removed max-w-screen-xl & mx-auto
        All sections (<header>, <section>) now use px-6 for mild horizontal padding, but otherwise span the full available width (minus the 2 inches from Layout.tsx).

    More Columns
        The final product grid uses:

    grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6

    This ensures at very large breakpoints, you’ll see up to 6 columns per row, rather than simply 3 or 4. The product cards stay at a manageable size, but you can fit more in a single row.

Minimum 2 Columns

    Even on the smallest screens, we force 2 columns (grid-cols-2) so we never get huge single-card rows.
    If you prefer a single column on very small screens, you can keep grid-cols-1 at the base. For example:

        grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 ...

    Minimal Horizontal Padding
        We keep px-6 so that text and cards don’t stick directly to the edges of the screen. Increase, decrease, or remove as needed.

With this layout, the Collections page will fill all available width, display more product cards in a row at large breakpoints, and remain consistent with your site’s 2-inch margin from the Layout wrapper.
You said:
Now this product detiail page : "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;      // e.g. "diamondShape", "carat"
    variationValue: string;     // e.g. "round", "1.5"
    additionalPrice: string;    // store as string, convert to number
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;          // store as string, convert in code
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
};

type ProductPageProps = {
    productData: ProductData | null;
    locale: string;
};

export default function ProductPage({ productData, locale }: ProductPageProps) {
    const { addToCart } = useCart();

    // ----- Basic Checks -----
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ----- Determine translation -----
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ----- State for Variation Selections -----
    // For each type (shape, carat, quality, cut, metal color, ring size) you could store them separately
    // Here, we create a single object keyed by variationType => variationValue
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    const updateVariation = (variation: ProductVariation) => {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    };

    // ----- Compute Total Price -----
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ----- Selected Image -----
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ----- Shipping: 1 Month from Now -----
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    ); // +1 month
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ----- Summary of Selections -----
    // e.g. diamondShape = "Ovale", carat = "1.5", metalColor = "Or Blanc" ...
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ----- Add to Cart -----
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            // We can store variation IDs as an array if needed
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            <motion.section
                className="py-16 px-6 max-w-screen-xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* ------------------------------------------
            LEFT COLUMN: Image Showcase
        ------------------------------------------ */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* ------------------------------------------
            RIGHT COLUMN: Info & Customization
        ------------------------------------------ */}
                <div>
                    {/* Title */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>

                    {/* Price */}
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>

                    {/* Divider Line */}
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details (example) */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>

                        {/* Example Variation Types:
                - diamondShape
                - carat
                - quality
                - coupe
                - metalColor
                - ringSize
               We'll group them by variationType.
            */}
                        {["diamondShape", "carat", "quality", "coupe", "metalColor", "ringSize"].map(
                            (type) => {
                                // Filter from productData.variations by variationType
                                const variationGroup = productData.variations.filter(
                                    (v) => v.variationType === type
                                );
                                if (variationGroup.length === 0) return null;

                                return (
                                    <div key={type} className="mb-4">
                                        <p className="font-medium text-sm text-richEbony mb-1">
                                            {getVariationLabel(type)}
                                        </p>
                                        <div className="flex flex-wrap gap-3">
                                            {variationGroup.map((variation) => {
                                                const isSelected =
                                                    selectedVariations[type]?.id === variation.id;
                                                return (
                                                    <button
                                                        key={variation.id}
                                                        onClick={() => updateVariation(variation)}
                                                        className={px-3 py-1 rounded-full border transition
                              ${
                                                            isSelected
                                                                ? "bg-burgundy text-brandIvory border-burgundy"
                                                                : "bg-brandIvory text-richEbony border-burgundy"
                                                        }
                            }
                                                    >
                                                        {variation.variationValue}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            }
                        )}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info (1 month from now) */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" + "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>

                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* -------------------------------------------------------------------
   ✅ getServerSideProps
   Fetch product, convert decimals to strings, pass to the page
------------------------------------------------------------------- */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            locale: context.locale || "fr",
        },
    };
};
'

Below is an updated product detail page that spans the full available width (minus the 2 inches in your layout wrapper) instead of restricting to max-w-screen-xl. We’ve also removed any mx-auto so that it fills the container fully. We keep a little horizontal padding (px-6) for neat spacing. Feel free to adjust the padding to match your design preferences.

// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";

type ProductTranslation = {
  language: string;
  name: string;
  description: string;
};

type ProductVariation = {
  id: number;
  variationType: string;      // e.g. "diamondShape", "carat"
  variationValue: string;     // e.g. "round", "1.5"
  additionalPrice: string;    // store as string, convert to number
};

type ProductData = {
  id: number;
  sku: string;
  basePrice: string;          // store as string, convert in code
  images: string[];
  translations: ProductTranslation[];
  variations: ProductVariation[];
};

type ProductPageProps = {
  productData: ProductData | null;
  locale: string;
};

export default function ProductPage({ productData, locale }: ProductPageProps) {
  const { addToCart } = useCart();

  // ----- Basic Checks -----
  if (!productData) {
    return (
      <section className="py-12 px-6 section-dark">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Création Introuvable
        </h1>
        <p className="text-platinumGray">
          La pièce que vous recherchez n’est plus disponible.
        </p>
      </section>
    );
  }

  // ----- Determine translation -----
  const productTranslation =
    productData.translations.find((t) => t.language === locale) ||
    productData.translations.find((t) => t.language === "fr") ||
    productData.translations.find((t) => t.language === "en");

  // ----- State for Variation Selections -----
  const [selectedVariations, setSelectedVariations] = useState<{
    [key: string]: ProductVariation;
  }>({});

  const updateVariation = (variation: ProductVariation) => {
    setSelectedVariations((prev) => ({
      ...prev,
      [variation.variationType]: variation,
    }));
  };

  // ----- Compute Total Price -----
  const basePriceNum = parseFloat(productData.basePrice || "0");
  const additionalPriceSum = useMemo(() => {
    let sum = 0;
    Object.values(selectedVariations).forEach((v) => {
      sum += parseFloat(v.additionalPrice || "0");
    });
    return sum;
  }, [selectedVariations]);
  const totalPrice = basePriceNum + additionalPriceSum;

  // ----- Selected Image -----
  const [selectedImage, setSelectedImage] = useState(
    productData.images[0] || "/images/placeholder.jpg"
  );

  // ----- Shipping: 1 Month from Now -----
  const currentDate = new Date();
  const shippingDate = new Date(
    currentDate.setMonth(currentDate.getMonth() + 1)
  ); // +1 month
  const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  // ----- Summary of Selections -----
  const selectionSummary = Object.values(selectedVariations)
    .map((v) => `${v.variationType}: ${v.variationValue}`)
    .join(" | ");

  // ----- Add to Cart -----
  const handleAddToCart = () => {
    addToCart({
      image: selectedImage,
      productId: productData.id,
      variationId: undefined, // or store array of IDs if needed
      sku: productData.sku,
      name: productTranslation?.name || "Bijou personnalisé",
      price: totalPrice,
      quantity: 1,
    });
  };

  return (
    <>
      <NextSeo
        title={`Diamant Rouge | ${productTranslation?.name}`}
        description={productTranslation?.description}
        openGraph={{
          title: `Diamant Rouge | ${productTranslation?.name}`,
          description: productTranslation?.description,
        }}
      />

      {/* Two-column layout (image left, details right), full width minus 2in (from Layout). */}
      <motion.section
        className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
      >
        {/* ------------------------------------------
            LEFT COLUMN: Image Showcase
        ------------------------------------------ */}
        <div>
          {/* Main Image */}
          <div className="relative w-full h-auto mb-4">
            <Image
              src={selectedImage}
              width={700}
              height={700}
              alt={productTranslation?.name || "Bijou Diamant Rouge"}
              className="rounded-lg shadow-luxury"
            />
          </div>

          {/* Thumbnails */}
          <div className="flex gap-3 overflow-x-auto">
            {productData.images.map((img, index) => {
              const isSelected = selectedImage === img;
              return (
                <button
                  key={index}
                  onClick={() => setSelectedImage(img)}
                  className={`border rounded-lg overflow-hidden ${
                    isSelected ? "border-brandGold" : "border-transparent"
                  }`}
                >
                  <Image
                    src={img}
                    width={80}
                    height={80}
                    alt={`Miniature ${index}`}
                    className="object-cover"
                  />
                </button>
              );
            })}
          </div>
        </div>

        {/* ------------------------------------------
            RIGHT COLUMN: Info & Customization
        ------------------------------------------ */}
        <div>
          {/* Title */}
          <h1 className="text-4xl font-serif text-richEbony mb-2">
            {productTranslation?.name}
          </h1>

          {/* Price */}
          <p className="text-2xl text-brandGold font-bold mb-2">
            {totalPrice.toFixed(2)} MAD
          </p>

          {/* Divider Line */}
          <hr className="border-platinumGray mb-4" />

          {/* Description */}
          <div className="text-platinumGray mb-6">
            {productTranslation?.description}
          </div>

          {/* Material Details (example) */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Détails du Matériau
            </h3>
            <p className="text-platinumGray text-sm">
              Chaque création Diamant Rouge est façonnée à partir de métaux nobles
              et de pierres précieuses soigneusement sélectionnées.
            </p>
          </div>

          {/* Personalization Options */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Personnalisation
            </h3>

            {/* Variation Types: diamondShape, carat, quality, coupe, metalColor, ringSize */}
            {[
              "diamondShape",
              "carat",
              "quality",
              "coupe",
              "metalColor",
              "ringSize",
            ].map((type) => {
              const variationGroup = productData.variations.filter(
                (v) => v.variationType === type
              );
              if (variationGroup.length === 0) return null;

              return (
                <div key={type} className="mb-4">
                  <p className="font-medium text-sm text-richEbony mb-1">
                    {getVariationLabel(type)}
                  </p>
                  <div className="flex flex-wrap gap-3">
                    {variationGroup.map((variation) => {
                      const isSelected =
                        selectedVariations[type]?.id === variation.id;
                      return (
                        <button
                          key={variation.id}
                          onClick={() => updateVariation(variation)}
                          className={`px-3 py-1 rounded-full border transition
                            ${
                              isSelected
                                ? "bg-burgundy text-brandIvory border-burgundy"
                                : "bg-brandIvory text-richEbony border-burgundy"
                            }
                          `}
                        >
                          {variation.variationValue}
                        </button>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>

          {/* Summary of Selections */}
          {selectionSummary && (
            <div className="mb-6">
              <p className="text-sm text-platinumGray">
                <strong>Votre configuration:</strong> {selectionSummary}
              </p>
            </div>
          )}

          {/* Shipping Info (1 month from now) */}
          <div className="mb-6">
            <p className="text-sm text-platinumGray">
              Livraison estimée autour du {shippingDateStr}
            </p>
          </div>

          {/* Paiement Sécurisé */}
          <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
            <p className="text-sm text-richEbony font-semibold">
              Paiement Sécurisé
            </p>
            <Image
              src="/images/icons/img.icons8.png"
              width={40}
              height={24}
              alt="Visa"
            />
            <Image
              src="/images/icons/mastercard-old.svg"
              width={40}
              height={24}
              alt="Mastercard"
            />
          </div>

          {/* Buttons: "Try in Showroom" + "Add to Cart" */}
          <div className="flex flex-wrap gap-4">
            <Link href="/appointments" passHref>
              <button
                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
              >
                Essayer en Showroom
              </button>
            </Link>

            <button
              onClick={handleAddToCart}
              className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
            >
              Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
            </button>
          </div>
        </div>
      </motion.section>
    </>
  );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
  switch (type) {
    case "diamondShape":
      return "Forme du diamant";
    case "carat":
      return "Carat";
    case "quality":
      return "Qualité";
    case "coupe":
      return "Coupe";
    case "metalColor":
      return "Couleur du métal";
    case "ringSize":
      return "Taille de bague";
    default:
      return type;
  }
}

/* -------------------------------------------------------------------
   ✅ getServerSideProps
   Fetch product, convert decimals to strings, pass to the page
------------------------------------------------------------------- */
export const getServerSideProps: GetServerSideProps = async (context) => {
  const id = parseInt(context.params?.id as string, 10);
  if (isNaN(id)) return { notFound: true };

  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      translations: true,
      variations: true,
    },
  });

  if (!product) {
    return { notFound: true };
  }

  // Convert Decimal fields to string
  const productData = {
    ...product,
    basePrice: product.basePrice.toString(),
    variations: product.variations.map((v) => ({
      ...v,
      additionalPrice: v.additionalPrice.toString(),
    })),
  };

  return {
    props: {
      productData: JSON.parse(JSON.stringify(productData)),
      locale: context.locale || "fr",
    },
  };
};

Key Changes

    Removed max-w-screen-xl & mx-auto
        The main <motion.section> now only has px-6 for horizontal padding.
        This ensures the entire layout spans the available width defined by your layout wrapper (minus 2 inches).

    Two-Column Layout
        For medium screens and larger (md:grid-cols-2), we display the image on the left, details on the right.
        On mobile (grid-cols-1), everything stacks vertically.

    Additional Padding
        We keep py-16 at the top/bottom for vertical spacing and px-6 for horizontal spacing.
        This is purely for readability; adjust these as you see fit.

With these updates, the product detail page seamlessly uses the (100vw - 2in) space from your Layout.tsx, ensuring a full-width experience while still maintaining a bit of padding for visual clarity.
You said:
Now add similar products suggestions bellow centred in the page

Below is an updated product detail page showing similar products below the main product section, centered on the page. We’ll fetch a few products from the same category (or a random subset if category is not available) and display them in a grid. Feel free to adjust the number of similar products, layout, or the logic that finds them.

// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
  language: string;
  name: string;
  description: string;
};

type ProductVariation = {
  id: number;
  variationType: string;
  variationValue: string;
  additionalPrice: string;
};

type ProductData = {
  id: number;
  sku: string;
  basePrice: string;
  images: string[];
  translations: ProductTranslation[];
  variations: ProductVariation[];
  categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
  productData: ProductData | null;
  similarProducts: ProductData[];
  locale: string;
};

export default function ProductPage({
  productData,
  similarProducts,
  locale,
}: ProductPageProps) {
  const { addToCart } = useCart();

  // ──────────────────────────────────────────
  // 1) Basic Checks
  // ──────────────────────────────────────────
  if (!productData) {
    return (
      <section className="py-12 px-6 section-dark">
        <h1 className="text-5xl font-serif text-brandGold mb-4">
          Création Introuvable
        </h1>
        <p className="text-platinumGray">
          La pièce que vous recherchez n’est plus disponible.
        </p>
      </section>
    );
  }

  // ──────────────────────────────────────────
  // 2) Translation
  // ──────────────────────────────────────────
  const productTranslation =
    productData.translations.find((t) => t.language === locale) ||
    productData.translations.find((t) => t.language === "fr") ||
    productData.translations.find((t) => t.language === "en");

  // ──────────────────────────────────────────
  // 3) Variation Selections
  // ──────────────────────────────────────────
  const [selectedVariations, setSelectedVariations] = useState<{
    [key: string]: ProductVariation;
  }>({});

  function updateVariation(variation: ProductVariation) {
    setSelectedVariations((prev) => ({
      ...prev,
      [variation.variationType]: variation,
    }));
  }

  // ──────────────────────────────────────────
  // 4) Pricing
  // ──────────────────────────────────────────
  const basePriceNum = parseFloat(productData.basePrice || "0");
  const additionalPriceSum = useMemo(() => {
    let sum = 0;
    Object.values(selectedVariations).forEach((v) => {
      sum += parseFloat(v.additionalPrice || "0");
    });
    return sum;
  }, [selectedVariations]);

  const totalPrice = basePriceNum + additionalPriceSum;

  // ──────────────────────────────────────────
  // 5) Selected Image
  // ──────────────────────────────────────────
  const [selectedImage, setSelectedImage] = useState(
    productData.images[0] || "/images/placeholder.jpg"
  );

  // ──────────────────────────────────────────
  // 6) Shipping Info (1 Month from Now)
  // ──────────────────────────────────────────
  const currentDate = new Date();
  const shippingDate = new Date(
    currentDate.setMonth(currentDate.getMonth() + 1)
  );
  const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  // ──────────────────────────────────────────
  // 7) Summary of Selections
  // ──────────────────────────────────────────
  const selectionSummary = Object.values(selectedVariations)
    .map((v) => `${v.variationType}: ${v.variationValue}`)
    .join(" | ");

  // ──────────────────────────────────────────
  // 8) Add to Cart
  // ──────────────────────────────────────────
  const handleAddToCart = () => {
    addToCart({
      image: selectedImage,
      productId: productData.id,
      variationId: undefined,
      sku: productData.sku,
      name: productTranslation?.name || "Bijou personnalisé",
      price: totalPrice,
      quantity: 1,
    });
  };

  return (
    <>
      <NextSeo
        title={`Diamant Rouge | ${productTranslation?.name}`}
        description={productTranslation?.description}
        openGraph={{
          title: `Diamant Rouge | ${productTranslation?.name}`,
          description: productTranslation?.description,
        }}
      />

      {/** ─────────────────────────────────────────
           MAIN PRODUCT SECTION
       ───────────────────────────────────────── */}
      <motion.section
        className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
      >
        {/* LEFT: Images */}
        <div>
          {/* Main Image */}
          <div className="relative w-full h-auto mb-4">
            <Image
              src={selectedImage}
              width={700}
              height={700}
              alt={productTranslation?.name || "Bijou Diamant Rouge"}
              className="rounded-lg shadow-luxury"
            />
          </div>

          {/* Thumbnails */}
          <div className="flex gap-3 overflow-x-auto">
            {productData.images.map((img, index) => {
              const isSelected = selectedImage === img;
              return (
                <button
                  key={index}
                  onClick={() => setSelectedImage(img)}
                  className={`border rounded-lg overflow-hidden ${
                    isSelected ? "border-brandGold" : "border-transparent"
                  }`}
                >
                  <Image
                    src={img}
                    width={80}
                    height={80}
                    alt={`Miniature ${index}`}
                    className="object-cover"
                  />
                </button>
              );
            })}
          </div>
        </div>

        {/* RIGHT: Info & Customization */}
        <div>
          {/* Title & Price */}
          <h1 className="text-4xl font-serif text-richEbony mb-2">
            {productTranslation?.name}
          </h1>
          <p className="text-2xl text-brandGold font-bold mb-2">
            {totalPrice.toFixed(2)} MAD
          </p>
          <hr className="border-platinumGray mb-4" />

          {/* Description */}
          <div className="text-platinumGray mb-6">
            {productTranslation?.description}
          </div>

          {/* Material Details */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Détails du Matériau
            </h3>
            <p className="text-platinumGray text-sm">
              Chaque création Diamant Rouge est façonnée à partir de métaux
              nobles et de pierres précieuses soigneusement sélectionnées.
            </p>
          </div>

          {/* Personalization Options */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-richEbony mb-2">
              Personnalisation
            </h3>
            {[
              "diamondShape",
              "carat",
              "quality",
              "coupe",
              "metalColor",
              "ringSize",
            ].map((type) => {
              const variationGroup = productData.variations.filter(
                (v) => v.variationType === type
              );
              if (variationGroup.length === 0) return null;

              return (
                <div key={type} className="mb-4">
                  <p className="font-medium text-sm text-richEbony mb-1">
                    {getVariationLabel(type)}
                  </p>
                  <div className="flex flex-wrap gap-3">
                    {variationGroup.map((variation) => {
                      const isSelected =
                        selectedVariations[type]?.id === variation.id;
                      return (
                        <button
                          key={variation.id}
                          onClick={() => updateVariation(variation)}
                          className={`px-3 py-1 rounded-full border transition
                            ${
                              isSelected
                                ? "bg-burgundy text-brandIvory border-burgundy"
                                : "bg-brandIvory text-richEbony border-burgundy"
                            }
                          `}
                        >
                          {variation.variationValue}
                        </button>
                      );
                    })}
                  </div>
                </div>
              );
            })}
          </div>

          {/* Summary of Selections */}
          {selectionSummary && (
            <div className="mb-6">
              <p className="text-sm text-platinumGray">
                <strong>Votre configuration:</strong> {selectionSummary}
              </p>
            </div>
          )}

          {/* Shipping Info */}
          <div className="mb-6">
            <p className="text-sm text-platinumGray">
              Livraison estimée autour du {shippingDateStr}
            </p>
          </div>

          {/* Paiement Sécurisé */}
          <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
            <p className="text-sm text-richEbony font-semibold">
              Paiement Sécurisé
            </p>
            <Image
              src="/images/icons/img.icons8.png"
              width={40}
              height={24}
              alt="Visa"
            />
            <Image
              src="/images/icons/mastercard-old.svg"
              width={40}
              height={24}
              alt="Mastercard"
            />
          </div>

          {/* Buttons: "Try in Showroom" & "Add to Cart" */}
          <div className="flex flex-wrap gap-4">
            <Link href="/appointments" passHref>
              <button
                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
              >
                Essayer en Showroom
              </button>
            </Link>
            <button
              onClick={handleAddToCart}
              className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
            >
              Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
            </button>
          </div>
        </div>
      </motion.section>

      {/** ─────────────────────────────────────────
           SIMILAR PRODUCTS SECTION
       ───────────────────────────────────────── */}
      {similarProducts.length > 0 && (
        <motion.section
          className="py-12 px-6 text-center"
          initial={{ opacity: 0, y: 50 }}
          whileInView={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          viewport={{ once: true }}
        >
          <h2 className="text-2xl font-serif text-brandGold mb-6">
            Vous aimerez peut-être
          </h2>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
            {similarProducts.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>
        </motion.section>
      )}
    </>
  );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
  switch (type) {
    case "diamondShape":
      return "Forme du diamant";
    case "carat":
      return "Carat";
    case "quality":
      return "Qualité";
    case "coupe":
      return "Coupe";
    case "metalColor":
      return "Couleur du métal";
    case "ringSize":
      return "Taille de bague";
    default:
      return type;
  }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
  const id = parseInt(context.params?.id as string, 10);
  if (isNaN(id)) return { notFound: true };

  const product = await prisma.product.findUnique({
    where: { id },
    include: {
      translations: true,
      variations: true,
      category: true, // if you have a category relation
    },
  });

  if (!product) {
    return { notFound: true };
  }

  // Convert Decimal fields to string
  const productData = {
    ...product,
    basePrice: product.basePrice.toString(),
    variations: product.variations.map((v) => ({
      ...v,
      additionalPrice: v.additionalPrice.toString(),
    })),
  };

  // ─────────────────────────────────────────────────
  // Fetch "Similar Products"
  // e.g. same category (excluding current product)
  // If product.categoryId is null, we can just pick random or top new arrivals
  let similarProducts = [];
  if (product.categoryId) {
    similarProducts = await prisma.product.findMany({
      where: {
        categoryId: product.categoryId,
        id: { not: product.id },
      },
      take: 5,
      include: {
        translations: true,
        variations: true,
      },
    });
  } else {
    // fallback: just get some random products
    similarProducts = await prisma.product.findMany({
      where: {
        id: { not: product.id },
      },
      take: 5,
      include: {
        translations: true,
        variations: true,
      },
    });
  }

  // Convert decimals in similar products
  const similarProductsData = similarProducts.map((p) => ({
    ...p,
    basePrice: p.basePrice.toString(),
    variations: p.variations.map((v) => ({
      ...v,
      additionalPrice: v.additionalPrice.toString(),
    })),
  }));

  return {
    props: {
      productData: JSON.parse(JSON.stringify(productData)),
      similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
      locale: context.locale || "fr",
    },
  };
};

How It Works

    getServerSideProps
        Finds your main product by id.
        Fetches similar products (e.g., from the same category, excluding the current product).
        Converts Decimal fields to strings for Next.js.

    Similar Products Section
        Placed below the main product detail.
        A motion.section with heading “Vous aimerez peut-être”.
        Displays a responsive grid (grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5).
        Centered text (text-center) with each product card centered (justify-items-center).

    Fallback if No Category
        If your product has no category, we simply fetch some random or top 5 products from the database.
        That ensures we always display something under “Vous aimerez peut-être.”

    Centering
        The entire block is in a section with text-center.
        The product grid itself uses justify-items-center to center each card.

You now have a “Similar Products” section at the bottom of the product detail page, showing up to five products from the same category. This ensures a luxury cross-selling flow, letting users explore more items from Diamant Rouge.
You said:
Now let's move on to the checkout page ,after adding to cart and prceed to checkout i wont to have the user option to have the choice to get shiped to the store with the adresse of the store check it or to  ship to the adress associated  to  his account or to choose get shipped to another adresse and then specify the new adresse informations. but before we need to work on getting the user the option  to register an shipping adresse to his account from his profile . so first we need to adjust the user table to have the optional adress on his database table then rework the user profile : "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String // hashed password stored here
  name      String?
  role      String   @default("customer") // can be 'admin' or 'customer'
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"  "import { prisma } from "../lib/prisma";
import { getSession } from "next-auth/react";
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";
import { Minus, Package, ShoppingBag } from "lucide-react"; // ✅ High-End Luxury Icons
import { motion, AnimatePresence } from "framer-motion"; // ✅ Import Framer Motion

type OrderPlus = {
    id: number;
    status: string;
    trackingNumber?: string | null;
    totalAmount: string;
    shippingAddress: string | null;
    city: string | null;
    postalCode: string | null;
    country: string | null;
    createdAt: string;
    orderItems: {
        id: number;
        productId: number;
        quantity: number;
        price: string;
        product?: {
            id: number;
            sku: string;
            images: string[];
            translations: {
                language: string;
                name: string;
            }[];
        };
    }[];
};

type WishlistItem = {
    id: number;
    productId: number;
    product: {
        id: number;
        sku: string;
        basePrice: string;
        images: string[];
        translations: {
            language: string;
            name: string;
        }[];
    };
};

export default function ProfilePage({
                                        orders,
                                        wishlist,
                                        locale,
                                    }: {
    orders: OrderPlus[];
    wishlist: WishlistItem[];
    locale: string;
}) {
    const { removeFromWishlist } = useWishlist();
    const [wishlistItems, setWishlistItems] = useState(wishlist);

    async function handleRemoveFromWishlist(productId: number) {
        setWishlistItems((prev) => prev.filter((item) => item.productId !== productId));
        await removeFromWishlist(productId);
    }

    return (
        <main className="section-light p-8 min-h-screen">
            <h1 className="text-4xl font-serif mb-6 text-brandGold">My Profile</h1>

            {/* Order History */}
            <section className="mb-10">
                <h2 className="text-3xl font-serif mb-4 text-brandGold">Order History</h2>
                {orders.length === 0 ? (
                    <p className="flex items-center gap-2 text-platinumGray">
                        <ShoppingBag className="text-brandGold" size={20} /> You have no orders yet.
                    </p>
                ) : (
                    <ul className="space-y-6">
                        {orders.map((order) => (
                            <li
                                key={order.id}
                                className="bg-burgundy/10 p-4 rounded-lg shadow-luxury relative text-richEbony"
                            >
                                <p>
                                    Order <strong>#{order.id}</strong> -{" "}
                                    <span className="text-brandGold">{order.status}</span>
                                </p>
                                <p>
                                    Total: <strong>€{order.totalAmount}</strong>
                                </p>
                                <p>
                                    Shipped To: {order.shippingAddress}, {order.city}{" "}
                                    {order.postalCode}, {order.country}
                                </p>
                                <p>Placed On: {new Date(order.createdAt).toLocaleString()}</p>

                                {order.trackingNumber && (
                                    <p className="flex items-center gap-2 text-sm text-platinumGray mt-1">
                                        <Package className="text-brandGold" size={18} />{" "}
                                        <strong>{order.trackingNumber}</strong>
                                    </p>
                                )}

                                <ul className="mt-3 space-y-1">
                                    {order.orderItems.map((item) => {
                                        const productName =
                                            item.product?.translations.find((t) => t.language === locale)?.name ||
                                            item.product?.translations.find((t) => t.language === "en")?.name ||
                                            item.product?.sku;

                                        return (
                                            <li key={item.id} className="pl-2 text-platinumGray">
                                                {productName} (Qty: {item.quantity}, Price: €{item.price})
                                            </li>
                                        );
                                    })}
                                </ul>
                            </li>
                        ))}
                    </ul>
                )}
            </section>

            {/* Wishlist Section */}
            <section>
                <h2 className="text-3xl font-serif mb-4 text-brandGold">My Wishlist</h2>
                {wishlistItems.length === 0 ? (
                    <p className="flex items-center gap-2 text-platinumGray">
                        <ShoppingBag className="text-brandGold" size={20} /> Your wishlist is empty.
                    </p>
                ) : (
                    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6">
                        <AnimatePresence>
                            {wishlistItems.map(({ product }) => {
                                const productTranslation =
                                    product.translations.find((t) => t.language === locale) ||
                                    product.translations.find((t) => t.language === "en");

                                return (
                                    <motion.div
                                        key={product.id}
                                        initial={{ opacity: 0, scale: 0.9 }}
                                        animate={{ opacity: 1, scale: 1 }}
                                        exit={{ opacity: 0, scale: 0.8 }}
                                        transition={{ duration: 0.4 }}
                                        className="relative bg-burgundy/10 p-4 rounded-lg text-center shadow-luxury text-richEbony"
                                    >
                                        {/* ✅ Properly Positioned Remove Button */}
                                        <button
                                            onClick={() => handleRemoveFromWishlist(product.id)}
                                            className="absolute top-3 right-3 text-burgundy border border-burgundy p-1 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300"
                                        >
                                            <Minus size={16} />
                                        </button>

                                        <Image
                                            src={
                                                product.images.length > 0
                                                    ? product.images[0]
                                                    : "/images/placeholder.jpg"
                                            }
                                            width={150}
                                            height={150}
                                            alt={productTranslation?.name || "Wishlist Product"}
                                            className="mx-auto rounded-md object-cover"
                                        />
                                        <h3 className="text-lg text-brandGold mt-2">
                                            {productTranslation?.name}
                                        </h3>
                                        <p className="text-platinumGray">
                                            €{parseFloat(product.basePrice).toFixed(2)}
                                        </p>

                                        <Link href={/products/${product.id}} passHref>
                                            <button className="mt-2 bg-brandGold text-richEbony px-4 py-2 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300">
                                                View Product
                                            </button>
                                        </Link>
                                    </motion.div>
                                );
                            })}
                        </AnimatePresence>
                    </div>
                )}
            </section>
        </main>
    );
}

export async function getServerSideProps(context: any) {
    const session = await getSession(context);
    if (!session) {
        return { redirect: { destination: "/login", permanent: false } };
    }

    const userId = Number(session.user.id);
    const locale = context.locale || "en";

    try {
        // ✅ Fetch orders with tracking numbers & product images
        const rawOrders = await prisma.order.findMany({
            where: { userId },
            include: {
                orderItems: {
                    include: {
                        product: {
                            select: {
                                id: true,
                                sku: true,
                                images: true,
                                translations: {
                                    select: { language: true, name: true },
                                },
                            },
                        },
                    },
                },
            },
            orderBy: { createdAt: "desc" },
        });

        // ✅ Fetch wishlist with product images
        const rawWishlist = await prisma.wishlist.findMany({
            where: { userId },
            include: {
                product: {
                    select: {
                        id: true,
                        sku: true,
                        basePrice: true,
                        images: true,
                        translations: {
                            select: { language: true, name: true },
                        },
                    },
                },
            },
        });

        return {
            props: {
                orders: JSON.parse(JSON.stringify(rawOrders)),
                wishlist: JSON.parse(JSON.stringify(rawWishlist)),
                locale,
            },
        };
    } catch (error) {
        console.error("❌ Profile SSR error:", error);
        return {
            props: { orders: [], wishlist: [], locale },
        };
    }
}
"

Below is a step-by-step guide for:

    Updating your Prisma schema to add optional address fields for the user.
    Migrating your database so the new columns appear.
    Adding an “Address” section to your Profile page, where users can view/edit their shipping address.
    Creating a simple API route (/api/user/update-address) to save the address fields to the database.

Once you have this address saved to each user, you can later offer a checkout option to ship to the user’s saved address, a new custom address, or to pick up in-store.
1) Extend the User Model in schema.prisma

Add these optional address fields to your User model:

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String?
  role      String   @default("customer")
+ address    String?
+ city       String?
+ postalCode String?
+ country    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}

Apply the Migration

    Edit your schema.prisma file.
    Run:

    npx prisma migrate dev --name "add_user_address_fields"

    (Or db push, if that’s your workflow.)

Now your database has address, city, postalCode, and country columns in the User table.
2) Profile Page: “Shipping Address” Section

Here’s how you can extend your existing ProfilePage to include an Address form. We’ll:

    Fetch the user’s address fields (address, city, postalCode, country) in getServerSideProps.
    Display them in a small edit form.
    When the user submits, we’ll call a new API route to update the user’s address in the DB.

Below is an example snippet modifying your ProfilePage from your provided code. Focus on the “My Address” section. You can adapt it to your design.

// pages/profile.tsx

import { prisma } from "../lib/prisma";
import { getSession } from "next-auth/react";
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";
import { Minus, Package, ShoppingBag } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";

// ... Your existing types for OrderPlus, WishlistItem, etc.

type ProfilePageProps = {
  orders: OrderPlus[];
  wishlist: WishlistItem[];
  locale: string;

  // 🆕 Address Fields
  address: string | null;
  city: string | null;
  postalCode: string | null;
  country: string | null;
};

export default function ProfilePage({
  orders,
  wishlist,
  locale,
  address: initialAddress,
  city: initialCity,
  postalCode: initialPostal,
  country: initialCountry,
}: ProfilePageProps) {
  const { removeFromWishlist } = useWishlist();
  const [wishlistItems, setWishlistItems] = useState(wishlist);

  // 🆕 State to hold address edits
  const [address, setAddress] = useState(initialAddress || "");
  const [city, setCity] = useState(initialCity || "");
  const [postalCode, setPostalCode] = useState(initialPostal || "");
  const [country, setCountry] = useState(initialCountry || "");

  // 🆕 Confirm Message
  const [updateMsg, setUpdateMsg] = useState("");

  async function handleRemoveFromWishlist(productId: number) {
    setWishlistItems((prev) => prev.filter((item) => item.productId !== productId));
    await removeFromWishlist(productId);
  }

  // 🆕 Handle Save Address
  async function handleSaveAddress(e: React.FormEvent) {
    e.preventDefault();
    setUpdateMsg("");

    try {
      const res = await fetch("/api/user/update-address", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ address, city, postalCode, country }),
      });
      if (res.ok) {
        setUpdateMsg("Adresse mise à jour avec succès !");
      } else {
        setUpdateMsg("Erreur lors de la mise à jour de l'adresse.");
      }
    } catch (error) {
      console.error("Update address error:", error);
      setUpdateMsg("Erreur lors de la mise à jour de l'adresse.");
    }
  }

  return (
    <main className="section-light p-8 min-h-screen">
      <h1 className="text-4xl font-serif mb-6 text-brandGold">Mon Profil</h1>

      {/* 🆕 My Address Section */}
      <section className="mb-10 bg-burgundy/10 p-4 rounded-lg shadow-luxury">
        <h2 className="text-3xl font-serif mb-4 text-brandGold">
          Mon Adresse de Livraison
        </h2>
        <form onSubmit={handleSaveAddress} className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Adresse
            </label>
            <input
              type="text"
              value={address}
              onChange={(e) => setAddress(e.target.value)}
              className="input-field w-full"
            />
          </div>
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Ville
            </label>
            <input
              type="text"
              value={city}
              onChange={(e) => setCity(e.target.value)}
              className="input-field w-full"
            />
          </div>
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Code Postal
            </label>
            <input
              type="text"
              value={postalCode}
              onChange={(e) => setPostalCode(e.target.value)}
              className="input-field w-full"
            />
          </div>
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Pays
            </label>
            <input
              type="text"
              value={country}
              onChange={(e) => setCountry(e.target.value)}
              className="input-field w-full"
            />
          </div>
          <div className="col-span-full mt-3">
            <button type="submit" className="button-primary">
              Enregistrer
            </button>
            {updateMsg && (
              <p className="text-sm text-burgundy mt-2 font-semibold">
                {updateMsg}
              </p>
            )}
          </div>
        </form>
      </section>

      {/* Order History */}
      <section className="mb-10">
        {/* ... your existing Orders UI ... */}
      </section>

      {/* Wishlist Section */}
      <section>
        {/* ... your existing Wishlist UI ... */}
      </section>
    </main>
  );
}

// ✅ Extend getServerSideProps to fetch user address
export async function getServerSideProps(context: any) {
  const session = await getSession(context);
  if (!session) {
    return { redirect: { destination: "/login", permanent: false } };
  }

  const userId = Number(session.user.id);
  const locale = context.locale || "en";

  try {
    // 1) Fetch user to get address
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        address: true,
        city: true,
        postalCode: true,
        country: true,
      },
    });

    // 2) Fetch orders
    const rawOrders = await prisma.order.findMany({
      where: { userId },
      include: {
        orderItems: {
          include: {
            product: {
              select: {
                id: true,
                sku: true,
                images: true,
                translations: {
                  select: { language: true, name: true },
                },
              },
            },
          },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // 3) Fetch wishlist
    const rawWishlist = await prisma.wishlist.findMany({
      where: { userId },
      include: {
        product: {
          select: {
            id: true,
            sku: true,
            basePrice: true,
            images: true,
            translations: {
              select: { language: true, name: true },
            },
          },
        },
      },
    });

    return {
      props: {
        orders: JSON.parse(JSON.stringify(rawOrders)),
        wishlist: JSON.parse(JSON.stringify(rawWishlist)),
        locale,
        address: user?.address || null,
        city: user?.city || null,
        postalCode: user?.postalCode || null,
        country: user?.country || null,
      },
    };
  } catch (error) {
    console.error("❌ Profile SSR error:", error);
    return {
      props: {
        orders: [],
        wishlist: [],
        locale,
        address: null,
        city: null,
        postalCode: null,
        country: null,
      },
    };
  }
}

3) API Route: /api/user/update-address.ts

Create a simple POST endpoint that:

    Authenticates the user.
    Updates the address fields in the User table.

// pages/api/user/update-address.ts
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import type { NextApiRequest, NextApiResponse } from "next";

export default async function updateAddress(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const session = await getSession({ req });
  if (!session || !session.user?.id) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const userId = Number(session.user.id);

  const { address, city, postalCode, country } = req.body;

  try {
    await prisma.user.update({
      where: { id: userId },
      data: {
        address: address || null,
        city: city || null,
        postalCode: postalCode || null,
        country: country || null,
      },
    });

    return res.status(200).json({ message: "Address updated successfully" });
  } catch (error) {
    console.error("Error updating address:", error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}

Now your profile page can POST to this route. The user can store or update their shipping address. Once saved, you can show that address in the checkout flow.
4) How This Ties into Checkout

With the user’s address stored, your checkout page can do the following:

    Fetch the user’s default address from the DB.
    Let them pick:
        Pickup In-Store (You provide the store’s address, e.g., “Boulevard de Paris, Casablanca…”)
        Ship to My Saved Address (the user’s default address, city, postal code, country)
        Ship to a New Address (show a quick form to fill in a one-time address for this order)

Then you pass that chosen shipping address into the Order record’s shippingAddress, city, postalCode, country fields. This ensures each order tracks exactly where it should be delivered (even if it’s a custom address not saved in the user’s profile).
Conclusion

    Updated User model: address, city, postalCode, country.
    Profile page now has a form to edit those fields.
    API route saves them in the DB.
    Checkout can see the user’s stored address and give them the option to use or override it.

This setup provides a luxury experience where users can effortlessly manage their shipping details and choose how they’d like to receive their Diamant Rouge creations!
You said:
the user adresse should have a valid phone number either
Reasoned for a second

Below is how you can extend your User model to include an optional phone number field, then display and edit it in your Profile page. The process follows the same pattern as adding address fields:
1) Prisma Schema Update

Add a phoneNumber field to the User model:

model User {
  id         Int      @id @default(autoincrement())
  email      String   @unique
  password   String
  name       String?
  role       String   @default("customer")
+ phoneNumber String?
  address    String?
  city       String?
  postalCode String?
  country    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}

Then run:

npx prisma migrate dev --name "add_phoneNumber_to_user"

Now your User table includes a nullable phoneNumber column.
2) Add Phone Input in Profile Page

Building upon the existing ProfilePage snippet with address fields, we can add one more input for the phone number. We’ll fetch and display it the same way.

// pages/profile.tsx

import { prisma } from "../lib/prisma";
import { getSession } from "next-auth/react";
import Link from "next/link";
import Image from "next/image";
import { useWishlist } from "../contexts/WishlistContext";
import { useState } from "react";
import { Minus, Package, ShoppingBag } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";

// ... your existing types like OrderPlus, WishlistItem, etc.

type ProfilePageProps = {
  orders: OrderPlus[];
  wishlist: WishlistItem[];
  locale: string;

  // Address and phone fields
  address: string | null;
  city: string | null;
  postalCode: string | null;
  country: string | null;
  phoneNumber: string | null;
};

export default function ProfilePage({
  orders,
  wishlist,
  locale,
  address: initialAddress,
  city: initialCity,
  postalCode: initialPostal,
  country: initialCountry,
  phoneNumber: initialPhone,
}: ProfilePageProps) {
  const { removeFromWishlist } = useWishlist();
  const [wishlistItems, setWishlistItems] = useState(wishlist);

  // Address & phone state
  const [address, setAddress] = useState(initialAddress || "");
  const [city, setCity] = useState(initialCity || "");
  const [postalCode, setPostalCode] = useState(initialPostal || "");
  const [country, setCountry] = useState(initialCountry || "");
  const [phoneNumber, setPhoneNumber] = useState(initialPhone || "");

  const [updateMsg, setUpdateMsg] = useState("");

  async function handleRemoveFromWishlist(productId: number) {
    setWishlistItems((prev) => prev.filter((item) => item.productId !== productId));
    await removeFromWishlist(productId);
  }

  // Handle saving address & phone
  async function handleSaveAddress(e: React.FormEvent) {
    e.preventDefault();
    setUpdateMsg("");

    try {
      const res = await fetch("/api/user/update-address", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ address, city, postalCode, country, phoneNumber }),
      });
      if (res.ok) {
        setUpdateMsg("Informations mises à jour avec succès !");
      } else {
        setUpdateMsg("Erreur lors de la mise à jour des informations.");
      }
    } catch (error) {
      console.error("Update address/phone error:", error);
      setUpdateMsg("Erreur lors de la mise à jour des informations.");
    }
  }

  return (
    <main className="section-light p-8 min-h-screen">
      <h1 className="text-4xl font-serif mb-6 text-brandGold">Mon Profil</h1>

      {/* Address & Phone Section */}
      <section className="mb-10 bg-burgundy/10 p-4 rounded-lg shadow-luxury">
        <h2 className="text-3xl font-serif mb-4 text-brandGold">
          Informations de Livraison
        </h2>
        <form onSubmit={handleSaveAddress} className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {/* Address */}
          <div>
            <label className="block text-sm text-platinumGray mb-1">Adresse</label>
            <input
              type="text"
              value={address}
              onChange={(e) => setAddress(e.target.value)}
              className="input-field w-full"
            />
          </div>

          {/* City */}
          <div>
            <label className="block text-sm text-platinumGray mb-1">Ville</label>
            <input
              type="text"
              value={city}
              onChange={(e) => setCity(e.target.value)}
              className="input-field w-full"
            />
          </div>

          {/* Postal Code */}
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Code Postal
            </label>
            <input
              type="text"
              value={postalCode}
              onChange={(e) => setPostalCode(e.target.value)}
              className="input-field w-full"
            />
          </div>

          {/* Country */}
          <div>
            <label className="block text-sm text-platinumGray mb-1">Pays</label>
            <input
              type="text"
              value={country}
              onChange={(e) => setCountry(e.target.value)}
              className="input-field w-full"
            />
          </div>

          {/* Phone Number */}
          <div>
            <label className="block text-sm text-platinumGray mb-1">
              Numéro de Téléphone
            </label>
            <input
              type="text"
              value={phoneNumber}
              onChange={(e) => setPhoneNumber(e.target.value)}
              className="input-field w-full"
            />
          </div>

          <div className="col-span-full mt-3">
            <button type="submit" className="button-primary">
              Enregistrer
            </button>
            {updateMsg && (
              <p className="text-sm text-burgundy mt-2 font-semibold">
                {updateMsg}
              </p>
            )}
          </div>
        </form>
      </section>

      {/* Order History */}
      <section className="mb-10">
        <h2 className="text-3xl font-serif mb-4 text-brandGold">Mes Commandes</h2>
        {/* ... your existing Orders UI ... */}
      </section>

      {/* Wishlist Section */}
      <section>
        <h2 className="text-3xl font-serif mb-4 text-brandGold">Ma Wishlist</h2>
        {/* ... your existing Wishlist UI ... */}
      </section>
    </main>
  );
}

// Extend getServerSideProps
export async function getServerSideProps(context: any) {
  const session = await getSession(context);
  if (!session) {
    return { redirect: { destination: "/login", permanent: false } };
  }

  const userId = Number(session.user.id);
  const locale = context.locale || "en";

  try {
    // 🆕 Fetch user to get address & phone
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        address: true,
        city: true,
        postalCode: true,
        country: true,
        phoneNumber: true,
      },
    });

    // Orders
    const rawOrders = await prisma.order.findMany({
      where: { userId },
      include: {
        orderItems: {
          include: {
            product: {
              select: {
                id: true,
                sku: true,
                images: true,
                translations: {
                  select: { language: true, name: true },
                },
              },
            },
          },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    // Wishlist
    const rawWishlist = await prisma.wishlist.findMany({
      where: { userId },
      include: {
        product: {
          select: {
            id: true,
            sku: true,
            basePrice: true,
            images: true,
            translations: {
              select: { language: true, name: true },
            },
          },
        },
      },
    });

    return {
      props: {
        orders: JSON.parse(JSON.stringify(rawOrders)),
        wishlist: JSON.parse(JSON.stringify(rawWishlist)),
        locale,
        address: user?.address || null,
        city: user?.city || null,
        postalCode: user?.postalCode || null,
        country: user?.country || null,
        phoneNumber: user?.phoneNumber || null,
      },
    };
  } catch (error) {
    console.error("❌ Profile SSR error:", error);
    return {
      props: {
        orders: [],
        wishlist: [],
        locale,
        address: null,
        city: null,
        postalCode: null,
        country: null,
        phoneNumber: null,
      },
    };
  }
}

3) Update the API Route

As you did for the address, extend /api/user/update-address to also accept and update phoneNumber:

// pages/api/user/update-address.ts

import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import type { NextApiRequest, NextApiResponse } from "next";

export default async function updateAddress(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const session = await getSession({ req });
  if (!session || !session.user?.id) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const userId = Number(session.user.id);

  const { address, city, postalCode, country, phoneNumber } = req.body;

  try {
    await prisma.user.update({
      where: { id: userId },
      data: {
        address: address || null,
        city: city || null,
        postalCode: postalCode || null,
        country: country || null,
        phoneNumber: phoneNumber || null, // ✅ update phone
      },
    });

    return res.status(200).json({ message: "Address/Phone updated successfully" });
  } catch (error) {
    console.error("Error updating address:", error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}

4) Validation of Phone Format (Optional)

If you want to validate the phone number (e.g., using a library like libphonenumber-js), you can do that in the API route or client side. For example:

import { parsePhoneNumberFromString } from 'libphonenumber-js';
// ...
const parsed = parsePhoneNumberFromString(phoneNumber, 'MA'); // if you're in Morocco
if (!parsed?.isValid()) {
  return res.status(400).json({ error: "Invalid phone number" });
}

Then store the formatted or raw version as you prefer.
Summary

    Prisma: Add phoneNumber String? to the User model.
    Migration: npx prisma migrate dev --name "add_phoneNumber_to_user".
    Profile Page: Show an input for phone number. Extend your API route to store it in user.phoneNumber.
    (Optional) Validation: Use client or server code to ensure phone format.

Now each user can save a valid phone number in their profile—critical for shipping or contact details in your Diamant Rouge experience.
You said:
use the manual token parse to check the session , usesession is not working  "
    console.log('📥 Received request body:', req.body);

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    const rawCookie = req.headers.cookie || '';
    let match = rawCookie.match(/next-auth\.session-token=([^;]+)/);
    if (!match) {
        match = rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
        if (!match) {
            console.log('❌ No session token found. Returning 401.');
            return res.status(401).json({ error: 'User not authenticated. No token found.' });
        }
    }

    const tokenStr = decodeURIComponent(match[1]);

    let payload: DecodedPayload | null = null;
    try {
        const secret = process.env.NEXTAUTH_SECRET || '';
        const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));

        console.log('✅ Token decoded:', decoded);
        if (typeof decoded !== 'object' || !decoded.id || !decoded.email) {
            throw new Error('Invalid token payload structure.');
        }
        payload = decoded as unknown as DecodedPayload;
    } catch (err) {
        console.error('❌ Token verification failed:', err);
        return res.status(401).json({ error: 'User not authenticated. Invalid token.' });
    }

    if (!payload) {
        console.error('❌ Token payload is null. Returning 401.');
        return res.status(401).json({ error: 'User not authenticated. Invalid token payload.' });
    }

    console.log('✅ User ID =>', payload.id);
    const userId = Number(payload.id);"
2/2
Reasoned for a second

Below is an API route snippet demonstrating how to manually parse the session token from cookies (rather than relying on useSession or getSession) to authenticate the user. We’ll verify the token with jwtVerify from jose, extract the user ID (and optional email), then proceed with your logic (e.g., updating a user’s address).

Feel free to adapt this snippet to match your existing naming patterns and data fields.

// pages/api/user/update-address.ts

import type { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";
import { jwtVerify } from "jose"; // Make sure you have "jose" installed
import { DecodedPayload } from "../../../types/DecodedPayload"; 
// or define your own type inline:
// type DecodedPayload = { id: string | number; email: string; iat?: number; exp?: number };

export default async function updateAddress(
  req: NextApiRequest,
  res: NextApiResponse
) {
  console.log("📥 Received request body:", req.body);

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  // ----- 1) Parse raw cookies for session token -----
  const rawCookie = req.headers.cookie || "";
  let match = rawCookie.match(/next-auth\.session-token=([^;]+)/);
  if (!match) {
    match = rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) {
      console.log("❌ No session token found. Returning 401.");
      return res
        .status(401)
        .json({ error: "User not authenticated. No token found." });
    }
  }
  const tokenStr = decodeURIComponent(match[1]);

  // ----- 2) Verify token using "jose" -----
  let payload: DecodedPayload | null = null;
  try {
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );

    console.log("✅ Token decoded:", decoded);
    if (typeof decoded !== "object" || !decoded.id || !decoded.email) {
      throw new Error("Invalid token payload structure.");
    }
    payload = decoded as DecodedPayload; 
  } catch (err) {
    console.error("❌ Token verification failed:", err);
    return res
      .status(401)
      .json({ error: "User not authenticated. Invalid token." });
  }

  if (!payload) {
    console.error("❌ Token payload is null. Returning 401.");
    return res
      .status(401)
      .json({ error: "User not authenticated. Invalid token payload." });
  }

  // ----- 3) We have a valid payload => get user ID -----
  console.log("✅ User ID =>", payload.id);
  const userId = Number(payload.id);

  // ----- 4) Access the request body (address, phone, etc.) -----
  const { address, city, postalCode, country, phoneNumber } = req.body;

  try {
    // ----- 5) Update user in the database -----
    await prisma.user.update({
      where: { id: userId },
      data: {
        address: address || null,
        city: city || null,
        postalCode: postalCode || null,
        country: country || null,
        phoneNumber: phoneNumber || null,
      },
    });

    console.log("✅ Address/Phone updated for user ID:", userId);
    return res.status(200).json({ message: "Address/Phone updated successfully" });
  } catch (error) {
    console.error("❌ Error updating user address/phone:", error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}

Explanation

    Parse Session Token
        We look for next-auth.session-token or __Secure-next-auth.session-token in the cookie string.
        If neither is found, we return a 401.

    Verify with jose
        We call jwtVerify(tokenStr, new TextEncoder().encode(secret)).
        Extract payload to confirm we have id and email. If missing or invalid, we return 401.

    Fetch & Update Database
        We convert payload.id to a number, then call prisma.user.update(...).
        The request body holds the new address/phone data. If you want to store additional fields, expand the code accordingly.

    Return
        If everything succeeds, we send 200 with a success message. Otherwise, 500 for unexpected errors.

This snippet gives you a robust, manual token-based check for user authentication in Next.js API routes without using useSession or getSession.
You said:
Now lets proceed to the checkout page doing the necessary updates described above : "import { useCart } from "../contexts/CartContext";
import { useState } from "react";
import { useRouter } from "next/router";

export default function CheckoutPage() {
    const { cart, clearCart } = useCart();
    const [checkoutComplete, setCheckoutComplete] = useState(false);
    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);
    const router = useRouter();

    // Payment method state
    const [paymentMethod, setPaymentMethod] = useState<"CMI" | "COD" | "">("");

    // Shipping info states
    const [shippingAddress, setShippingAddress] = useState("");
    const [city, setCity] = useState("");
    const [postalCode, setPostalCode] = useState("");
    const [country, setCountry] = useState("");

    const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

    async function handleCheckout() {
        setLoading(true);
        setError("");

        if (!paymentMethod) {
            setError("⚠ Please select a payment method.");
            setLoading(false);
            return;
        }

        if (!shippingAddress || !city || !postalCode || !country) {
            setError("⚠ Please fill out all shipping details.");
            setLoading(false);
            return;
        }

        try {
            if (paymentMethod === "CMI") {
                const res = await fetch("/api/payment/cmi", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        orderId: Date.now().toString(),
                        amount: total,
                        customerEmail: "customer@example.com", // Replace with actual email
                    }),
                });

                const data = await res.json();
                if (data.redirectUrl) {
                    window.location.href = data.redirectUrl;
                } else {
                    setError("⚠ Payment error. Please try again.");
                }
            } else {
                const res = await fetch("/api/order/place-order", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        cart,
                        paymentMethod,
                        shippingAddress,
                        city,
                        postalCode,
                        country,
                    }),
                });

                const data = await res.json();
                if (!res.ok) {
                    setError(data.error || "⚠ Failed to place order");
                    return;
                }

                clearCart();
                setCheckoutComplete(true);
            }
        } catch (err) {
            console.error(err);
            setError("⚠ An error occurred placing your order.");
        } finally {
            setLoading(false);
        }
    }

    if (checkoutComplete) {
        return (
            <main className="section-light p-8 text-center min-h-screen">
                <h1 className="text-4xl font-serif text-brandGold mb-4">Thank You!</h1>
                <p className="text-platinumGray">Your order has been placed successfully.</p>
                <button
                    className="mt-4 bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full transition duration-300"
                    onClick={() => router.push("/profile")}
                >
                    View My Orders
                </button>
            </main>
        );
    }

    if (cart.length === 0) {
        return (
            <main className="section-light p-8 text-center min-h-screen">
                <h1 className="text-4xl font-serif text-brandGold mb-4">Checkout</h1>
                <p className="text-platinumGray">Your cart is empty.</p>
                <button
                    className="mt-4 bg-brandGold text-richEbony px-6 py-3 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300"
                    onClick={() => router.push("/")}
                >
                    Continue Shopping
                </button>
            </main>
        );
    }

    return (
        <main className="section-light p-8 max-w-2xl mx-auto min-h-screen">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Checkout</h1>
            <div className="mb-4">
                <p className="text-2xl font-bold text-brandGold">
                    Total: €{total.toFixed(2)}
                </p>
            </div>

            {/* Payment Method Selection */}
            <div className="mb-6">
                <label className="block text-lg font-semibold text-richEbony mb-2">
                    Select Payment Method
                </label>
                <div className="flex gap-4">
                    <button
                        className={px-6 py-3 rounded-full transition duration-300 ${
                            paymentMethod === "CMI"
                                ? "bg-brandGold text-richEbony"
                                : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                        }}
                        onClick={() => setPaymentMethod("CMI")}
                    >
                        Pay with Credit Card (CMI)
                    </button>
                    <button
                        className={px-6 py-3 rounded-full transition duration-300 ${
                            paymentMethod === "COD"
                                ? "bg-brandGold text-richEbony"
                                : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                        }}
                        onClick={() => setPaymentMethod("COD")}
                    >
                        Pay on Delivery
                    </button>
                </div>
            </div>

            {/* Shipping Info */}
            <div className="mb-4 space-y-2">
                <label className="block text-lg font-semibold text-richEbony">
                    Address
                </label>
                <input
                    className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                    value={shippingAddress}
                    onChange={(e) => setShippingAddress(e.target.value)}
                    placeholder="Enter your shipping address"
                />
            </div>
            <div className="mb-4 space-y-2 flex gap-4">
                <div className="flex-1">
                    <label className="block text-lg font-semibold text-richEbony">
                        City
                    </label>
                    <input
                        className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                        value={city}
                        onChange={(e) => setCity(e.target.value)}
                        placeholder="Enter city"
                    />
                </div>
                <div className="flex-1">
                    <label className="block text-lg font-semibold text-richEbony">
                        Postal Code
                    </label>
                    <input
                        className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                        value={postalCode}
                        onChange={(e) => setPostalCode(e.target.value)}
                        placeholder="Enter postal code"
                    />
                </div>
            </div>
            <div className="mb-6 space-y-2">
                <label className="block text-lg font-semibold text-richEbony">
                    Country
                </label>
                <input
                    className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                    value={country}
                    onChange={(e) => setCountry(e.target.value)}
                    placeholder="Enter country"
                />
            </div>

            {error && <p className="text-burgundy text-lg mb-4">{error}</p>}

            <button
                onClick={handleCheckout}
                disabled={loading}
                className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full font-medium transition w-full duration-300"
            >
                {loading ? "Processing..." : "Confirm & Pay"}
            </button>
        </main>
    );
}
'
2/2

Below is a reworked CheckoutPage that provides three shipping options:

    Pickup In-Store – Uses a predefined store address (no user address needed).
    Ship to My Profile Address – Pulls the user’s saved address from the database (city, postal code, country, phone, etc.).
    Ship to a New Address – Allows the user to manually input a new address.

We’ll fetch the user’s address from the DB in getServerSideProps, using a manual token parse to authenticate. If the user is not logged in, we redirect to login. This ensures the user has an existing session. Once we have the user’s address data, we pass it to the client, so the checkout can display the appropriate shipping option.

Finally, the handleCheckout method builds the correct shipping address based on the user’s selection, then calls /api/order/place-order.
1) API Route or SSR for User Address

To follow the pattern from your snippet, we’ll do server-side data fetching in the checkout page. For a purely client approach, you could also fetch from an API. The SSR approach is straightforward for Next.js:

// pages/checkout.tsx (Example name)

import { useCart } from "../contexts/CartContext";
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { GetServerSideProps } from "next";
import { prisma } from "../lib/prisma";
import { jwtVerify } from "jose";

type CheckoutProps = {
  userId: number | null;
  userAddress?: string;
  userCity?: string;
  userPostalCode?: string;
  userCountry?: string;
};

export default function CheckoutPage({
  userId,
  userAddress,
  userCity,
  userPostalCode,
  userCountry,
}: CheckoutProps) {
  const { cart, clearCart } = useCart();
  const [checkoutComplete, setCheckoutComplete] = useState(false);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  // Payment method state
  const [paymentMethod, setPaymentMethod] = useState<"CMI" | "COD" | "">("");

  // ─────────────────────────────────────────────────
  // 1) Shipping Option => "STORE", "PROFILE", or "NEW"
  // ─────────────────────────────────────────────────
  const [shippingOption, setShippingOption] = useState<"STORE" | "PROFILE" | "NEW" | "">("");

  // We'll store the final shipping address data here
  const [shippingAddress, setShippingAddress] = useState("");
  const [city, setCity] = useState("");
  const [postalCode, setPostalCode] = useState("");
  const [country, setCountry] = useState("");

  // The store’s address for in-store pickup
  const storeAddress = "Diamant Rouge Boutique, 123 Rue de la Joaillerie, Casablanca";

  // Calculate cart total
  const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

  // ─────────────────────────────────────────────────
  // 2) Whenever user chooses "PROFILE", fill in from user data
  //    If user chooses "STORE", we set address to store's address
  //    If "NEW", we let them fill it out manually (fields remain blank)
  // ─────────────────────────────────────────────────
  useEffect(() => {
    if (shippingOption === "STORE") {
      setShippingAddress(storeAddress);
      setCity("Casablanca");
      setPostalCode("20000");
      setCountry("Maroc");
    } else if (shippingOption === "PROFILE") {
      // Use user’s DB address if available
      setShippingAddress(userAddress || "");
      setCity(userCity || "");
      setPostalCode(userPostalCode || "");
      setCountry(userCountry || "");
    } else if (shippingOption === "NEW") {
      setShippingAddress("");
      setCity("");
      setPostalCode("");
      setCountry("");
    }
  }, [shippingOption]);

  // ─────────────────────────────────────────────────
  // 3) Handle Checkout
  // ─────────────────────────────────────────────────
  async function handleCheckout() {
    setLoading(true);
    setError("");

    // Basic validations
    if (!paymentMethod) {
      setError("⚠ Veuillez sélectionner un mode de paiement.");
      setLoading(false);
      return;
    }
    if (!shippingOption) {
      setError("⚠ Veuillez sélectionner une option de livraison.");
      setLoading(false);
      return;
    }

    // If shipping is "STORE", we already set the store’s address in state.
    // If shipping is "PROFILE", we used the user’s address from DB.
    // If shipping is "NEW", the user must fill out all fields:
    if (shippingOption === "NEW") {
      if (!shippingAddress || !city || !postalCode || !country) {
        setError("⚠ Veuillez remplir tous les champs pour la livraison.");
        setLoading(false);
        return;
      }
    }

    try {
      if (paymentMethod === "CMI") {
        // Simulate or call your /api/payment/cmi route
        const res = await fetch("/api/payment/cmi", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            orderId: Date.now().toString(),
            amount: total,
            customerEmail: "customer@example.com", // Replace with actual email from user
          }),
        });

        const data = await res.json();
        if (data.redirectUrl) {
          window.location.href = data.redirectUrl;
        } else {
          setError("⚠ Erreur lors du paiement. Veuillez réessayer.");
        }
      } else {
        // Place order for COD or any other payment method
        const res = await fetch("/api/order/place-order", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            cart,
            paymentMethod,
            shippingAddress,
            city,
            postalCode,
            country,
          }),
        });

        const data = await res.json();
        if (!res.ok) {
          setError(data.error || "⚠ Échec de la commande.");
          return;
        }
        clearCart();
        setCheckoutComplete(true);
      }
    } catch (err) {
      console.error(err);
      setError("⚠ Une erreur est survenue lors du traitement de votre commande.");
    } finally {
      setLoading(false);
    }
  }

  // ─────────────────────────────────────────────────
  // 4) Render States
  // ─────────────────────────────────────────────────
  if (checkoutComplete) {
    return (
      <main className="section-light p-8 text-center min-h-screen">
        <h1 className="text-4xl font-serif text-brandGold mb-4">Merci!</h1>
        <p className="text-platinumGray">Votre commande a bien été passée.</p>
        <button
          className="mt-4 bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full transition duration-300"
          onClick={() => router.push("/profile")}
        >
          Voir Mes Commandes
        </button>
      </main>
    );
  }

  if (cart.length === 0) {
    return (
      <main className="section-light p-8 text-center min-h-screen">
        <h1 className="text-4xl font-serif text-brandGold mb-4">Checkout</h1>
        <p className="text-platinumGray">Votre panier est vide.</p>
        <button
          className="mt-4 bg-brandGold text-richEbony px-6 py-3 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300"
          onClick={() => router.push("/")}
        >
          Continuer vos Achats
        </button>
      </main>
    );
  }

  return (
    <main className="section-light p-8 max-w-2xl mx-auto min-h-screen">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Checkout</h1>
      <div className="mb-4">
        <p className="text-2xl font-bold text-brandGold">
          Total: {total.toFixed(2)} MAD
        </p>
      </div>

      {/* ─────────────────────────────────────────────────
          Shipping Options (STORE, PROFILE, NEW)
      ───────────────────────────────────────────────── */}
      <div className="mb-8">
        <label className="block text-lg font-semibold text-richEbony mb-2">
          Mode de Livraison
        </label>
        <div className="flex flex-col gap-2">
          <label className="flex items-center gap-2">
            <input
              type="radio"
              name="shippingOption"
              value="STORE"
              checked={shippingOption === "STORE"}
              onChange={() => setShippingOption("STORE")}
            />
            <span>Retrait en Boutique (Casablanca)</span>
          </label>

          {userId ? (
            <label className="flex items-center gap-2">
              <input
                type="radio"
                name="shippingOption"
                value="PROFILE"
                checked={shippingOption === "PROFILE"}
                onChange={() => setShippingOption("PROFILE")}
              />
              <span>
                Utiliser Mon Adresse de Profil
                {userAddress ? (
                  <em className="text-sm text-platinumGray ml-2">
                    ({userAddress}, {userCity}, {userPostalCode}, {userCountry})
                  </em>
                ) : (
                  <em className="text-sm text-burgundy ml-2">
                    (Aucune adresse enregistrée)
                  </em>
                )}
              </span>
            </label>
          ) : null}

          <label className="flex items-center gap-2">
            <input
              type="radio"
              name="shippingOption"
              value="NEW"
              checked={shippingOption === "NEW"}
              onChange={() => setShippingOption("NEW")}
            />
            <span>Entrer une Nouvelle Adresse</span>
          </label>
        </div>
      </div>

      {/* Only show address fields if shippingOption === "NEW" */}
      {shippingOption === "NEW" && (
        <div>
          <div className="mb-4 space-y-2">
            <label className="block text-lg font-semibold text-richEbony">
              Adresse
            </label>
            <input
              className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
              value={shippingAddress}
              onChange={(e) => setShippingAddress(e.target.value)}
              placeholder="Entrez votre adresse"
            />
          </div>
          <div className="mb-4 space-y-2 flex gap-4">
            <div className="flex-1">
              <label className="block text-lg font-semibold text-richEbony">
                Ville
              </label>
              <input
                className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                value={city}
                onChange={(e) => setCity(e.target.value)}
                placeholder="Entrez la ville"
              />
            </div>
            <div className="flex-1">
              <label className="block text-lg font-semibold text-richEbony">
                Code Postal
              </label>
              <input
                className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
                value={postalCode}
                onChange={(e) => setPostalCode(e.target.value)}
                placeholder="Entrez le code postal"
              />
            </div>
          </div>
          <div className="mb-6 space-y-2">
            <label className="block text-lg font-semibold text-richEbony">
              Pays
            </label>
            <input
              className="w-full p-3 text-richEbony rounded-lg border border-brandGold focus:ring focus:ring-brandGold transition"
              value={country}
              onChange={(e) => setCountry(e.target.value)}
              placeholder="Entrez le pays"
            />
          </div>
        </div>
      )}

      {/* ─────────────────────────────────────────────────
          Payment Method
      ───────────────────────────────────────────────── */}
      <div className="mb-6">
        <label className="block text-lg font-semibold text-richEbony mb-2">
          Mode de Paiement
        </label>
        <div className="flex gap-4">
          <button
            className={`px-6 py-3 rounded-full transition duration-300 ${
              paymentMethod === "CMI"
                ? "bg-brandGold text-richEbony"
                : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
            }`}
            onClick={() => setPaymentMethod("CMI")}
          >
            Carte de Crédit (CMI)
          </button>
          <button
            className={`px-6 py-3 rounded-full transition duration-300 ${
              paymentMethod === "COD"
                ? "bg-brandGold text-richEbony"
                : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
            }`}
            onClick={() => setPaymentMethod("COD")}
          >
            Paiement à la Livraison
          </button>
        </div>
      </div>

      {error && <p className="text-burgundy text-lg mb-4">{error}</p>}

      <button
        onClick={handleCheckout}
        disabled={loading}
        className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full font-medium transition w-full duration-300"
      >
        {loading ? "Traitement..." : "Confirmer & Payer"}
      </button>
    </main>
  );
}

/* --------------------------------------------------------------------
   ✅ getServerSideProps: Manually parse token, fetch user’s address
-------------------------------------------------------------------- */
export const getServerSideProps: GetServerSideProps = async (context) => {
  // 1) Parse token from cookies
  const rawCookie = context.req.headers.cookie || "";
  let match = rawCookie.match(/next-auth\.session-token=([^;]+)/);
  if (!match) {
    match = rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) {
      console.log("❌ No session token found. Redirecting to login.");
      return {
        redirect: {
          destination: "/login",
          permanent: false,
        },
      };
    }
  }
  const tokenStr = decodeURIComponent(match[1]);

  // 2) Verify token with jose
  let userId: number | null = null;
  try {
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );

    console.log("✅ Token decoded:", decoded);
    if (typeof decoded !== "object" || !decoded.id) {
      throw new Error("Invalid token payload structure.");
    }
    userId = Number(decoded.id);
  } catch (err) {
    console.error("❌ Token verification failed:", err);
    return {
      redirect: {
        destination: "/login",
        permanent: false,
      },
    };
  }

  // 3) Fetch user’s address fields if we have a valid userId
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        address: true,
        city: true,
        postalCode: true,
        country: true,
      },
    });

    return {
      props: {
        userId,
        userAddress: user?.address || "",
        userCity: user?.city || "",
        userPostalCode: user?.postalCode || "",
        userCountry: user?.country || "",
      },
    };
  } catch (err) {
    console.error("❌ Error fetching user address:", err);
    // If something goes wrong, user can still checkout with "NEW" or "STORE" options
    return {
      props: {
        userId,
        userAddress: "",
        userCity: "",
        userPostalCode: "",
        userCountry: "",
      },
    };
  }
};

How It Works

    Three Shipping Options – We store the user’s choice in shippingOption:
        STORE – In-store pickup, sets a predefined store address/city/zip/country.
        PROFILE – Use the user’s existing address from the DB (fetched in SSR).
        NEW – Provide blank fields for a new address input.

    SSR with Manual Cookie Parsing
        We read next-auth.session-token or __Secure-next-auth.session-token from the cookies.
        Verify it using jose. If invalid or missing, redirect to login.
        If valid, fetch the user’s address from the DB (address, city, postalCode, country) and pass them to the page.

    Auto-Fill Behavior in the useEffect
        If shippingOption === "STORE", we set the store’s address.
        If shippingOption === "PROFILE", we load the user’s address from props.
        If shippingOption === "NEW", we clear the fields to allow manual input.

    handleCheckout
        We confirm a paymentMethod is selected.
        We confirm a shippingOption is selected.
        If the shipping is “NEW,” we ensure the user typed a complete address.
        We then POST to either /api/payment/cmi (for card payment) or /api/order/place-order (COD).
        If the order is placed successfully, we clearCart and show a thank-you message.

    UI
        For the store pickup, we simply show a radio button labeled “Retrait en Boutique (Casablanca)”.
        For the user’s profile address, we show a radio button with the user’s DB address appended in parentheses. If the user has no saved address, we show “(Aucune adresse enregistrée).”
        For entering a brand-new address, we reveal the address fields.

This design ensures users can choose how to receive their Diamant Rouge order: in-store pickup, shipping to their on-file address, or shipping to a brand-new address.
You said:
Let's move now reworking optimizing  the admin dashboard , first i wont the admin from the index dashboard get to access different management pages from the same page just as a toggles : "// pages/admin/index.tsx
import Link from "next/link";
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";

export default function AdminDashboard() {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-4">Admin Dashboard</h1>
            <p className="text-platinumGray">
                Welcome to the Diamant-Rouge back office.
            </p>

            <ul className="mt-4 list-disc list-inside text-richEbony space-y-2">
                <li>
                    <Link
                        href="/admin/products"
                        className="text-burgundy hover:text-brandGold transition"
                    >
                        Manage Products
                    </Link>
                </li>
                <li>
                    <Link
                        href="/admin/categories"
                        className="text-burgundy hover:text-brandGold transition"
                    >
                        Manage Categories
                    </Link>
                </li>
                <li>
                    <Link
                        href="/admin/orders"
                        className="text-burgundy hover:text-brandGold transition"
                    >
                        View Orders
                    </Link>
                </li>
            </ul>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: {
                destination: "/",
                permanent: false,
            },
        };
    }
    return { props: {} };
};
"

Below is an updated AdminDashboard page that consolidates product, category, and order management into a single view using client-side toggles (tabs or buttons). Instead of navigating to separate routes (/admin/products, etc.), the admin can switch sections on the same page. This approach creates a unified admin experience.

You can still keep your existing pages (/admin/products, /admin/categories, /admin/orders) if needed, but the snippet below shows how you might embed or replicate their functionality in one component. For brevity, we’ll create dummy placeholders for “ManageProducts,” “ManageCategories,” and “ViewOrders,” but you can inline or import your actual components/pages.

// pages/admin/index.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { useState } from "react";

// Example placeholders for your sub-sections
function ManageProducts() {
  return (
    <div className="p-4">
      <h2 className="text-2xl font-serif text-brandGold mb-3">Gérer les Produits</h2>
      <p className="text-platinumGray">
        (Liste, création, édition, suppression de produits, etc.)
      </p>
      {/* Replace with your actual product management UI */}
    </div>
  );
}

function ManageCategories() {
  return (
    <div className="p-4">
      <h2 className="text-2xl font-serif text-brandGold mb-3">Gérer les Catégories</h2>
      <p className="text-platinumGray">
        (Liste, création, édition, suppression de catégories, etc.)
      </p>
      {/* Replace with your actual category management UI */}
    </div>
  );
}

function ViewOrders() {
  return (
    <div className="p-4">
      <h2 className="text-2xl font-serif text-brandGold mb-3">Voir les Commandes</h2>
      <p className="text-platinumGray">
        (Liste des commandes, suivi du statut, etc.)
      </p>
      {/* Replace with your actual orders UI */}
    </div>
  );
}

export default function AdminDashboard() {
  // Manage which tab is currently active
  const [activeTab, setActiveTab] = useState<"products" | "categories" | "orders">("products");

  return (
    <section className="section-light min-h-screen p-8">
      <h1 className="text-3xl font-serif text-brandGold mb-6">Admin Dashboard</h1>
      <p className="text-platinumGray mb-8">
        Bienvenue sur la plateforme d'administration Diamant-Rouge.
      </p>

      {/* Tab Navigation Buttons */}
      <div className="flex gap-4 mb-6">
        <button
          onClick={() => setActiveTab("products")}
          className={`px-6 py-2 rounded-full font-medium transition
            ${activeTab === "products"
              ? "bg-brandGold text-richEbony"
              : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
            }
          `}
        >
          Produits
        </button>
        <button
          onClick={() => setActiveTab("categories")}
          className={`px-6 py-2 rounded-full font-medium transition
            ${activeTab === "categories"
              ? "bg-brandGold text-richEbony"
              : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
            }
          `}
        >
          Catégories
        </button>
        <button
          onClick={() => setActiveTab("orders")}
          className={`px-6 py-2 rounded-full font-medium transition
            ${activeTab === "orders"
              ? "bg-brandGold text-richEbony"
              : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
            }
          `}
        >
          Commandes
        </button>
      </div>

      {/* Conditional Rendering of Each Section */}
      {activeTab === "products" && <ManageProducts />}
      {activeTab === "categories" && <ManageCategories />}
      {activeTab === "orders" && <ViewOrders />}
    </section>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const session = await getSession(context);
  if (!session || session.user.role !== "admin") {
    return {
      redirect: {
        destination: "/",
        permanent: false,
      },
    };
  }
  return { props: {} };
};

How It Works

    Local State for Active Tab
        A useState hook (activeTab) tracks which admin section is visible: "products", "categories", or "orders".

    Tab Navigation
        Three buttons let the admin switch the active tab.
        We style the active button differently (gold background) from the inactive ones (burgundy/20).

    Conditional Rendering
        Depending on activeTab, we display <ManageProducts />, <ManageCategories />, or <ViewOrders />.

    Placeholder Components
        Replace ManageProducts, ManageCategories, and ViewOrders with your actual pages or components for each admin function.
        For large code, you can import them from separate files. E.g.:

        import ManageProducts from "../../components/admin/ManageProducts";

        This keeps your code organized.

    Session & Role Check
        We still check session.user.role === "admin" in getServerSideProps. If not, redirect the user away.

This design merges the three admin management pages into one dashboard with toggleable sections. It gives your admin a quick overview and easy navigation without jumping across separate routes.
You said:
Now the different management systems are pages , should we change them into compoenents or keep them pages and display them under each respective toggle : "import { useState, useEffect } from "react";

export default function ManageCategories() {
    const [categories, setCategories] = useState([]);
    const [newCategorySlug, setNewCategorySlug] = useState("");
    const [translations, setTranslations] = useState([
        { language: "en", name: "", description: "" },
    ]);
    const [error, setError] = useState("");
    const [editingCategory, setEditingCategory] = useState(null);

    useEffect(() => {
        fetchCategories();
    }, []);

    const fetchCategories = async () => {
        const res = await fetch("/api/admin/categories");
        const data = await res.json();
        setCategories(data);
    };

    const handleTranslationChange = (index, key, value) => {
        const updatedTranslations = [...translations];
        updatedTranslations[index][key] = value;
        setTranslations(updatedTranslations);
    };

    // ✅ Handle Category Creation
    const handleCreateCategory = async () => {
        if (!newCategorySlug.trim()) return setError("Category slug is required.");
        setError("");

        const res = await fetch("/api/admin/categories", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ slug: newCategorySlug, translations }),
        });

        if (!res.ok) {
            setError("Failed to create category.");
            return;
        }

        setNewCategorySlug("");
        setTranslations([{ language: "en", name: "", description: "" }]);
        fetchCategories();
    };

    // ✅ Handle Category Editing
    const handleEditCategory = async () => {
        if (!editingCategory) return;
        setError("");

        const res = await fetch(/api/admin/categories/${editingCategory.id}, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                slug: editingCategory.slug,
                translations: editingCategory.translations,
            }),
        });

        if (!res.ok) {
            setError("Failed to update category.");
            return;
        }

        setEditingCategory(null);
        fetchCategories();
    };

    // ✅ Handle Category Deletion
    const handleDeleteCategory = async (id) => {
        if (!window.confirm("Are you sure you want to delete this category?")) return;

        const res = await fetch(/api/admin/categories/${id}, { method: "DELETE" });

        if (!res.ok) {
            setError("Failed to delete category.");
            return;
        }

        fetchCategories();
    };

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-4">
                Manage Categories
            </h1>

            {/* Category Creation */}
            <div className="mb-6">
                <input
                    type="text"
                    placeholder="Category Slug (e.g., rings, bracelets)"
                    value={newCategorySlug}
                    onChange={(e) => setNewCategorySlug(e.target.value)}
                    className="input-field mr-2 w-full max-w-sm"
                />

                {translations.map((t, index) => (
                    <div key={index} className="mt-3 space-y-2">
                        <input
                            type="text"
                            placeholder={Category Name (${t.language})}
                            value={t.name}
                            onChange={(e) =>
                                handleTranslationChange(index, "name", e.target.value)
                            }
                            className="input-field w-full max-w-sm"
                        />
                        <input
                            type="text"
                            placeholder={Description (${t.language})}
                            value={t.description}
                            onChange={(e) =>
                                handleTranslationChange(index, "description", e.target.value)
                            }
                            className="input-field w-full max-w-sm"
                        />
                    </div>
                ))}

                <button
                    onClick={handleCreateCategory}
                    className="button-primary mt-4"
                >
                    Create Category
                </button>
                {error && <p className="text-burgundy mt-2">{error}</p>}
            </div>

            {/* Category List */}
            <ul className="mt-4 list-disc list-inside space-y-4">
                {categories.map((category) => {
                    const translation =
                        category.translations.find((t) => t.language === "en") || {};

                    return (
                        <li
                            key={category.id}
                            className="flex flex-col md:flex-row md:items-center justify-between bg-burgundy/10 p-4 rounded-md"
                        >
                            <div className="text-richEbony">
                                <strong>{translation.name || category.slug}</strong> -{" "}
                                {translation.description || "No description available"}
                            </div>
                            <div className="flex gap-3 mt-2 md:mt-0">
                                <button
                                    onClick={() => setEditingCategory(category)}
                                    className="bg-brandGold text-richEbony px-3 py-1 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300"
                                >
                                    Edit
                                </button>
                                <button
                                    onClick={() => handleDeleteCategory(category.id)}
                                    className="bg-burgundy text-brandIvory px-3 py-1 rounded-full hover:bg-brandGold hover:text-richEbony transition duration-300"
                                >
                                    Delete
                                </button>
                            </div>
                        </li>
                    );
                })}
            </ul>

            {/* Edit Form */}
            {editingCategory && (
                <div className="mt-6 p-4 bg-burgundy/10 rounded-md">
                    <h2 className="text-xl font-serif text-brandGold mb-3">
                        Edit Category
                    </h2>
                    <input
                        type="text"
                        placeholder="Category Slug"
                        value={editingCategory.slug}
                        onChange={(e) =>
                            setEditingCategory({ ...editingCategory, slug: e.target.value })
                        }
                        className="input-field w-full max-w-sm mb-3"
                    />
                    {editingCategory.translations.map((t, index) => (
                        <div key={index} className="mt-4 space-y-2">
                            <input
                                type="text"
                                placeholder={Category Name (${t.language})}
                                value={t.name}
                                onChange={(e) => {
                                    const updatedTranslations = [...editingCategory.translations];
                                    updatedTranslations[index].name = e.target.value;
                                    setEditingCategory({
                                        ...editingCategory,
                                        translations: updatedTranslations,
                                    });
                                }}
                                className="input-field w-full max-w-sm"
                            />
                            <input
                                type="text"
                                placeholder={Description (${t.language})}
                                value={t.description}
                                onChange={(e) => {
                                    const updatedTranslations = [...editingCategory.translations];
                                    updatedTranslations[index].description = e.target.value;
                                    setEditingCategory({
                                        ...editingCategory,
                                        translations: updatedTranslations,
                                    });
                                }}
                                className="input-field w-full max-w-sm"
                            />
                        </div>
                    ))}
                    <button
                        onClick={handleEditCategory}
                        className="button-primary mt-4"
                    >
                        Update Category
                    </button>
                    {error && <p className="text-burgundy mt-2">{error}</p>}
                </div>
            )}
        </section>
    );
}
"  "// pages/admin/products/index.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";

type AdminProduct = {
    id: number;
    sku: string;
    basePrice: string;
    translations: {
        language: string;
        name: string;
    }[];
};

type ProductsAdminProps = {
    products: AdminProduct[];
};

export default function ProductsAdminPage({ products }: ProductsAdminProps) {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Manage Products
            </h1>

            <a
                href="/admin/products/create"
                className="button-primary inline-block mb-6"
            >
                + Add New Product
            </a>

            <table className="w-full bg-burgundy/10 text-richEbony shadow-luxury rounded-lg overflow-hidden">
                <thead className="bg-burgundy/20">
                <tr>
                    <th className="p-3 text-left">ID</th>
                    <th className="p-3 text-left">SKU</th>
                    <th className="p-3 text-left">Name (EN)</th>
                    <th className="p-3">Price</th>
                    <th className="p-3">Actions</th>
                </tr>
                </thead>
                <tbody>
                {products.map((prod) => {
                    const enTranslation = prod.translations.find(
                        (t) => t.language === "en"
                    );
                    return (
                        <tr
                            key={prod.id}
                            className="border-b border-platinumGray/30 hover:bg-burgundy/10"
                        >
                            <td className="p-3">{prod.id}</td>
                            <td className="p-3">{prod.sku}</td>
                            <td className="p-3">{enTranslation?.name}</td>
                            <td className="p-3">€{prod.basePrice}</td>
                            <td className="p-3 text-center">
                                <a
                                    href={/admin/products/${prod.id}/edit}
                                    className="text-burgundy hover:text-brandGold mr-3"
                                >
                                    Edit
                                </a>
                                <a
                                    href={/admin/products/${prod.id}/delete}
                                    className="text-burgundy hover:text-brandGold"
                                >
                                    Delete
                                </a>
                            </td>
                        </tr>
                    );
                })}
                </tbody>
            </table>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: { destination: "/", permanent: false },
        };
    }

    const rawProducts = await prisma.product.findMany({
        include: {
            translations: true,
        },
        orderBy: { id: "asc" },
    });

    // Convert Date objects to strings
    const products = JSON.parse(JSON.stringify(rawProducts));

    return {
        props: {
            products,
        },
    };
};
"  "// pages/admin/products/create.tsx

import { useState, useEffect } from "react";
import { useRouter } from "next/router";

export default function CreateProduct() {
    const router = useRouter();

    // ✅ State Management
    const [categories, setCategories] = useState<any[]>([]);
    const [formData, setFormData] = useState({
        sku: "",
        basePrice: "",
        categoryId: "",
        translations: [{ language: "en", name: "", description: "" }],
        variations: [],
        images: [],
    });

    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    // ✅ Fetch Categories on Load
    useEffect(() => {
        fetch("/api/admin/categories")
            .then((res) => res.json())
            .then((data) => setCategories(data))
            .catch(() => setError("Failed to load categories"));
    }, []);

    // ✅ Handle Input Changes
    const handleInputChange = (e: any) => {
        const { name, value } = e.target;
        setFormData((prev) => ({ ...prev, [name]: value }));
    };

    const handleTranslationChange = (index: number, key: string, value: string) => {
        setFormData((prev) => ({
            ...prev,
            translations: prev.translations.map((t, i) =>
                i === index ? { ...t, [key]: value } : t
            ),
        }));
    };

    const addVariation = () => {
        setFormData((prev) => ({
            ...prev,
            variations: [
                ...prev.variations,
                { variationType: "", variationValue: "", additionalPrice: 0 },
            ],
        }));
    };

    const handleVariationChange = (
        index: number,
        key: string,
        value: string | number
    ) => {
        setFormData((prev) => ({
            ...prev,
            variations: prev.variations.map((v, i) =>
                i === index ? { ...v, [key]: value } : v
            ),
        }));
    };

    // ✅ Handle Image Upload
    const handleImageUpload = async (e: any) => {
        const file = e.target.files[0];
        if (!file) return setError("No file selected.");

        const imageForm = new FormData();
        imageForm.append("file", file);

        try {
            const response = await fetch("/api/upload-image", {
                method: "POST",
                body: imageForm,
            });
            const data = await response.json();

            if (response.ok) {
                setFormData((prev) => ({
                    ...prev,
                    images: [...prev.images, data.imageUrl],
                }));
            } else {
                setError(data.error || "Image upload failed.");
            }
        } catch {
            setError("An error occurred while uploading the image.");
        }
    };

    // ✅ Remove Image from List
    const handleRemoveImage = (index: number) => {
        setFormData((prev) => ({
            ...prev,
            images: prev.images.filter((_, i) => i !== index),
        }));
    };

    // ✅ Handle Form Submission
    const handleSubmit = async () => {
        setLoading(true);
        setError("");

        if (!formData.sku || !formData.basePrice || !formData.categoryId) {
            setLoading(false);
            return setError("SKU, Base Price, and Category are required.");
        }

        try {
            const resSession = await fetch("/api/auth/session");
            const sessionData = await resSession.json();
            if (!sessionData || !sessionData.user) {
                throw new Error("Unauthorized: Admin session not found");
            }

            const res = await fetch("/api/admin/products", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: Bearer ${sessionData.user.token},
                },
                body: JSON.stringify(formData),
            });

            if (!res.ok) throw new Error("Failed to create product");

            router.push("/admin/products");
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main className="section-light min-h-screen p-6 max-w-2xl mx-auto">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Create Product
            </h1>

            {/* SKU & Price */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">SKU</label>
                <input
                    name="sku"
                    value={formData.sku}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Base Price (€)</label>
                <input
                    name="basePrice"
                    type="number"
                    value={formData.basePrice}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>

            {/* Category Selection */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Category</label>
                <select
                    name="categoryId"
                    value={formData.categoryId}
                    onChange={handleInputChange}
                    className="input-field w-full"
                >
                    <option value="">Select Category</option>
                    {categories.map((cat) => (
                        <option key={cat.id} value={cat.id}>
                            {cat.translations.find((t: any) => t.language === "en")?.name ||
                                cat.slug}
                        </option>
                    ))}
                </select>
            </div>

            {/* Translations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Translations</h3>
            {formData.translations.map((t, index) => (
                <div key={index} className="mb-4">
                    <label className="block font-medium text-richEbony">
                        Language ({t.language})
                    </label>
                    <input
                        value={t.name}
                        onChange={(e) =>
                            handleTranslationChange(index, "name", e.target.value)
                        }
                        className="input-field w-full"
                        placeholder="Product Name"
                    />
                    <textarea
                        value={t.description}
                        onChange={(e) =>
                            handleTranslationChange(index, "description", e.target.value)
                        }
                        className="input-field w-full mt-2"
                        placeholder="Description"
                    />
                </div>
            ))}

            {/* Variations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Variations</h3>
            {formData.variations.map((v, index) => (
                <div key={index} className="mb-4 flex flex-col md:flex-row gap-2">
                    <input
                        value={v.variationType}
                        onChange={(e) =>
                            handleVariationChange(index, "variationType", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Type (e.g., Size)"
                    />
                    <input
                        value={v.variationValue}
                        onChange={(e) =>
                            handleVariationChange(index, "variationValue", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Value (e.g., 5)"
                    />
                    <input
                        type="number"
                        value={v.additionalPrice}
                        onChange={(e) =>
                            handleVariationChange(index, "additionalPrice", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Extra Cost"
                    />
                </div>
            ))}
            <button onClick={addVariation} className="button-secondary">
                + Add Variation
            </button>

            {/* Image Upload */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Images</h3>
            <input type="file" onChange={handleImageUpload} className="input-field w-full" />

            {/* Image Preview with Remove Button */}
            <div className="flex gap-2 mt-3">
                {formData.images.map((url, index) => (
                    <div key={index} className="relative">
                        <img
                            src={url}
                            alt="Uploaded"
                            className="w-16 h-16 object-cover rounded-md"
                        />
                        <button
                            onClick={() => handleRemoveImage(index)}
                            className="absolute top-0 right-0 bg-burgundy text-brandIvory rounded-full w-6 h-6 flex items-center justify-center hover:bg-brandGold hover:text-richEbony transition"
                        >
                            ✕
                        </button>
                    </div>
                ))}
            </div>

            {error && <p className="text-burgundy mt-4">{error}</p>}

            <button
                onClick={handleSubmit}
                disabled={loading}
                className="button-primary mt-6"
            >
                {loading ? "Creating..." : "Create Product"}
            </button>
        </main>
    );
}
" "// pages/admin/products/[id]/delete.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../../lib/prisma";
import { useRouter } from "next/router";

export default function DeleteProductPage({ product }: { product: any }) {
    const router = useRouter();

    async function handleDelete() {
        const res = await fetch(/api/admin/products/${product.id}, {
            method: "DELETE",
        });

        if (res.ok) {
            router.push("/admin/products");
        }
    }

    return (
        <main className="section-light min-h-screen p-6 flex flex-col items-center justify-center">
            <h1 className="text-3xl font-serif text-burgundy mb-4">
                Confirm Deletion
            </h1>
            <p className="text-platinumGray mb-6 text-center max-w-md">
                Are you sure you want to delete{" "}
                <strong>
                    {product.translations.find((t: any) => t.language === "en")?.name ||
                        "this product"}
                </strong>
                ?
            </p>

            <div className="flex gap-6">
                <button
                    onClick={handleDelete}
                    className="button-primary text-center"
                >
                    Delete
                </button>
                <button
                    onClick={() => router.push("/admin/products")}
                    className="button-secondary"
                >
                    Cancel
                </button>
            </div>
        </main>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const { id } = context.params!;
    const rawProduct = await prisma.product.findUnique({
        where: { id: Number(id) },
        include: { translations: true },
    });

    if (!rawProduct) {
        return { notFound: true };
    }

    const product = JSON.parse(JSON.stringify(rawProduct));
    return { props: { product } };
};
"  "// pages/admin/products/[id]/edit.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../../lib/prisma";
import { useState } from "react";
import { useRouter } from "next/router";

export default function EditProductPage({
                                            product,
                                            categories,
                                        }: {
    product: any;
    categories: any[];
}) {
    const router = useRouter();
    const [formData, setFormData] = useState({
        sku: product.sku,
        basePrice: product.basePrice.toString(),
        categoryId: product.categoryId || "",
        translations: product.translations || [],
        images: product.images || [],
    });

    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    const handleInputChange = (e: any) => {
        const { name, value } = e.target;
        setFormData((prev) => ({ ...prev, [name]: value }));
    };

    const handleTranslationChange = (
        index: number,
        key: string,
        value: string
    ) => {
        const updatedTranslations = [...formData.translations];
        updatedTranslations[index][key] = value;
        setFormData((prev) => ({ ...prev, translations: updatedTranslations }));
    };

    const handleImageUpload = async (e: any) => {
        const file = e.target.files[0];
        if (!file) {
            setError("No file selected");
            return;
        }

        const imageForm = new FormData();
        imageForm.append("file", file);

        try {
            const response = await fetch("/api/upload-image", {
                method: "POST",
                body: imageForm,
            });

            const data = await response.json();

            if (response.ok) {
                setFormData((prev) => ({
                    ...prev,
                    images: [...prev.images, data.imageUrl],
                }));
            } else {
                setError(data.error || "Image upload failed");
            }
        } catch (err) {
            setError("An error occurred while uploading the image.");
        }
    };

    const handleRemoveImage = (index: number) => {
        setFormData((prev) => ({
            ...prev,
            images: prev.images.filter((_, i) => i !== index),
        }));
    };

    const handleSubmit = async () => {
        setLoading(true);
        setError("");

        try {
            const res = await fetch(/api/admin/products/${product.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(formData),
            });

            if (!res.ok) {
                throw new Error("Failed to update product");
            }

            router.push("/admin/products");
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main className="section-light min-h-screen p-6 max-w-2xl mx-auto">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Edit Product
            </h1>

            {/* SKU & Price */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">SKU</label>
                <input
                    name="sku"
                    value={formData.sku}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>
            <div className="mb-4">
                <label className="block font-medium text-richEbony">
                    Base Price (€)
                </label>
                <input
                    name="basePrice"
                    type="number"
                    value={formData.basePrice}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>

            {/* Category Selection */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Category</label>
                <select
                    name="categoryId"
                    value={formData.categoryId}
                    onChange={handleInputChange}
                    className="input-field w-full"
                >
                    <option value="">Select a category</option>
                    {categories.map((category: any) => (
                        <option key={category.id} value={category.id}>
                            {category.translations.find((t: any) => t.language === "en")
                                ?.name || category.slug}
                        </option>
                    ))}
                </select>
            </div>

            {/* Translations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Translations</h3>
            {formData.translations.map((t: any, index: number) => (
                <div key={index} className="mb-4">
                    <label className="block font-medium text-richEbony">
                        Language ({t.language})
                    </label>
                    <input
                        value={t.name}
                        onChange={(e) =>
                            handleTranslationChange(index, "name", e.target.value)
                        }
                        className="input-field w-full"
                        placeholder="Product Name"
                    />
                    <textarea
                        value={t.description}
                        onChange={(e) =>
                            handleTranslationChange(index, "description", e.target.value)
                        }
                        className="input-field w-full mt-2"
                        placeholder="Description"
                    />
                </div>
            ))}

            {/* Image Upload */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Product Images</h3>
            <input
                type="file"
                onChange={handleImageUpload}
                className="input-field w-full"
            />

            {/* Image Preview with Remove Button */}
            <div className="flex gap-2 mt-3">
                {formData.images.map((url: string, index: number) => (
                    <div key={index} className="relative">
                        <img
                            src={url}
                            alt="Uploaded"
                            className="w-16 h-16 object-cover rounded-md"
                        />
                        <button
                            onClick={() => handleRemoveImage(index)}
                            className="absolute top-0 right-0 bg-burgundy text-brandIvory rounded-full w-6 h-6 flex items-center justify-center hover:bg-brandGold hover:text-richEbony transition"
                        >
                            ✕
                        </button>
                    </div>
                ))}
            </div>

            {error && <p className="text-burgundy mt-4">{error}</p>}

            <button
                onClick={handleSubmit}
                disabled={loading}
                className="button-primary mt-6"
            >
                {loading ? "Updating..." : "Update Product"}
            </button>
        </main>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const { id } = context.params!;
    const rawProduct = await prisma.product.findUnique({
        where: { id: Number(id) },
        include: { translations: true },
    });

    const rawCategories = await prisma.category.findMany({
        include: { translations: true },
    });

    if (!rawProduct) {
        return { notFound: true };
    }

    // Convert date fields
    const product = JSON.parse(JSON.stringify(rawProduct));
    const categories = rawCategories.map((cat) => ({
        ...cat,
        createdAt: cat.createdAt.toISOString(),
        updatedAt: cat.updatedAt.toISOString(),
    }));

    return { props: { product, categories } };
};
"  "// pages/admin/orders/index.tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import Link from "next/link";

type AdminOrder = {
    id: number;
    status: string;
    totalAmount: string;
    createdAt: string;
    user: {
        email: string;
    } | null;
};

export default function OrdersAdminPage({ orders }: { orders: AdminOrder[] }) {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Orders</h1>

            {orders.length === 0 ? (
                <p className="text-platinumGray">No orders found.</p>
            ) : (
                <div className="overflow-x-auto">
                    <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
                        <thead className="bg-burgundy/20 text-brandGold">
                        <tr>
                            <th className="p-3 text-left">ID</th>
                            <th className="p-3 text-left">User</th>
                            <th className="p-3">Status</th>
                            <th className="p-3">Total (€)</th>
                            <th className="p-3">Created</th>
                            <th className="p-3">Actions</th>
                        </tr>
                        </thead>
                        <tbody>
                        {orders.map((order) => (
                            <tr
                                key={order.id}
                                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
                            >
                                <td className="p-3">{order.id}</td>
                                <td className="p-3">{order.user?.email ?? "Guest"}</td>
                                <td className="p-3 text-center">{order.status}</td>
                                <td className="p-3 text-center">€{order.totalAmount}</td>
                                <td className="p-3">
                                    {new Date(order.createdAt).toLocaleString()}
                                </td>
                                <td className="p-3 text-center">
                                    <Link href={/admin/orders/${order.id}} className="button-secondary">
                                        View / Edit
                                    </Link>
                                </td>
                            </tr>
                        ))}
                        </tbody>
                    </table>
                </div>
            )}
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: { destination: "/", permanent: false },
        };
    }

    const rawOrders = await prisma.order.findMany({
        include: { user: true },
        orderBy: { createdAt: "desc" },
    });

    return {
        props: { orders: JSON.parse(JSON.stringify(rawOrders)) },
    };
};
"  "// pages/admin/orders/[id].tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import { useState } from "react";

type OrderEditProps = {
    orderData: any;
};

export default function OrderEditPage({ orderData }: OrderEditProps) {
    const [orderStatus, setOrderStatus] = useState(orderData.status);
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState("");

    async function handleStatusUpdate() {
        setLoading(true);
        setMessage("");

        try {
            const res = await fetch(/api/admin/orders/${orderData.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ status: orderStatus }),
            });

            const data = await res.json();
            if (!res.ok) {
                setMessage(data.error || "Failed to update order");
            } else {
                setMessage("Order updated successfully");
            }
        } catch (error) {
            setMessage("Error updating order");
        } finally {
            setLoading(false);
        }
    }

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">
                Editing Order #{orderData.id}
            </h1>
            {message && <p className="text-burgundy mb-4 font-semibold">{message}</p>}

            {/* Order Info */}
            <div className="bg-burgundy/10 p-6 rounded-lg shadow-luxury space-y-3">
                <p>
                    <strong>User:</strong> {orderData.user?.email || "Guest"}
                </p>
                <p>
                    <strong>Created At:</strong>{" "}
                    {new Date(orderData.createdAt).toLocaleString()}
                </p>
                <p>
                    <strong>Address:</strong> {orderData.shippingAddress}, {orderData.city}{" "}
                    {orderData.postalCode}, {orderData.country}
                </p>
                <p>
                    <strong>Total:</strong> €{orderData.totalAmount}
                </p>

                {/* Update Status */}
                <div className="mt-4">
                    <label className="block text-lg font-medium text-richEbony mb-2">
                        Update Status
                    </label>
                    <select
                        className="input-field w-full max-w-sm"
                        value={orderStatus}
                        onChange={(e) => setOrderStatus(e.target.value)}
                        disabled={loading}
                    >
                        <option value="PENDING">Pending</option>
                        <option value="CONFIRMED">Confirmed</option>
                        <option value="SHIPPED">Shipped</option>
                        <option value="DELIVERED">Delivered</option>
                        <option value="CANCELLED">Cancelled</option>
                    </select>
                </div>

                <button
                    onClick={handleStatusUpdate}
                    className="button-primary w-full md:w-auto mt-4"
                    disabled={loading}
                >
                    {loading ? "Updating..." : "Update Status"}
                </button>
            </div>

            {/* Order Items */}
            <h2 className="text-3xl font-serif text-brandGold mt-8 mb-4">
                Order Items
            </h2>
            <ul className="space-y-4">
                {orderData.orderItems.map((item: any) => {
                    const productName =
                        item.product.translations.find((t: any) => t.language === "en")
                            ?.name || "Unnamed Product";

                    return (
                        <li
                            key={item.id}
                            className="bg-burgundy/10 p-4 rounded-md shadow-subtle"
                        >
                            <p>
                                <strong>{productName}</strong>
                            </p>
                            <p>SKU: {item.product.sku}</p>
                            <p>Quantity: {item.quantity}</p>
                            <p>Price: €{parseFloat(item.price).toFixed(2)}</p>
                        </li>
                    );
                })}
            </ul>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const { id } = context.params!;
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const rawOrder = await prisma.order.findUnique({
        where: { id: Number(id) },
        include: {
            user: true,
            orderItems: {
                include: {
                    product: {
                        include: { translations: true },
                    },
                },
            },
        },
    });

    if (!rawOrder) {
        return { notFound: true };
    }

    return {
        props: { orderData: JSON.parse(JSON.stringify(rawOrder)) },
    };
};
"
Reasoned for a couple of seconds

Below is an overview of two main approaches for your admin sections—pages vs. components—including pros and cons. Then we provide a short snippet demonstrating how to convert your existing pages into components that can be conditionally shown in a single Admin Dashboard view.
1) Keeping Them as Pages
How It Works

    You have separate URLs like:
        /admin/products for product management
        /admin/categories for category management
        /admin/orders for orders
    The admin accesses these pages via links or a tab system that navigates between them.

Pros

    Direct Routes: Your admin can bookmark or share direct links to specific sections.
    SRR/SEO: Each page can use server-side data fetching (getServerSideProps) easily to load data before rendering.
    Simplicity: Each page is logically separated, making it easy to develop or replace independently.

Cons

    Multiple Full-Page Loads: If your user navigates from /admin/products to /admin/categories, the entire page reloads.
    Split UI: Harder to integrate a single dashboard experience with multiple sections toggled in the same view.

2) Turning Them into Components for a Single Dashboard
How It Works

    You create React components (e.g., <ManageProducts />, <ManageCategories />, <ManageOrders />) instead of separate pages.
    A single page (e.g. /admin/index.tsx) conditionally renders them based on user toggles (tabs or buttons).

Pros

    Single UI: The admin sees all tools in one place—toggling sections without a full reload.
    Faster Navigation: Because you’re just switching components rather than navigating to separate routes.
    Unified Experience: Great if you want an “all-in-one” dashboard feel.

Cons

    Shared Data Fetching: You need to handle data fetching manually or with client-side calls. SSR can be more complex if each sub-section needs different queries.
    Loss of Direct URLs: The user can’t directly link to “/admin/products” if it’s purely a component inside “/admin.” You’d need a custom approach to map URLs to tabs.
    Bigger Single Page: Potentially more initial load time if you do everything on one page.

Which Approach to Choose?

    If your admin frequently shares direct links or wants full SSR per section, pages may be more suitable.
    If you want a consolidated “all-in-one” UX that’s fast and feels like an app, you can transform these pages into components and embed them within the new “tabbed” admin approach.

Often teams combine these approaches:

    Provide a single dashboard page for quick toggling.
    Keep individual routes for deeper pages (like /admin/products/[id] editing).
    Or create a system that changes the hash or query param to define which sub-tab is active, so you can still share direct URLs like /admin?tab=products.

Converting Pages into Components

To convert, for example, ManageCategories from a page to a component:

    Remove all Next.js page references like getServerSideProps.
    Export a React component that handles data with client-side fetch calls or receives data as props.
    Import that component in your AdminDashboard.

Below is a short snippet showing how ManageCategories might look as a pure component:

// components/admin/ManageCategories.tsx

import { useState, useEffect } from "react";

type CategoryTranslation = {
  language: string;
  name: string;
  description: string;
};

type Category = {
  id: number;
  slug: string;
  translations: CategoryTranslation[];
};

export function ManageCategories() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [newCategorySlug, setNewCategorySlug] = useState("");
  const [translations, setTranslations] = useState<CategoryTranslation[]>([
    { language: "en", name: "", description: "" },
  ]);
  const [error, setError] = useState("");
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);

  useEffect(() => {
    fetchCategories();
  }, []);

  async function fetchCategories() {
    try {
      const res = await fetch("/api/admin/categories");
      const data = await res.json();
      setCategories(data);
    } catch (err) {
      setError("Failed to fetch categories");
    }
  }

  // ... same logic as in your page: create, edit, delete category, etc.

  return (
    <div className="p-4">
      <h2 className="text-3xl font-serif text-brandGold mb-4">
        Manage Categories
      </h2>
      {/* ... same UI code as in your page, minus SSR references */}
    </div>
  );
}

Then in your AdminDashboard:

// pages/admin/index.tsx

import { useState } from "react";
import { ManageCategories } from "../../components/admin/ManageCategories"; 
import { ManageProducts } from "../../components/admin/ManageProducts"; 
import { ManageOrders } from "../../components/admin/ManageOrders";

export default function AdminDashboard() {
  const [activeTab, setActiveTab] = useState<"products"|"categories"|"orders">("products");

  return (
    <section className="section-light min-h-screen p-8">
      {/* Tab Buttons */}
      <div className="flex gap-4 mb-6">
        <button onClick={() => setActiveTab("products")}>Produits</button>
        <button onClick={() => setActiveTab("categories")}>Catégories</button>
        <button onClick={() => setActiveTab("orders")}>Commandes</button>
      </div>

      {/* Render Sub-Components */}
      {activeTab === "products" && <ManageProducts />}
      {activeTab === "categories" && <ManageCategories />}
      {activeTab === "orders" && <ManageOrders />}
    </section>
  );
}

You’d need to handle data loading in each sub-component or pass data from the top-level via props.
Summary

    Option 1: Keep them as separate pages – You gain direct URLs, SSR convenience, but multiple route transitions.
    Option 2: Convert them into components (shown in a single page) – You get a unified admin experience with tab toggles, but you lose the straightforward route-based approach.
    A hybrid approach is common: a main dashboard that conditionally shows sub-components, plus deeper pages for more advanced or direct links.

Choose whichever aligns with your admin workflow. If quick toggling in one place is your priority, turn them into components. If direct URLs or SSR matters more, keep them as pages. You can also do a bit of both—embedding the simpler screens as components, and using dedicated pages for more complex flows.
You said:
let's go changing each one of the system management  into relevent efficient and optimized components starting with the product management system , if possible and efficeit combine all it's pages into single compoenent  :  "// pages/admin/products/index.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";

type AdminProduct = {
    id: number;
    sku: string;
    basePrice: string;
    translations: {
        language: string;
        name: string;
    }[];
};

type ProductsAdminProps = {
    products: AdminProduct[];
};

export default function ProductsAdminPage({ products }: ProductsAdminProps) {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Manage Products
            </h1>

            <a
                href="/admin/products/create"
                className="button-primary inline-block mb-6"
            >
                + Add New Product
            </a>

            <table className="w-full bg-burgundy/10 text-richEbony shadow-luxury rounded-lg overflow-hidden">
                <thead className="bg-burgundy/20">
                <tr>
                    <th className="p-3 text-left">ID</th>
                    <th className="p-3 text-left">SKU</th>
                    <th className="p-3 text-left">Name (EN)</th>
                    <th className="p-3">Price</th>
                    <th className="p-3">Actions</th>
                </tr>
                </thead>
                <tbody>
                {products.map((prod) => {
                    const enTranslation = prod.translations.find(
                        (t) => t.language === "en"
                    );
                    return (
                        <tr
                            key={prod.id}
                            className="border-b border-platinumGray/30 hover:bg-burgundy/10"
                        >
                            <td className="p-3">{prod.id}</td>
                            <td className="p-3">{prod.sku}</td>
                            <td className="p-3">{enTranslation?.name}</td>
                            <td className="p-3">€{prod.basePrice}</td>
                            <td className="p-3 text-center">
                                <a
                                    href={/admin/products/${prod.id}/edit}
                                    className="text-burgundy hover:text-brandGold mr-3"
                                >
                                    Edit
                                </a>
                                <a
                                    href={/admin/products/${prod.id}/delete}
                                    className="text-burgundy hover:text-brandGold"
                                >
                                    Delete
                                </a>
                            </td>
                        </tr>
                    );
                })}
                </tbody>
            </table>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: { destination: "/", permanent: false },
        };
    }

    const rawProducts = await prisma.product.findMany({
        include: {
            translations: true,
        },
        orderBy: { id: "asc" },
    });

    // Convert Date objects to strings
    const products = JSON.parse(JSON.stringify(rawProducts));

    return {
        props: {
            products,
        },
    };
};
"  "// pages/admin/products/create.tsx

import { useState, useEffect } from "react";
import { useRouter } from "next/router";

export default function CreateProduct() {
    const router = useRouter();

    // ✅ State Management
    const [categories, setCategories] = useState<any[]>([]);
    const [formData, setFormData] = useState({
        sku: "",
        basePrice: "",
        categoryId: "",
        translations: [{ language: "en", name: "", description: "" }],
        variations: [],
        images: [],
    });

    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    // ✅ Fetch Categories on Load
    useEffect(() => {
        fetch("/api/admin/categories")
            .then((res) => res.json())
            .then((data) => setCategories(data))
            .catch(() => setError("Failed to load categories"));
    }, []);

    // ✅ Handle Input Changes
    const handleInputChange = (e: any) => {
        const { name, value } = e.target;
        setFormData((prev) => ({ ...prev, [name]: value }));
    };

    const handleTranslationChange = (index: number, key: string, value: string) => {
        setFormData((prev) => ({
            ...prev,
            translations: prev.translations.map((t, i) =>
                i === index ? { ...t, [key]: value } : t
            ),
        }));
    };

    const addVariation = () => {
        setFormData((prev) => ({
            ...prev,
            variations: [
                ...prev.variations,
                { variationType: "", variationValue: "", additionalPrice: 0 },
            ],
        }));
    };

    const handleVariationChange = (
        index: number,
        key: string,
        value: string | number
    ) => {
        setFormData((prev) => ({
            ...prev,
            variations: prev.variations.map((v, i) =>
                i === index ? { ...v, [key]: value } : v
            ),
        }));
    };

    // ✅ Handle Image Upload
    const handleImageUpload = async (e: any) => {
        const file = e.target.files[0];
        if (!file) return setError("No file selected.");

        const imageForm = new FormData();
        imageForm.append("file", file);

        try {
            const response = await fetch("/api/upload-image", {
                method: "POST",
                body: imageForm,
            });
            const data = await response.json();

            if (response.ok) {
                setFormData((prev) => ({
                    ...prev,
                    images: [...prev.images, data.imageUrl],
                }));
            } else {
                setError(data.error || "Image upload failed.");
            }
        } catch {
            setError("An error occurred while uploading the image.");
        }
    };

    // ✅ Remove Image from List
    const handleRemoveImage = (index: number) => {
        setFormData((prev) => ({
            ...prev,
            images: prev.images.filter((_, i) => i !== index),
        }));
    };

    // ✅ Handle Form Submission
    const handleSubmit = async () => {
        setLoading(true);
        setError("");

        if (!formData.sku || !formData.basePrice || !formData.categoryId) {
            setLoading(false);
            return setError("SKU, Base Price, and Category are required.");
        }

        try {
            const resSession = await fetch("/api/auth/session");
            const sessionData = await resSession.json();
            if (!sessionData || !sessionData.user) {
                throw new Error("Unauthorized: Admin session not found");
            }

            const res = await fetch("/api/admin/products", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: Bearer ${sessionData.user.token},
                },
                body: JSON.stringify(formData),
            });

            if (!res.ok) throw new Error("Failed to create product");

            router.push("/admin/products");
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main className="section-light min-h-screen p-6 max-w-2xl mx-auto">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Create Product
            </h1>

            {/* SKU & Price */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">SKU</label>
                <input
                    name="sku"
                    value={formData.sku}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Base Price (€)</label>
                <input
                    name="basePrice"
                    type="number"
                    value={formData.basePrice}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>

            {/* Category Selection */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Category</label>
                <select
                    name="categoryId"
                    value={formData.categoryId}
                    onChange={handleInputChange}
                    className="input-field w-full"
                >
                    <option value="">Select Category</option>
                    {categories.map((cat) => (
                        <option key={cat.id} value={cat.id}>
                            {cat.translations.find((t: any) => t.language === "en")?.name ||
                                cat.slug}
                        </option>
                    ))}
                </select>
            </div>

            {/* Translations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Translations</h3>
            {formData.translations.map((t, index) => (
                <div key={index} className="mb-4">
                    <label className="block font-medium text-richEbony">
                        Language ({t.language})
                    </label>
                    <input
                        value={t.name}
                        onChange={(e) =>
                            handleTranslationChange(index, "name", e.target.value)
                        }
                        className="input-field w-full"
                        placeholder="Product Name"
                    />
                    <textarea
                        value={t.description}
                        onChange={(e) =>
                            handleTranslationChange(index, "description", e.target.value)
                        }
                        className="input-field w-full mt-2"
                        placeholder="Description"
                    />
                </div>
            ))}

            {/* Variations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Variations</h3>
            {formData.variations.map((v, index) => (
                <div key={index} className="mb-4 flex flex-col md:flex-row gap-2">
                    <input
                        value={v.variationType}
                        onChange={(e) =>
                            handleVariationChange(index, "variationType", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Type (e.g., Size)"
                    />
                    <input
                        value={v.variationValue}
                        onChange={(e) =>
                            handleVariationChange(index, "variationValue", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Value (e.g., 5)"
                    />
                    <input
                        type="number"
                        value={v.additionalPrice}
                        onChange={(e) =>
                            handleVariationChange(index, "additionalPrice", e.target.value)
                        }
                        className="input-field md:w-1/3"
                        placeholder="Extra Cost"
                    />
                </div>
            ))}
            <button onClick={addVariation} className="button-secondary">
                + Add Variation
            </button>

            {/* Image Upload */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Images</h3>
            <input type="file" onChange={handleImageUpload} className="input-field w-full" />

            {/* Image Preview with Remove Button */}
            <div className="flex gap-2 mt-3">
                {formData.images.map((url, index) => (
                    <div key={index} className="relative">
                        <img
                            src={url}
                            alt="Uploaded"
                            className="w-16 h-16 object-cover rounded-md"
                        />
                        <button
                            onClick={() => handleRemoveImage(index)}
                            className="absolute top-0 right-0 bg-burgundy text-brandIvory rounded-full w-6 h-6 flex items-center justify-center hover:bg-brandGold hover:text-richEbony transition"
                        >
                            ✕
                        </button>
                    </div>
                ))}
            </div>

            {error && <p className="text-burgundy mt-4">{error}</p>}

            <button
                onClick={handleSubmit}
                disabled={loading}
                className="button-primary mt-6"
            >
                {loading ? "Creating..." : "Create Product"}
            </button>
        </main>
    );
}
"  "// pages/admin/products/[id]/delete.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../../lib/prisma";
import { useRouter } from "next/router";

export default function DeleteProductPage({ product }: { product: any }) {
    const router = useRouter();

    async function handleDelete() {
        const res = await fetch(/api/admin/products/${product.id}, {
            method: "DELETE",
        });

        if (res.ok) {
            router.push("/admin/products");
        }
    }

    return (
        <main className="section-light min-h-screen p-6 flex flex-col items-center justify-center">
            <h1 className="text-3xl font-serif text-burgundy mb-4">
                Confirm Deletion
            </h1>
            <p className="text-platinumGray mb-6 text-center max-w-md">
                Are you sure you want to delete{" "}
                <strong>
                    {product.translations.find((t: any) => t.language === "en")?.name ||
                        "this product"}
                </strong>
                ?
            </p>

            <div className="flex gap-6">
                <button
                    onClick={handleDelete}
                    className="button-primary text-center"
                >
                    Delete
                </button>
                <button
                    onClick={() => router.push("/admin/products")}
                    className="button-secondary"
                >
                    Cancel
                </button>
            </div>
        </main>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const { id } = context.params!;
    const rawProduct = await prisma.product.findUnique({
        where: { id: Number(id) },
        include: { translations: true },
    });

    if (!rawProduct) {
        return { notFound: true };
    }

    const product = JSON.parse(JSON.stringify(rawProduct));
    return { props: { product } };
};
"  "// pages/admin/products/[id]/edit.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../../lib/prisma";
import { useState } from "react";
import { useRouter } from "next/router";

export default function EditProductPage({
                                            product,
                                            categories,
                                        }: {
    product: any;
    categories: any[];
}) {
    const router = useRouter();
    const [formData, setFormData] = useState({
        sku: product.sku,
        basePrice: product.basePrice.toString(),
        categoryId: product.categoryId || "",
        translations: product.translations || [],
        images: product.images || [],
    });

    const [error, setError] = useState("");
    const [loading, setLoading] = useState(false);

    const handleInputChange = (e: any) => {
        const { name, value } = e.target;
        setFormData((prev) => ({ ...prev, [name]: value }));
    };

    const handleTranslationChange = (
        index: number,
        key: string,
        value: string
    ) => {
        const updatedTranslations = [...formData.translations];
        updatedTranslations[index][key] = value;
        setFormData((prev) => ({ ...prev, translations: updatedTranslations }));
    };

    const handleImageUpload = async (e: any) => {
        const file = e.target.files[0];
        if (!file) {
            setError("No file selected");
            return;
        }

        const imageForm = new FormData();
        imageForm.append("file", file);

        try {
            const response = await fetch("/api/upload-image", {
                method: "POST",
                body: imageForm,
            });

            const data = await response.json();

            if (response.ok) {
                setFormData((prev) => ({
                    ...prev,
                    images: [...prev.images, data.imageUrl],
                }));
            } else {
                setError(data.error || "Image upload failed");
            }
        } catch (err) {
            setError("An error occurred while uploading the image.");
        }
    };

    const handleRemoveImage = (index: number) => {
        setFormData((prev) => ({
            ...prev,
            images: prev.images.filter((_, i) => i !== index),
        }));
    };

    const handleSubmit = async () => {
        setLoading(true);
        setError("");

        try {
            const res = await fetch(/api/admin/products/${product.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(formData),
            });

            if (!res.ok) {
                throw new Error("Failed to update product");
            }

            router.push("/admin/products");
        } catch (err: any) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <main className="section-light min-h-screen p-6 max-w-2xl mx-auto">
            <h1 className="text-3xl font-serif text-brandGold mb-6">
                Edit Product
            </h1>

            {/* SKU & Price */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">SKU</label>
                <input
                    name="sku"
                    value={formData.sku}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>
            <div className="mb-4">
                <label className="block font-medium text-richEbony">
                    Base Price (€)
                </label>
                <input
                    name="basePrice"
                    type="number"
                    value={formData.basePrice}
                    onChange={handleInputChange}
                    className="input-field w-full"
                />
            </div>

            {/* Category Selection */}
            <div className="mb-4">
                <label className="block font-medium text-richEbony">Category</label>
                <select
                    name="categoryId"
                    value={formData.categoryId}
                    onChange={handleInputChange}
                    className="input-field w-full"
                >
                    <option value="">Select a category</option>
                    {categories.map((category: any) => (
                        <option key={category.id} value={category.id}>
                            {category.translations.find((t: any) => t.language === "en")
                                ?.name || category.slug}
                        </option>
                    ))}
                </select>
            </div>

            {/* Translations */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Translations</h3>
            {formData.translations.map((t: any, index: number) => (
                <div key={index} className="mb-4">
                    <label className="block font-medium text-richEbony">
                        Language ({t.language})
                    </label>
                    <input
                        value={t.name}
                        onChange={(e) =>
                            handleTranslationChange(index, "name", e.target.value)
                        }
                        className="input-field w-full"
                        placeholder="Product Name"
                    />
                    <textarea
                        value={t.description}
                        onChange={(e) =>
                            handleTranslationChange(index, "description", e.target.value)
                        }
                        className="input-field w-full mt-2"
                        placeholder="Description"
                    />
                </div>
            ))}

            {/* Image Upload */}
            <h3 className="text-xl text-brandGold mt-6 mb-2">Product Images</h3>
            <input
                type="file"
                onChange={handleImageUpload}
                className="input-field w-full"
            />

            {/* Image Preview with Remove Button */}
            <div className="flex gap-2 mt-3">
                {formData.images.map((url: string, index: number) => (
                    <div key={index} className="relative">
                        <img
                            src={url}
                            alt="Uploaded"
                            className="w-16 h-16 object-cover rounded-md"
                        />
                        <button
                            onClick={() => handleRemoveImage(index)}
                            className="absolute top-0 right-0 bg-burgundy text-brandIvory rounded-full w-6 h-6 flex items-center justify-center hover:bg-brandGold hover:text-richEbony transition"
                        >
                            ✕
                        </button>
                    </div>
                ))}
            </div>

            {error && <p className="text-burgundy mt-4">{error}</p>}

            <button
                onClick={handleSubmit}
                disabled={loading}
                className="button-primary mt-6"
            >
                {loading ? "Updating..." : "Update Product"}
            </button>
        </main>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const { id } = context.params!;
    const rawProduct = await prisma.product.findUnique({
        where: { id: Number(id) },
        include: { translations: true },
    });

    const rawCategories = await prisma.category.findMany({
        include: { translations: true },
    });

    if (!rawProduct) {
        return { notFound: true };
    }

    // Convert date fields
    const product = JSON.parse(JSON.stringify(rawProduct));
    const categories = rawCategories.map((cat) => ({
        ...cat,
        createdAt: cat.createdAt.toISOString(),
        updatedAt: cat.updatedAt.toISOString(),
    }));

    return { props: { product, categories } };
};
" apis : "import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '../../../lib/prisma';
import { jwtVerify } from 'jose';

interface DecodedPayload {
    id: string;
    role: string;
    email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    console.log('--- ADMIN PRODUCT MANAGEMENT ROUTE START ---');

    try {
        // ✅ Extract and verify admin session token
        const rawCookie = req.headers.cookie || '';
        let match = rawCookie.match(/next-auth\.session-token=([^;]+)/) || rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
        if (!match) throw new Error("Unauthorized: No token found");

        const tokenStr = decodeURIComponent(match[1]);
        const secret = process.env.NEXTAUTH_SECRET || '';

        const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
        const user = decoded as unknown as DecodedPayload;

        if (user.role !== 'admin') throw new Error("Unauthorized: Admin access required");

        // ✅ Handle Product Creation
        if (req.method === 'POST') {
            console.log('✅ Creating new product...');

            const { sku, basePrice, categoryId, categorySlug, translations, variations, images } = req.body;

            if (!sku || !basePrice || (!categoryId && !categorySlug)) {
                console.log("❌ Missing required fields:", { sku, basePrice, categoryId, categorySlug });
                return res.status(400).json({ error: "Missing required fields: SKU, Base Price, or Category." });
            }

            let assignedCategoryId = null;

            if (categoryId) {
                // ✅ Convert categoryId to integer
                assignedCategoryId = parseInt(categoryId);
            } else if (categorySlug) {
                // ✅ Find Category by Slug if only slug is provided
                const category = await prisma.category.findUnique({ where: { slug: categorySlug } });
                if (!category) {
                    console.log("❌ Invalid categorySlug provided:", categorySlug);
                    return res.status(400).json({ error: "Invalid category slug provided." });
                }
                assignedCategoryId = category.id;
            }

            // ✅ Create New Product
            const newProduct = await prisma.product.create({
                data: {
                    sku,
                    basePrice: parseFloat(basePrice),
                    categoryId: assignedCategoryId, // ✅ Correctly assign categoryId
                    translations: {
                        create: translations.map(t => ({
                            language: t.language,
                            name: t.name,
                            description: t.description || ""
                        }))
                    },
                    variations: {
                        create: variations.map(v => ({
                            variationType: v.variationType,
                            variationValue: v.variationValue,
                            additionalPrice: parseFloat(v.additionalPrice) || 0
                        }))
                    },
                    images: images || [],
                },
            });

            console.log('✅ Product created successfully:', newProduct);
            return res.status(201).json(newProduct);
        }

        return res.status(405).json({ error: "Method Not Allowed" });

    } catch (error: any) {
        console.error('❌ API Error:', error);
        return res.status(401).json({ error: error.message || "Unauthorized request" });
    }
}
"  "// /pages/api/admin/products/[id].ts
import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '../../../../lib/prisma';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    const { id } = req.query;
    const productId = Number(id);

    if (!productId) {
        return res.status(400).json({ error: "Invalid product ID" });
    }

    try {
        if (req.method === 'PUT') {
            const { sku, basePrice, categoryId, translations, images } = req.body;

            // ✅ Validate required fields
            if (!sku || !basePrice) {
                return res.status(400).json({ error: "SKU and Base Price are required." });
            }

            // ✅ Ensure categoryId is either a valid integer or null
            const parsedCategoryId = categoryId ? parseInt(categoryId) : null;

            // ✅ Clean translations (remove unnecessary IDs)
            const cleanedTranslations = translations.map(({ id, ...rest }) => rest);

            // ✅ Update product in a transaction to maintain integrity
            const updatedProduct = await prisma.$transaction(async (tx) => {
                // ✅ Step 1: Delete existing translations
                await tx.productTranslation.deleteMany({ where: { productId } });

                // ✅ Step 2: Update product
                const product = await tx.product.update({
                    where: { id: productId },
                    data: {
                        sku,
                        basePrice: parseFloat(basePrice),
                        categoryId: parsedCategoryId,
                        images: Array.isArray(images) ? images : [],
                    },
                    include: { category: true, variations: true },
                });

                // ✅ Step 3: Recreate translations
                await tx.productTranslation.createMany({
                    data: cleanedTranslations.map((t) => ({
                        ...t,
                        productId,
                    })),
                });

                return product;
            });

            return res.status(200).json(updatedProduct);
        }

        if (req.method === 'DELETE') {
            // ✅ Ensure product exists before attempting deletion
            const existingProduct = await prisma.product.findUnique({ where: { id: productId } });

            if (!existingProduct) {
                return res.status(404).json({ error: "Product not found." });
            }

            // ✅ Delete related records in a transaction
            await prisma.$transaction(async (tx) => {
                await tx.productTranslation.deleteMany({ where: { productId } });
                await tx.productVariation.deleteMany({ where: { productId } });
                await tx.product.delete({ where: { id: productId } });
            });

            return res.status(200).json({ message: "Product deleted successfully." });
        }

        return res.status(405).json({ error: "Method Not Allowed" });
    } catch (error) {
        console.error("❌ API Error:", error);
        return res.status(500).json({ error: "Internal Server Error" });
    }
}
"
4/4
ChatGPT said:

Below is an all-in-one ManageProducts component that combines the following functionalities into a single React component (instead of multiple pages):

    List of Products (View products, open “create” or “edit” modals)
    Create Product form
    Edit Product form
    Delete Product confirmation

It uses client-side data fetching (via fetch("/api/...")) and local state for toggling between list, create, and edit modes. This allows you to embed this single component in your Admin Dashboard (the “Products” tab, for example) and manage products entirely without leaving the page.

You can adapt any parts as needed—particularly the modal or inline approach for editing/creating. This snippet uses a “toggle state” approach with minimal modals. If you prefer separate pages or deeper modals, you can tweak accordingly.
1) Create a Single ManageProducts Component

// components/admin/ManageProducts.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

// 1) Types
type AdminProduct = {
  id: number;
  sku: string;
  basePrice: string;
  images: string[];
  categoryId?: number | null;
  translations: {
    language: string;
    name: string;
    description?: string;
  }[];
};

type Category = {
  id: number;
  slug: string;
  translations: {
    language: string;
    name: string;
    description?: string;
  }[];
};

type Variation = {
  variationType: string;
  variationValue: string;
  additionalPrice: number;
};

// 2) Top-level ManageProducts Component
export function ManageProducts() {
  // -----------------------------
  // State: product list, categories, error, loading
  // -----------------------------
  const [products, setProducts] = useState<AdminProduct[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  // -----------------------------
  // State: Current mode => "list", "create", "edit", "delete"
  // plus any product in focus
  // -----------------------------
  const [mode, setMode] = useState<"list" | "create" | "edit" | "delete">("list");
  const [selectedProduct, setSelectedProduct] = useState<AdminProduct | null>(null);

  // -----------------------------
  // State for the form data (create/edit)
  // Could be separate states if you prefer
  // -----------------------------
  const [formData, setFormData] = useState<{
    id?: number;
    sku: string;
    basePrice: string;
    categoryId: string;
    translations: {
      language: string;
      name: string;
      description: string;
    }[];
    variations: Variation[];
    images: string[];
  }>({
    sku: "",
    basePrice: "",
    categoryId: "",
    translations: [{ language: "en", name: "", description: "" }],
    variations: [],
    images: [],
  });

  // -----------------------------
  // On mount => fetch products and categories
  // -----------------------------
  useEffect(() => {
    fetchProducts();
    fetchCategories();
  }, []);

  async function fetchProducts() {
    setLoading(true);
    setError("");
    try {
      const res = await fetch("/api/admin/products?all=true"); 
      // or your custom endpoint
      const data = await res.json();
      if (res.ok) {
        setProducts(data);
      } else {
        setError(data.error || "Failed to fetch products.");
      }
    } catch (err) {
      console.error(err);
      setError("Error fetching products.");
    } finally {
      setLoading(false);
    }
  }

  async function fetchCategories() {
    try {
      const res = await fetch("/api/admin/categories");
      const data = await res.json();
      if (res.ok) {
        setCategories(data);
      }
    } catch (err) {
      console.error(err);
      // not crucial enough to show error here
    }
  }

  // -----------------------------
  // Handler: create new product
  // -----------------------------
  async function handleCreateProduct() {
    setLoading(true);
    setError("");
    // Basic validations
    if (!formData.sku || !formData.basePrice || !formData.categoryId) {
      setError("SKU, Base Price, and Category are required.");
      setLoading(false);
      return;
    }

    try {
      const res = await fetch("/api/admin/products", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sku: formData.sku,
          basePrice: formData.basePrice,
          categoryId: formData.categoryId,
          translations: formData.translations,
          variations: formData.variations,
          images: formData.images,
        }),
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to create product.");
      }
      // success => refresh list
      await fetchProducts();
      setMode("list");
      resetForm();
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  // -----------------------------
  // Handler: edit existing product
  // -----------------------------
  async function handleUpdateProduct() {
    if (!selectedProduct) return;
    setLoading(true);
    setError("");

    try {
      const res = await fetch(`/api/admin/products/${selectedProduct.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sku: formData.sku,
          basePrice: formData.basePrice,
          categoryId: formData.categoryId,
          translations: formData.translations,
          images: formData.images,
        }),
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to update product.");
      }
      // success
      await fetchProducts();
      setMode("list");
      resetForm();
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  // -----------------------------
  // Handler: delete product
  // -----------------------------
  async function handleDeleteProduct() {
    if (!selectedProduct) return;
    setLoading(true);
    setError("");

    try {
      const res = await fetch(`/api/admin/products/${selectedProduct.id}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete product.");
      }
      // success
      await fetchProducts();
      setMode("list");
      resetForm();
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  // -----------------------------
  // Helper: initialize form from existing product or empty
  // -----------------------------
  function loadFormForEdit(product: AdminProduct) {
    setFormData({
      sku: product.sku,
      basePrice: product.basePrice.toString(),
      categoryId: product.categoryId ? product.categoryId.toString() : "",
      translations: product.translations.map((t) => ({
        language: t.language,
        name: t.name,
        description: t.description || "",
      })),
      variations: [], // if you'd like to handle variations here
      images: product.images || [],
    });
  }

  function resetForm() {
    setFormData({
      sku: "",
      basePrice: "",
      categoryId: "",
      translations: [{ language: "en", name: "", description: "" }],
      variations: [],
      images: [],
    });
    setSelectedProduct(null);
  }

  // -----------------------------
  // Render
  // -----------------------------
  return (
    <div className="p-6 min-h-screen section-light">
      <h1 className="text-3xl font-serif text-brandGold mb-6">
        Manage Products
      </h1>

      {error && (
        <p className="text-burgundy mb-4 font-semibold">
          {error}
        </p>
      )}

      {/* Show Different Sections Conditionally */}
      {mode === "list" && (
        <div>
          <button
            onClick={() => {
              resetForm();
              setMode("create");
            }}
            className="button-primary mb-6"
          >
            + Add New Product
          </button>

          {loading && <p className="text-platinumGray">Loading...</p>}

          {/* Products Table */}
          <table className="w-full bg-burgundy/10 text-richEbony shadow-luxury rounded-lg overflow-hidden">
            <thead className="bg-burgundy/20">
              <tr>
                <th className="p-3 text-left">ID</th>
                <th className="p-3 text-left">SKU</th>
                <th className="p-3 text-left">Name (EN)</th>
                <th className="p-3">Price</th>
                <th className="p-3">Actions</th>
              </tr>
            </thead>
            <tbody>
              {products.map((prod) => {
                const enTranslation = prod.translations.find(
                  (t) => t.language === "en"
                );
                return (
                  <tr
                    key={prod.id}
                    className="border-b border-platinumGray/30 hover:bg-burgundy/10 transition"
                  >
                    <td className="p-3">{prod.id}</td>
                    <td className="p-3">{prod.sku}</td>
                    <td className="p-3">{enTranslation?.name || "No EN name"}</td>
                    <td className="p-3">€{prod.basePrice}</td>
                    <td className="p-3 text-center">
                      <button
                        onClick={() => {
                          setSelectedProduct(prod);
                          loadFormForEdit(prod);
                          setMode("edit");
                        }}
                        className="text-burgundy hover:text-brandGold mr-3"
                      >
                        Edit
                      </button>
                      <button
                        onClick={() => {
                          setSelectedProduct(prod);
                          setMode("delete");
                        }}
                        className="text-burgundy hover:text-brandGold"
                      >
                        Delete
                      </button>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}

      {mode === "create" && (
        <CreateOrEditForm
          formData={formData}
          setFormData={setFormData}
          categories={categories}
          loading={loading}
          onCancel={() => {
            setMode("list");
            resetForm();
          }}
          onSubmit={handleCreateProduct}
        />
      )}

      {mode === "edit" && (
        <CreateOrEditForm
          formData={formData}
          setFormData={setFormData}
          categories={categories}
          loading={loading}
          onCancel={() => {
            setMode("list");
            resetForm();
          }}
          onSubmit={handleUpdateProduct}
          isEditMode={true}
        />
      )}

      {mode === "delete" && selectedProduct && (
        <DeleteConfirm
          product={selectedProduct}
          loading={loading}
          onCancel={() => {
            setMode("list");
            resetForm();
          }}
          onDelete={handleDeleteProduct}
        />
      )}
    </div>
  );
}

/* 
  CreateOrEditForm 
  A sub-component to handle the create/edit form logic
*/
function CreateOrEditForm({
  formData,
  setFormData,
  categories,
  loading,
  onCancel,
  onSubmit,
  isEditMode = false,
}: {
  formData: {
    sku: string;
    basePrice: string;
    categoryId: string;
    translations: {
      language: string;
      name: string;
      description: string;
    }[];
    images: string[];
    variations: Variation[];
  };
  setFormData: React.Dispatch<
    React.SetStateAction<{
      sku: string;
      basePrice: string;
      categoryId: string;
      translations: { language: string; name: string; description: string }[];
      images: string[];
      variations: Variation[];
    }>
  >;
  categories: Category[];
  loading: boolean;
  onCancel: () => void;
  onSubmit: () => void;
  isEditMode?: boolean;
}) {
  // simpler handlers for each input
  function handleInputChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  }

  function handleTranslationChange(
    index: number,
    field: "name" | "description",
    value: string
  ) {
    setFormData((prev) => {
      const newTrans = [...prev.translations];
      newTrans[index] = { ...newTrans[index], [field]: value };
      return { ...prev, translations: newTrans };
    });
  }

  async function handleImageUpload(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files || e.target.files.length === 0) return;
    const file = e.target.files[0];
    if (!file) return;

    // For demonstration. You might handle an actual /api/upload-image call
    const imageForm = new FormData();
    imageForm.append("file", file);

    try {
      const res = await fetch("/api/upload-image", {
        method: "POST",
        body: imageForm,
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data.error || "Image upload failed.");
      }
      setFormData((prev) => ({
        ...prev,
        images: [...prev.images, data.imageUrl],
      }));
    } catch (err) {
      console.error(err);
      // handle error
    }
  }

  function handleRemoveImage(idx: number) {
    setFormData((prev) => ({
      ...prev,
      images: prev.images.filter((_, i) => i !== idx),
    }));
  }

  return (
    <div className="bg-burgundy/10 p-6 rounded-lg shadow-luxury">
      <h2 className="text-2xl font-serif text-brandGold mb-4">
        {isEditMode ? "Edit Product" : "Create Product"}
      </h2>

      {/* SKU & Price */}
      <div className="mb-4">
        <label className="block font-medium text-richEbony">SKU</label>
        <input
          name="sku"
          value={formData.sku}
          onChange={handleInputChange}
          className="input-field w-full"
        />
      </div>
      <div className="mb-4">
        <label className="block font-medium text-richEbony">Base Price (€)</label>
        <input
          name="basePrice"
          type="number"
          value={formData.basePrice}
          onChange={handleInputChange}
          className="input-field w-full"
        />
      </div>

      {/* Category */}
      <div className="mb-4">
        <label className="block font-medium text-richEbony">Category</label>
        <select
          name="categoryId"
          value={formData.categoryId}
          onChange={handleInputChange}
          className="input-field w-full"
        >
          <option value="">Select Category</option>
          {categories.map((cat) => {
            const enTrans = cat.translations.find((t) => t.language === "en");
            return (
              <option key={cat.id} value={cat.id}>
                {enTrans?.name || cat.slug}
              </option>
            );
          })}
        </select>
      </div>

      {/* Translations */}
      <h3 className="text-xl text-brandGold mt-4 mb-2">Translations</h3>
      {formData.translations.map((t, i) => (
        <div key={i} className="mb-4">
          <label className="block font-medium text-richEbony">
            Language: {t.language}
          </label>
          <input
            value={t.name}
            onChange={(e) => handleTranslationChange(i, "name", e.target.value)}
            className="input-field w-full mt-1"
            placeholder="Product Name"
          />
          <textarea
            value={t.description}
            onChange={(e) => handleTranslationChange(i, "description", e.target.value)}
            className="input-field w-full mt-2"
            placeholder="Description"
          />
        </div>
      ))}

      {/* Images */}
      <h3 className="text-xl text-brandGold mt-4 mb-2">Images</h3>
      <input type="file" onChange={handleImageUpload} className="input-field w-full" />
      <div className="flex gap-2 mt-2">
        {formData.images.map((url, idx) => (
          <div key={idx} className="relative">
            <img
              src={url}
              alt="img"
              className="w-16 h-16 object-cover rounded-md"
            />
            <button
              onClick={() => handleRemoveImage(idx)}
              className="absolute top-0 right-0 bg-burgundy text-brandIvory rounded-full w-6 h-6 flex items-center justify-center hover:bg-brandGold hover:text-richEbony transition"
            >
              ✕
            </button>
          </div>
        ))}
      </div>

      {/* Buttons */}
      <div className="mt-6 flex gap-4">
        <button
          onClick={onSubmit}
          disabled={loading}
          className="button-primary"
        >
          {loading ? "Saving..." : isEditMode ? "Update Product" : "Create Product"}
        </button>
        <button onClick={onCancel} className="button-secondary">
          Cancel
        </button>
      </div>
    </div>
  );
}

/* 
  DeleteConfirm
  A simple confirmation UI for product deletion
*/
function DeleteConfirm({
  product,
  loading,
  onCancel,
  onDelete,
}: {
  product: AdminProduct;
  loading: boolean;
  onCancel: () => void;
  onDelete: () => void;
}) {
  const enTranslation = product.translations.find((t) => t.language === "en");

  return (
    <div className="bg-burgundy/10 p-6 rounded-lg shadow-luxury">
      <h2 className="text-2xl font-serif text-burgundy mb-4">
        Confirm Deletion
      </h2>
      <p className="text-platinumGray mb-4">
        Are you sure you want to delete{" "}
        <strong>{enTranslation?.name || product.sku}</strong>?
      </p>
      <div className="flex gap-6">
        <button
          onClick={onDelete}
          disabled={loading}
          className="button-primary"
        >
          {loading ? "Deleting..." : "Delete"}
        </button>
        <button onClick={onCancel} className="button-secondary">
          Cancel
        </button>
      </div>
    </div>
  );
}

2) Embed in Your Admin Dashboard

In your tab-based admin page (e.g., pages/admin/index.tsx), you can now import <ManageProducts />:

// pages/admin/index.tsx
import { useState } from "react";
import { ManageProducts } from "../../components/admin/ManageProducts";
// import ManageCategories, ManageOrders, etc.

export default function AdminDashboard() {
  const [activeTab, setActiveTab] = useState<"products"|"categories"|"orders">("products");

  return (
    <section className="section-light min-h-screen p-8">
      <h1 className="text-3xl font-serif text-brandGold mb-6">Admin Dashboard</h1>
      {/* Tab Buttons */}
      <div className="flex gap-4 mb-6">
        <button onClick={() => setActiveTab("products")} className="...">
          Produits
        </button>
        <button onClick={() => setActiveTab("categories")} className="...">
          Catégories
        </button>
        <button onClick={() => setActiveTab("orders")} className="...">
          Commandes
        </button>
      </div>

      {activeTab === "products" && <ManageProducts />}
      {activeTab === "categories" && /* <ManageCategories /> */}
      {activeTab === "orders" && /* <ManageOrders /> */}
    </section>
  );
}

You no longer need separate “/admin/products”, “/admin/products/create”, “/admin/products/[id]/edit” pages if you prefer this single-component approach. All logic is handled inside your ManageProducts component.
Why This Works

    Client-Side Data & State
        We do fetch("/api/admin/products") to retrieve products, and store them in local state.
        Similarly for categories.
        All create/edit/delete happens by making fetch calls to your existing Next.js API endpoints.

    Single Page
        The admin toggles list / create / edit / delete modes in local state, so you never need a new route.

    No Full Reloads
        Everything happens in React. This can feel more like a SPA or a “real” dashboard.

    Still Secure
        Your API routes check for admin role via the token parse, so only authorized users can mutate data.

Caveats

    Direct linking to e.g. “/admin/products/[id]/edit” is no longer possible, as it’s all within one component. If you want direct deep links, keep the separate pages or implement a query param approach (?mode=edit&id=12).
    Large admin features can make the single component quite big. You may prefer to break out subcomponents for “Create Form,” “Edit Form,” etc.—which we partially did above with <CreateOrEditForm> and <DeleteConfirm>.

In summary, this snippet consolidates your product management pages into a single “ManageProducts” component, creating an all-in-one experience that can be dropped into a tab in your AdminDashboard. You can replicate this pattern for Categories and Orders if you want a uniform, consolidated solution.
You said:
i get : "--- ADMIN PRODUCT MANAGEMENT ROUTE START ---
 GET /api/admin/products?all=true 405 in 53ms
" because you're fetching apis that are not existing , normallly we fetch product from prisma directly 
ChatGPT said:

Below is an adjusted all-in-one ManageProducts component that doesn’t rely on a GET /api/admin/products?all=true route. Instead, it directly calls your prisma fetch logic from within the component using client-side data fetching or Next.js API routes that you already have. Two main approaches exist:

    Server-Side fetching in the parent page (then passing products as props).
    Client-Side fetching using your existing or new custom route (e.g. GET /api/admin/products).

We’ll show a Client-Side approach that calls an existing route – or if you prefer none – we’ll do a direct fetch to your local Next.js route /api/admin/products. If that route doesn’t exist yet, you can easily create it. If you prefer server-side only, you can pass in products as props to <ManageProducts products={} />. (But then the creation/edit/deletion must also be done via an API route or direct prisma calls.)
Option 1: Use an Existing or New /api/admin/products GET Route
1) Create (or use) an API route like /api/admin/products/index.ts:

// pages/api/admin/products/index.ts
import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose"; // if you do manual token checking

// or do session-based if you prefer

export default async function listProducts(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  try {
    // optional: parse/verify token or session to confirm admin
    // For example:
    // const rawCookie = req.headers.cookie || '';
    // ... verify token ...
    // if (!isAdmin) return res.status(403).json({ error: "Forbidden" });

    const products = await prisma.product.findMany({
      include: {
        translations: true,
      },
      orderBy: { id: "asc" },
    });
    return res.status(200).json(products);
  } catch (error) {
    console.error("❌ Error listing products:", error);
    return res.status(500).json({ error: "Server error listing products" });
  }
}

2) Your All-in-One Component: <ManageProducts />

Below is a revised version that calls /api/admin/products for listing. If that route doesn’t exist, you can directly do a server-side approach instead (explained next).

// components/admin/ManageProducts.tsx

import { useState, useEffect } from "react";

// [1] Types
type AdminProduct = {
  id: number;
  sku: string;
  basePrice: string;
  images: string[];
  categoryId?: number | null;
  translations: {
    language: string;
    name: string;
    description?: string;
  }[];
};

type Category = {
  id: number;
  slug: string;
  translations: {
    language: string;
    name: string;
    description?: string;
  }[];
};

type Variation = {
  variationType: string;
  variationValue: string;
  additionalPrice: number;
};

// [2] The component
export function ManageProducts() {
  const [products, setProducts] = useState<AdminProduct[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const [mode, setMode] = useState<"list" | "create" | "edit" | "delete">("list");
  const [selectedProduct, setSelectedProduct] = useState<AdminProduct | null>(null);

  const [formData, setFormData] = useState<{
    id?: number;
    sku: string;
    basePrice: string;
    categoryId: string;
    translations: {
      language: string;
      name: string;
      description: string;
    }[];
    variations: Variation[];
    images: string[];
  }>({
    sku: "",
    basePrice: "",
    categoryId: "",
    translations: [{ language: "en", name: "", description: "" }],
    variations: [],
    images: [],
  });

  // If you'd like to do "no route calls," you'd remove these fetch calls and rely on SSR or direct prisma calls
  useEffect(() => {
    fetchProducts();
    fetchCategories();
  }, []);

  async function fetchProducts() {
    setLoading(true);
    setError("");
    try {
      // calling your hypothetical route
      const res = await fetch("/api/admin/products");
      if (!res.ok) {
        const errData = await res.json();
        throw new Error(errData.error || "Failed to fetch products");
      }
      const data = await res.json();
      setProducts(data);
    } catch (err: any) {
      console.error("❌ fetchProducts error:", err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  async function fetchCategories() {
    try {
      const res = await fetch("/api/admin/categories");
      if (!res.ok) return;
      const data = await res.json();
      setCategories(data);
    } catch {
      // ignore or handle
    }
  }

  // [3] Example create/edit/delete logic calls your existing /api/admin/products or /api/admin/products/[id] routes
  // same as the snippet we provided earlier

  // ... Rest of the code from the snippet,
  // handleCreateProduct, handleUpdateProduct, handleDeleteProduct,
  // plus CreateOrEditForm, DeleteConfirm, etc.

  // (no changes from previous snippet in those parts)
  ...
}

If the code complains about a 405 method not allowed, ensure that you have a GET /api/admin/products route. If you don’t want separate API routes, see Option 2 below.
Option 2: Server-Side Fetching in the Parent Admin Tab Page

Alternatively, if you prefer to not create a separate GET route, you can do Server-Side in your parent Admin page, then pass the products / categories as props to <ManageProducts />. This eliminates the “405 not allowed” because you’re never calling a missing route. Instead:
1) The parent page (e.g. pages/admin/index.tsx) does SSR:

// pages/admin/index.tsx
import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import { getSession } from "next-auth/react";
import { useState } from "react";
import { ManageProducts } from "../../components/admin/ManageProducts";
// import ManageCategories, etc.

export default function AdminDashboard({ products, categories }: any) {
  const [activeTab, setActiveTab] = useState<"products" | "categories" | "orders">("products");

  return (
    <section className="p-8 min-h-screen section-light">
      <h1>Admin Dashboard</h1>
      {/* buttons for toggles ... */}
      {activeTab === "products" && (
        <ManageProducts
          initialProducts={products}
          initialCategories={categories}
        />
      )}
    </section>
  );
}

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const session = await getSession(ctx);
  if (!session || session.user.role !== "admin") {
    return {
      redirect: { destination: "/", permanent: false },
    };
  }
  // direct prisma fetch
  const rawProducts = await prisma.product.findMany({
    include: { translations: true },
  });
  const rawCategories = await prisma.category.findMany({
    include: { translations: true },
  });

  return {
    props: {
      products: JSON.parse(JSON.stringify(rawProducts)),
      categories: JSON.parse(JSON.stringify(rawCategories)),
    },
  };
};

2) Modify your ManageProducts to Accept Props Instead of Doing fetch(...)

// components/admin/ManageProducts.tsx
import { useState } from "react";

export function ManageProducts({
  initialProducts,
  initialCategories,
}: {
  initialProducts: AdminProduct[];
  initialCategories: Category[];
}) {
  // We store them in local state
  const [products, setProducts] = useState(initialProducts);
  const [categories] = useState(initialCategories);

  // The rest is the same – except we do NOT call fetch in useEffect
  // Because we already have the products from SSR

  // In your create/edit/delete calls, you can still call /api routes
  // or directly manipulate state and call prisma if you prefer

  // e.g. handleCreateProduct => fetch("/api/admin/products", { ... })
  // Then update local state or re-fetch if you do have an API route
  ...
}

That way, you do not need an existing “GET /api/admin/products” route. The 405 error is gone because you never do a fetch("/api/admin/products"). All product data is server-rendered and passed in as props.
In Summary

    You encountered a 405 error because your snippet tried calling a route (GET /api/admin/products?all=true) that wasn’t defined.
    Solutions:
        Define that route so it returns your product list.
        Server-side fetch the product list in the parent page and pass it to the single “ManageProducts” component via props. No route call needed.

Here’s a quick decision guide:

    If you want to client-side fetch your product list, create or reuse an existing API route that does prisma.product.findMany(...).
    If you’d rather keep it simple with SSR, do the prisma.product.findMany(...) in getServerSideProps of your admin page, then pass the data to <ManageProducts initialProducts={...} />.

Either approach will eliminate the “405 method not allowed” and let you unify your product management code in one “ManageProducts” component.
You said:
you know what , updat this api/admin/products to incorporate the get method and any other necessary api : "import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '../../../lib/prisma';
import { jwtVerify } from 'jose';

interface DecodedPayload {
    id: string;
    role: string;
    email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    console.log('--- ADMIN PRODUCT MANAGEMENT ROUTE START ---');

    try {
        // ✅ Extract and verify admin session token
        const rawCookie = req.headers.cookie || '';
        let match = rawCookie.match(/next-auth\.session-token=([^;]+)/) || rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
        if (!match) throw new Error("Unauthorized: No token found");

        const tokenStr = decodeURIComponent(match[1]);
        const secret = process.env.NEXTAUTH_SECRET || '';

        const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
        const user = decoded as unknown as DecodedPayload;

        if (user.role !== 'admin') throw new Error("Unauthorized: Admin access required");

        // ✅ Handle Product Creation
        if (req.method === 'POST') {
            console.log('✅ Creating new product...');

            const { sku, basePrice, categoryId, categorySlug, translations, variations, images } = req.body;

            if (!sku || !basePrice || (!categoryId && !categorySlug)) {
                console.log("❌ Missing required fields:", { sku, basePrice, categoryId, categorySlug });
                return res.status(400).json({ error: "Missing required fields: SKU, Base Price, or Category." });
            }

            let assignedCategoryId = null;

            if (categoryId) {
                // ✅ Convert categoryId to integer
                assignedCategoryId = parseInt(categoryId);
            } else if (categorySlug) {
                // ✅ Find Category by Slug if only slug is provided
                const category = await prisma.category.findUnique({ where: { slug: categorySlug } });
                if (!category) {
                    console.log("❌ Invalid categorySlug provided:", categorySlug);
                    return res.status(400).json({ error: "Invalid category slug provided." });
                }
                assignedCategoryId = category.id;
            }

            // ✅ Create New Product
            const newProduct = await prisma.product.create({
                data: {
                    sku,
                    basePrice: parseFloat(basePrice),
                    categoryId: assignedCategoryId, // ✅ Correctly assign categoryId
                    translations: {
                        create: translations.map(t => ({
                            language: t.language,
                            name: t.name,
                            description: t.description || ""
                        }))
                    },
                    variations: {
                        create: variations.map(v => ({
                            variationType: v.variationType,
                            variationValue: v.variationValue,
                            additionalPrice: parseFloat(v.additionalPrice) || 0
                        }))
                    },
                    images: images || [],
                },
            });

            console.log('✅ Product created successfully:', newProduct);
            return res.status(201).json(newProduct);
        }

        return res.status(405).json({ error: "Method Not Allowed" });

    } catch (error: any) {
        console.error('❌ API Error:', error);
        return res.status(401).json({ error: error.message || "Unauthorized request" });
    }
}
"
ChatGPT said:

Below is an updated pages/api/admin/products.ts route that handles:

    GET /api/admin/products – Returns a list of products (with their translations, category IDs, etc.).
    POST /api/admin/products – Creates a new product (the existing logic).

We do a manual token check with jose to ensure the user is an admin. If you have separate logic for updating or deleting a product, keep those in pages/api/admin/products/[id].ts as you already do.

// pages/api/admin/products.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- ADMIN PRODUCT MANAGEMENT ROUTE START ---");

  try {
    // -----------------------------
    // 1) Extract & verify admin session token
    // -----------------------------
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";

    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    const user = decoded as unknown as DecodedPayload;

    if (user.role !== "admin") {
      throw new Error("Unauthorized: Admin access required");
    }

    // -----------------------------
    // 2) Handle GET => return product list
    // -----------------------------
    if (req.method === "GET") {
      console.log("✅ GET /api/admin/products => Listing products...");
      const products = await prisma.product.findMany({
        include: {
          translations: true,
          category: true,
          variations: true,
        },
        orderBy: { id: "asc" },
      });

      return res.status(200).json(products);
    }

    // -----------------------------
    // 3) Handle POST => create new product
    // -----------------------------
    if (req.method === "POST") {
      console.log("✅ Creating new product...");

      const { sku, basePrice, categoryId, categorySlug, translations, variations, images } =
        req.body;

      if (!sku || !basePrice || (!categoryId && !categorySlug)) {
        console.log("❌ Missing required fields:", {
          sku,
          basePrice,
          categoryId,
          categorySlug,
        });
        return res
          .status(400)
          .json({ error: "Missing required fields: SKU, Base Price, or Category." });
      }

      let assignedCategoryId = null;

      if (categoryId) {
        // Convert categoryId to integer
        assignedCategoryId = parseInt(categoryId);
      } else if (categorySlug) {
        // Find Category by Slug if only slug is provided
        const category = await prisma.category.findUnique({
          where: { slug: categorySlug },
        });
        if (!category) {
          console.log("❌ Invalid categorySlug provided:", categorySlug);
          return res.status(400).json({ error: "Invalid category slug provided." });
        }
        assignedCategoryId = category.id;
      }

      // Create New Product
      const newProduct = await prisma.product.create({
        data: {
          sku,
          basePrice: parseFloat(basePrice),
          categoryId: assignedCategoryId, // assign category
          translations: {
            create: (translations || []).map((t: any) => ({
              language: t.language,
              name: t.name,
              description: t.description || "",
            })),
          },
          variations: {
            create: (variations || []).map((v: any) => ({
              variationType: v.variationType,
              variationValue: v.variationValue,
              additionalPrice: parseFloat(v.additionalPrice) || 0,
            })),
          },
          images: images || [],
        },
      });

      console.log("✅ Product created successfully:", newProduct);
      return res.status(201).json(newProduct);
    }

    // If neither GET nor POST
    return res.status(405).json({ error: "Method Not Allowed" });
  } catch (error: any) {
    console.error("❌ API Error:", error);
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

Explanation & Flow

    Session Token Parsing
        We search for either next-auth.session-token or __Secure-next-auth.session-token in the cookie.
        If not found, we return a 401.

    Token Verification
        We call jwtVerify(tokenStr, new TextEncoder().encode(secret)) from the jose library.
        If decoded.role is not “admin,” we throw an error.

    GET
        If req.method === "GET", we do prisma.product.findMany(...), including translations, category, variations.
        Return the products as JSON.

    POST
        We read sku, basePrice, categoryId or categorySlug, translations, variations, images from req.body.
        We validate the required fields (SKU, basePrice, and a category).
        Then we create the new product with Prisma, returning a 201 on success.

    All Else => 405
        If the request method is neither GET nor POST, we respond with a 405 “Method Not Allowed.”

With this, you now have a single endpoint supporting:

    GET /api/admin/products – listing all products.
    POST /api/admin/products – creating a new product.

Your client or component can call GET /api/admin/products to display the product list, and POST /api/admin/products to create a new product. For updating or deleting a product, you still rely on the pages/api/admin/products/[id].ts route, as in your code.
You said:
Now let's get the categories system management page as a component so we use it o our unified admin dashboard : "import { useState, useEffect } from "react";

export default function ManageCategories() {
    const [categories, setCategories] = useState([]);
    const [newCategorySlug, setNewCategorySlug] = useState("");
    const [translations, setTranslations] = useState([
        { language: "en", name: "", description: "" },
    ]);
    const [error, setError] = useState("");
    const [editingCategory, setEditingCategory] = useState(null);

    useEffect(() => {
        fetchCategories();
    }, []);

    const fetchCategories = async () => {
        const res = await fetch("/api/admin/categories");
        const data = await res.json();
        setCategories(data);
    };

    const handleTranslationChange = (index, key, value) => {
        const updatedTranslations = [...translations];
        updatedTranslations[index][key] = value;
        setTranslations(updatedTranslations);
    };

    // ✅ Handle Category Creation
    const handleCreateCategory = async () => {
        if (!newCategorySlug.trim()) return setError("Category slug is required.");
        setError("");

        const res = await fetch("/api/admin/categories", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ slug: newCategorySlug, translations }),
        });

        if (!res.ok) {
            setError("Failed to create category.");
            return;
        }

        setNewCategorySlug("");
        setTranslations([{ language: "en", name: "", description: "" }]);
        fetchCategories();
    };

    // ✅ Handle Category Editing
    const handleEditCategory = async () => {
        if (!editingCategory) return;
        setError("");

        const res = await fetch(/api/admin/categories/${editingCategory.id}, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                slug: editingCategory.slug,
                translations: editingCategory.translations,
            }),
        });

        if (!res.ok) {
            setError("Failed to update category.");
            return;
        }

        setEditingCategory(null);
        fetchCategories();
    };

    // ✅ Handle Category Deletion
    const handleDeleteCategory = async (id) => {
        if (!window.confirm("Are you sure you want to delete this category?")) return;

        const res = await fetch(/api/admin/categories/${id}, { method: "DELETE" });

        if (!res.ok) {
            setError("Failed to delete category.");
            return;
        }

        fetchCategories();
    };

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-4">
                Manage Categories
            </h1>

            {/* Category Creation */}
            <div className="mb-6">
                <input
                    type="text"
                    placeholder="Category Slug (e.g., rings, bracelets)"
                    value={newCategorySlug}
                    onChange={(e) => setNewCategorySlug(e.target.value)}
                    className="input-field mr-2 w-full max-w-sm"
                />

                {translations.map((t, index) => (
                    <div key={index} className="mt-3 space-y-2">
                        <input
                            type="text"
                            placeholder={Category Name (${t.language})}
                            value={t.name}
                            onChange={(e) =>
                                handleTranslationChange(index, "name", e.target.value)
                            }
                            className="input-field w-full max-w-sm"
                        />
                        <input
                            type="text"
                            placeholder={Description (${t.language})}
                            value={t.description}
                            onChange={(e) =>
                                handleTranslationChange(index, "description", e.target.value)
                            }
                            className="input-field w-full max-w-sm"
                        />
                    </div>
                ))}

                <button
                    onClick={handleCreateCategory}
                    className="button-primary mt-4"
                >
                    Create Category
                </button>
                {error && <p className="text-burgundy mt-2">{error}</p>}
            </div>

            {/* Category List */}
            <ul className="mt-4 list-disc list-inside space-y-4">
                {categories.map((category) => {
                    const translation =
                        category.translations.find((t) => t.language === "en") || {};

                    return (
                        <li
                            key={category.id}
                            className="flex flex-col md:flex-row md:items-center justify-between bg-burgundy/10 p-4 rounded-md"
                        >
                            <div className="text-richEbony">
                                <strong>{translation.name || category.slug}</strong> -{" "}
                                {translation.description || "No description available"}
                            </div>
                            <div className="flex gap-3 mt-2 md:mt-0">
                                <button
                                    onClick={() => setEditingCategory(category)}
                                    className="bg-brandGold text-richEbony px-3 py-1 rounded-full hover:bg-burgundy hover:text-brandIvory transition duration-300"
                                >
                                    Edit
                                </button>
                                <button
                                    onClick={() => handleDeleteCategory(category.id)}
                                    className="bg-burgundy text-brandIvory px-3 py-1 rounded-full hover:bg-brandGold hover:text-richEbony transition duration-300"
                                >
                                    Delete
                                </button>
                            </div>
                        </li>
                    );
                })}
            </ul>

            {/* Edit Form */}
            {editingCategory && (
                <div className="mt-6 p-4 bg-burgundy/10 rounded-md">
                    <h2 className="text-xl font-serif text-brandGold mb-3">
                        Edit Category
                    </h2>
                    <input
                        type="text"
                        placeholder="Category Slug"
                        value={editingCategory.slug}
                        onChange={(e) =>
                            setEditingCategory({ ...editingCategory, slug: e.target.value })
                        }
                        className="input-field w-full max-w-sm mb-3"
                    />
                    {editingCategory.translations.map((t, index) => (
                        <div key={index} className="mt-4 space-y-2">
                            <input
                                type="text"
                                placeholder={Category Name (${t.language})}
                                value={t.name}
                                onChange={(e) => {
                                    const updatedTranslations = [...editingCategory.translations];
                                    updatedTranslations[index].name = e.target.value;
                                    setEditingCategory({
                                        ...editingCategory,
                                        translations: updatedTranslations,
                                    });
                                }}
                                className="input-field w-full max-w-sm"
                            />
                            <input
                                type="text"
                                placeholder={Description (${t.language})}
                                value={t.description}
                                onChange={(e) => {
                                    const updatedTranslations = [...editingCategory.translations];
                                    updatedTranslations[index].description = e.target.value;
                                    setEditingCategory({
                                        ...editingCategory,
                                        translations: updatedTranslations,
                                    });
                                }}
                                className="input-field w-full max-w-sm"
                            />
                        </div>
                    ))}
                    <button
                        onClick={handleEditCategory}
                        className="button-primary mt-4"
                    >
                        Update Category
                    </button>
                    {error && <p className="text-burgundy mt-2">{error}</p>}
                </div>
            )}
        </section>
    );
}
"  "// pages/api/admin/categories.ts
import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === "GET") {
        // ✅ Fetch categories with their translations
        const categories = await prisma.category.findMany({
            include: { translations: true },
        });

        return res.status(200).json(categories);
    }

    if (req.method === "POST") {
        const { slug, translations } = req.body;
        if (!slug) return res.status(400).json({ error: "Category slug is required" });

        // ✅ Create category and its translations
        const category = await prisma.category.create({
            data: {
                slug,
                translations: {
                    create: translations.map((t) => ({
                        language: t.language,
                        name: t.name,
                        description: t.description || "",
                    })),
                },
            },
            include: { translations: true }, // ✅ Return translations in response
        });

        return res.status(201).json(category);
    }

    return res.status(405).json({ error: "Method Not Allowed" });
}
"  "import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    const { id } = req.query;

    if (req.method === "PUT") {
        const { slug, translations } = req.body;

        try {
            await prisma.categoryTranslation.deleteMany({
                where: { categoryId: Number(id) },
            });

            const updatedCategory = await prisma.category.update({
                where: { id: Number(id) },
                data: {
                    slug,
                    translations: {
                        create: translations.map((t) => ({
                            language: t.language,
                            name: t.name,
                            description: t.description || "",
                        })),
                    },
                },
                include: { translations: true },
            });

            return res.status(200).json(updatedCategory);
        } catch (error) {
            return res.status(500).json({ error: "Failed to update category." });
        }
    }

    if (req.method === "DELETE") {
        try {
            await prisma.categoryTranslation.deleteMany({
                where: { categoryId: Number(id) },
            });

            await prisma.category.delete({
                where: { id: Number(id) },
            });

            return res.status(200).json({ message: "Category deleted successfully." });
        } catch (error) {
            return res.status(500).json({ error: "Failed to delete category." });
        }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
}
"

Below is a single React component called ManageCategories that you can embed into your unified admin dashboard (e.g., in a tab-based system). It fetches, creates, edits, and deletes categories by calling your existing /api/admin/categories and /api/admin/categories/[id] routes.

You no longer need a dedicated /pages/admin/categories.tsx page. Instead, this component can be imported into your AdminDashboard or pages/admin/index.tsx and displayed conditionally alongside your other admin modules.

// components/admin/ManageCategories.tsx

import { useState, useEffect } from "react";

/**
 * ManageCategories Component
 * - Lists categories
 * - Creates new categories
 * - Edits existing categories (slug & translations)
 * - Deletes categories
 */
export function ManageCategories() {
  // ---------- State ----------
  const [categories, setCategories] = useState<any[]>([]);
  const [newCategorySlug, setNewCategorySlug] = useState("");
  const [translations, setTranslations] = useState([
    { language: "en", name: "", description: "" },
  ]);
  const [error, setError] = useState("");
  const [editingCategory, setEditingCategory] = useState<any | null>(null);

  // ---------- Fetch Categories on Mount ----------
  useEffect(() => {
    fetchCategories();
  }, []);

  async function fetchCategories() {
    setError("");
    try {
      const res = await fetch("/api/admin/categories");
      if (!res.ok) {
        throw new Error("Failed to fetch categories");
      }
      const data = await res.json();
      setCategories(data);
    } catch (err: any) {
      setError(err.message);
    }
  }

  // ---------- Handle Translations in Create Form ----------
  function handleTranslationChange(
    index: number,
    key: "name" | "description",
    value: string
  ) {
    const updated = [...translations];
    updated[index][key] = value;
    setTranslations(updated);
  }

  // ---------- Create Category ----------
  async function handleCreateCategory() {
    if (!newCategorySlug.trim()) {
      setError("Category slug is required.");
      return;
    }
    setError("");

    try {
      const res = await fetch("/api/admin/categories", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          slug: newCategorySlug,
          translations,
        }),
      });

      if (!res.ok) {
        throw new Error("Failed to create category.");
      }

      // Reset form
      setNewCategorySlug("");
      setTranslations([{ language: "en", name: "", description: "" }]);
      fetchCategories();
    } catch (err: any) {
      setError(err.message);
    }
  }

  // ---------- Edit Category ----------
  async function handleEditCategory() {
    if (!editingCategory) return;
    setError("");

    try {
      const res = await fetch(`/api/admin/categories/${editingCategory.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          slug: editingCategory.slug,
          translations: editingCategory.translations,
        }),
      });

      if (!res.ok) {
        throw new Error("Failed to update category.");
      }

      setEditingCategory(null);
      fetchCategories();
    } catch (err: any) {
      setError(err.message);
    }
  }

  // ---------- Delete Category ----------
  async function handleDeleteCategory(id: number) {
    if (!window.confirm("Are you sure you want to delete this category?")) return;

    try {
      const res = await fetch(`/api/admin/categories/${id}`, { method: "DELETE" });
      if (!res.ok) {
        throw new Error("Failed to delete category.");
      }
      fetchCategories();
    } catch (err: any) {
      setError(err.message);
    }
  }

  // ---------- Render ----------
  return (
    <div className="p-6 section-light">
      <h1 className="text-3xl font-serif text-brandGold mb-4">Manage Categories</h1>

      {error && <p className="text-burgundy mb-4">{error}</p>}

      {/* 1) Create Category Form */}
      <div className="mb-6 bg-burgundy/10 p-4 rounded-md">
        <h2 className="text-xl font-semibold text-richEbony mb-2">Create New Category</h2>
        <input
          type="text"
          placeholder="Category Slug (e.g. rings, bracelets)"
          value={newCategorySlug}
          onChange={(e) => setNewCategorySlug(e.target.value)}
          className="input-field w-full max-w-sm"
        />
        {translations.map((t, index) => (
          <div key={index} className="mt-3 space-y-2">
            <input
              type="text"
              placeholder={`Category Name (${t.language})`}
              value={t.name}
              onChange={(e) =>
                handleTranslationChange(index, "name", e.target.value)
              }
              className="input-field w-full max-w-sm"
            />
            <input
              type="text"
              placeholder={`Description (${t.language})`}
              value={t.description}
              onChange={(e) =>
                handleTranslationChange(index, "description", e.target.value)
              }
              className="input-field w-full max-w-sm"
            />
          </div>
        ))}

        <button onClick={handleCreateCategory} className="button-primary mt-3">
          Create Category
        </button>
      </div>

      {/* 2) List of Existing Categories */}
      <ul className="space-y-4 mt-8">
        {categories.map((cat) => {
          const enTrans = cat.translations.find((t: any) => t.language === "en") || {};
          return (
            <li
              key={cat.id}
              className="bg-burgundy/10 p-4 rounded-md flex flex-col gap-2 md:flex-row md:items-center md:justify-between"
            >
              <div>
                <strong className="text-richEbony">
                  {enTrans.name || cat.slug}
                </strong>{" "}
                - {enTrans.description || "No description"}
              </div>
              <div className="flex gap-3">
                <button
                  onClick={() => setEditingCategory(cat)}
                  className="bg-brandGold text-richEbony px-3 py-1 rounded-full hover:bg-burgundy hover:text-brandIvory transition"
                >
                  Edit
                </button>
                <button
                  onClick={() => handleDeleteCategory(cat.id)}
                  className="bg-burgundy text-brandIvory px-3 py-1 rounded-full hover:bg-brandGold hover:text-richEbony transition"
                >
                  Delete
                </button>
              </div>
            </li>
          );
        })}
      </ul>

      {/* 3) Edit Form (if editingCategory is set) */}
      {editingCategory && (
        <div className="mt-6 p-4 bg-burgundy/10 rounded-md">
          <h2 className="text-xl font-serif text-brandGold mb-3">
            Edit Category
          </h2>
          <input
            type="text"
            placeholder="Category Slug"
            value={editingCategory.slug}
            onChange={(e) =>
              setEditingCategory({
                ...editingCategory,
                slug: e.target.value,
              })
            }
            className="input-field w-full max-w-sm mb-3"
          />

          {editingCategory.translations.map((t: any, index: number) => (
            <div key={index} className="mt-4 space-y-2">
              <input
                type="text"
                placeholder={`Category Name (${t.language})`}
                value={t.name}
                onChange={(e) => {
                  const updated = [...editingCategory.translations];
                  updated[index].name = e.target.value;
                  setEditingCategory({
                    ...editingCategory,
                    translations: updated,
                  });
                }}
                className="input-field w-full max-w-sm"
              />
              <input
                type="text"
                placeholder={`Description (${t.language})`}
                value={t.description}
                onChange={(e) => {
                  const updated = [...editingCategory.translations];
                  updated[index].description = e.target.value;
                  setEditingCategory({
                    ...editingCategory,
                    translations: updated,
                  });
                }}
                className="input-field w-full max-w-sm"
              />
            </div>
          ))}

          <button onClick={handleEditCategory} className="button-primary mt-4">
            Update Category
          </button>
        </div>
      )}
    </div>
  );
}

How to Use in Your Unified Admin Dashboard

    Import the component into your tab-based admin page, e.g.:

// pages/admin/index.tsx
import { useState } from "react";
import { ManageProducts } from "../../components/admin/ManageProducts";
import { ManageCategories } from "../../components/admin/ManageCategories";
// ... etc.

export default function AdminDashboard() {
  const [activeTab, setActiveTab] = useState<"products"|"categories"|"orders">("products");

  return (
    <section className="p-8 min-h-screen section-light">
      <h1 className="text-3xl font-serif text-brandGold mb-6">Admin Dashboard</h1>
      <div className="flex gap-4 mb-6">
        <button onClick={() => setActiveTab("products")}>Produits</button>
        <button onClick={() => setActiveTab("categories")}>Catégories</button>
        <button onClick={() => setActiveTab("orders")}>Commandes</button>
      </div>

      {activeTab === "products" && <ManageProducts />}
      {activeTab === "categories" && <ManageCategories />}
      {/* e.g. {activeTab === "orders" && <ManageOrders />} */}
    </section>
  );
}

    Ensure the GET /api/admin/categories route is in place. Your code snippet for pages/api/admin/categories.ts is already set up to handle GET and POST.
    All logic to create, edit, or delete categories is done by calling fetch(...) to these routes. The user never has to leave the page.

Wrap Up

With this approach:

    You have a single ManageCategories component that handles listing, creating, editing, and deleting categories.
    The user can toggle between “Manage Products,” “Manage Categories,” and “Manage Orders” in your unified admin tab UI.
    No separate pages for each step. Everything is done via client-side fetch calls to the existing or newly created Next.js API routes.

That’s it! Now your categories system is modular and easy to embed in your all-in-one admin dashboard.
You said:
let's move now converting the orders management system into an unified component to use later into the all-in-one admin dashboard  : "// pages/admin/orders/index.tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import Link from "next/link";

type AdminOrder = {
    id: number;
    status: string;
    totalAmount: string;
    createdAt: string;
    user: {
        email: string;
    } | null;
};

export default function OrdersAdminPage({ orders }: { orders: AdminOrder[] }) {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Orders</h1>

            {orders.length === 0 ? (
                <p className="text-platinumGray">No orders found.</p>
            ) : (
                <div className="overflow-x-auto">
                    <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
                        <thead className="bg-burgundy/20 text-brandGold">
                        <tr>
                            <th className="p-3 text-left">ID</th>
                            <th className="p-3 text-left">User</th>
                            <th className="p-3">Status</th>
                            <th className="p-3">Total (€)</th>
                            <th className="p-3">Created</th>
                            <th className="p-3">Actions</th>
                        </tr>
                        </thead>
                        <tbody>
                        {orders.map((order) => (
                            <tr
                                key={order.id}
                                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
                            >
                                <td className="p-3">{order.id}</td>
                                <td className="p-3">{order.user?.email ?? "Guest"}</td>
                                <td className="p-3 text-center">{order.status}</td>
                                <td className="p-3 text-center">€{order.totalAmount}</td>
                                <td className="p-3">
                                    {new Date(order.createdAt).toLocaleString()}
                                </td>
                                <td className="p-3 text-center">
                                    <Link href={/admin/orders/${order.id}} className="button-secondary">
                                        View / Edit
                                    </Link>
                                </td>
                            </tr>
                        ))}
                        </tbody>
                    </table>
                </div>
            )}
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: { destination: "/", permanent: false },
        };
    }

    const rawOrders = await prisma.order.findMany({
        include: { user: true },
        orderBy: { createdAt: "desc" },
    });

    return {
        props: { orders: JSON.parse(JSON.stringify(rawOrders)) },
    };
};
"  "// pages/admin/orders/[id].tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import { useState } from "react";

type OrderEditProps = {
    orderData: any;
};

export default function OrderEditPage({ orderData }: OrderEditProps) {
    const [orderStatus, setOrderStatus] = useState(orderData.status);
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState("");

    async function handleStatusUpdate() {
        setLoading(true);
        setMessage("");

        try {
            const res = await fetch(/api/admin/orders/${orderData.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ status: orderStatus }),
            });

            const data = await res.json();
            if (!res.ok) {
                setMessage(data.error || "Failed to update order");
            } else {
                setMessage("Order updated successfully");
            }
        } catch (error) {
            setMessage("Error updating order");
        } finally {
            setLoading(false);
        }
    }

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">
                Editing Order #{orderData.id}
            </h1>
            {message && <p className="text-burgundy mb-4 font-semibold">{message}</p>}

            {/* Order Info */}
            <div className="bg-burgundy/10 p-6 rounded-lg shadow-luxury space-y-3">
                <p>
                    <strong>User:</strong> {orderData.user?.email || "Guest"}
                </p>
                <p>
                    <strong>Created At:</strong>{" "}
                    {new Date(orderData.createdAt).toLocaleString()}
                </p>
                <p>
                    <strong>Address:</strong> {orderData.shippingAddress}, {orderData.city}{" "}
                    {orderData.postalCode}, {orderData.country}
                </p>
                <p>
                    <strong>Total:</strong> €{orderData.totalAmount}
                </p>

                {/* Update Status */}
                <div className="mt-4">
                    <label className="block text-lg font-medium text-richEbony mb-2">
                        Update Status
                    </label>
                    <select
                        className="input-field w-full max-w-sm"
                        value={orderStatus}
                        onChange={(e) => setOrderStatus(e.target.value)}
                        disabled={loading}
                    >
                        <option value="PENDING">Pending</option>
                        <option value="CONFIRMED">Confirmed</option>
                        <option value="SHIPPED">Shipped</option>
                        <option value="DELIVERED">Delivered</option>
                        <option value="CANCELLED">Cancelled</option>
                    </select>
                </div>

                <button
                    onClick={handleStatusUpdate}
                    className="button-primary w-full md:w-auto mt-4"
                    disabled={loading}
                >
                    {loading ? "Updating..." : "Update Status"}
                </button>
            </div>

            {/* Order Items */}
            <h2 className="text-3xl font-serif text-brandGold mt-8 mb-4">
                Order Items
            </h2>
            <ul className="space-y-4">
                {orderData.orderItems.map((item: any) => {
                    const productName =
                        item.product.translations.find((t: any) => t.language === "en")
                            ?.name || "Unnamed Product";

                    return (
                        <li
                            key={item.id}
                            className="bg-burgundy/10 p-4 rounded-md shadow-subtle"
                        >
                            <p>
                                <strong>{productName}</strong>
                            </p>
                            <p>SKU: {item.product.sku}</p>
                            <p>Quantity: {item.quantity}</p>
                            <p>Price: €{parseFloat(item.price).toFixed(2)}</p>
                        </li>
                    );
                })}
            </ul>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const { id } = context.params!;
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const rawOrder = await prisma.order.findUnique({
        where: { id: Number(id) },
        include: {
            user: true,
            orderItems: {
                include: {
                    product: {
                        include: { translations: true },
                    },
                },
            },
        },
    });

    if (!rawOrder) {
        return { notFound: true };
    }

    return {
        props: { orderData: JSON.parse(JSON.stringify(rawOrder)) },
    };
};
" "import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";
import { sendOrderUpdateEmail } from "../../../../lib/email";

interface DecodedPayload {
    id: string;
    role: string;
    email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    console.log("🔹 ADMIN ORDER UPDATE ROUTE INITIATED");

    // 🔐 Extract session token manually
    const rawCookie = req.headers.cookie || "";
    let match = rawCookie.match(/next-auth\.session-token=([^;]+)/);
    if (!match) {
        match = rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
        if (!match) {
            console.log("❌ No session token in cookies.");
            return res.status(401).json({ error: "Unauthorized: No session token found." });
        }
    }

    const tokenStr = decodeURIComponent(match[1]);

    // 🔐 Decode JWT token manually
    let payload: DecodedPayload;
    try {
        const secret = process.env.NEXTAUTH_SECRET || "";
        const { payload: decoded } = await jwtVerify(
            tokenStr,
            new TextEncoder().encode(secret)
        );
        console.log("🔹 Decoded JWT Payload:", decoded);
        payload = decoded as unknown as DecodedPayload;
    } catch (err) {
        console.log("❌ JWT Decode Error:", err);
        return res.status(401).json({ error: "Unauthorized: Invalid token." });
    }

    // 🔐 Ensure the user is an admin
    if (payload.role !== "admin") {
        console.log("❌ User is not an admin.");
        return res.status(403).json({ error: "Forbidden: Admin access required." });
    }

    const { id } = req.query;

    if (req.method === "PUT") {
        const { status } = req.body;
        try {
            // ✅ Update the order in the database
            const updatedOrder = await prisma.order.update({
                where: { id: Number(id) },
                data: { status },
                include: { user: true },
            });

            // ✅ Send Email Notification if user email exists
            if (updatedOrder.user?.email) {
                await sendOrderUpdateEmail(updatedOrder.user.email, updatedOrder.id, status);
            }

            console.log(✅ Order #${id} updated to status: ${status});
            return res.status(200).json(updatedOrder);
        } catch (error: any) {
            console.error("❌ Order update error:", error);
            return res.status(500).json({ error: "Failed to update order." });
        }
    }

    return res.status(405).json({ error: "Method not allowed." });
}
"

Below is an example of a unified ManageOrders component that you can embed in your all‑in‑one Admin Dashboard. This component:

• Fetches orders via an API (or you can pass them via props from SSR).
• Displays a table of orders.
• Allows the admin to click “View / Edit” for an order, which opens an inline modal to update the order status and view order details.

You can adjust the styling and layout as needed.

// components/admin/ManageOrders.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Link from "next/link";

type AdminOrder = {
  id: number;
  status: string;
  totalAmount: string;
  createdAt: string;
  user: {
    email: string;
  } | null;
  shippingAddress?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  orderItems?: any[];
};

export function ManageOrders() {
  const [orders, setOrders] = useState<AdminOrder[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [selectedOrder, setSelectedOrder] = useState<AdminOrder | null>(null);
  const [orderStatus, setOrderStatus] = useState("");
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch orders from an API endpoint
  useEffect(() => {
    async function fetchOrders() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/orders");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch orders.");
        }
        const data = await res.json();
        setOrders(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchOrders();
  }, []);

  // When an order is selected for editing, pre-fill the status field
  function handleOpenOrder(order: AdminOrder) {
    setSelectedOrder(order);
    setOrderStatus(order.status);
    setUpdateMessage("");
  }

  async function handleStatusUpdate() {
    if (!selectedOrder) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/orders/${selectedOrder.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: orderStatus }),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update order.");
      } else {
        setUpdateMessage("Order updated successfully");
        // Update local orders list with new status
        setOrders((prev) =>
          prev.map((o) =>
            o.id === selectedOrder.id ? { ...o, status: orderStatus } : o
          )
        );
      }
    } catch (error) {
      setUpdateMessage("Error updating order");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Gérer les Commandes</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedOrder && <p className="text-platinumGray">Loading...</p>}

      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">User</th>
              <th className="p-3">Status</th>
              <th className="p-3">Total (€)</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {orders.map((order) => (
              <tr
                key={order.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{order.id}</td>
                <td className="p-3">{order.user?.email || "Guest"}</td>
                <td className="p-3 text-center">{order.status}</td>
                <td className="p-3 text-center">€{order.totalAmount}</td>
                <td className="p-3">
                  {new Date(order.createdAt).toLocaleString()}
                </td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => handleOpenOrder(order)}
                    className="button-secondary"
                  >
                    View / Edit
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* ---------------------------
          Order Edit Modal (Inline)
          --------------------------- */}
      <AnimatePresence>
        {selectedOrder && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Éditer Commande #{selectedOrder.id}
              </h2>
              <p className="mb-2">
                <strong>User:</strong> {selectedOrder.user?.email || "Guest"}
              </p>
              <p className="mb-2">
                <strong>Total:</strong> €{selectedOrder.totalAmount}
              </p>
              {selectedOrder.shippingAddress && (
                <p className="mb-2">
                  <strong>Address:</strong> {selectedOrder.shippingAddress},{" "}
                  {selectedOrder.city}, {selectedOrder.postalCode},{" "}
                  {selectedOrder.country}
                </p>
              )}
              <div className="mt-4">
                <label className="block text-lg font-medium text-richEbony mb-2">
                  Update Status
                </label>
                <select
                  className="input-field w-full"
                  value={orderStatus}
                  onChange={(e) => setOrderStatus(e.target.value)}
                  disabled={loading}
                >
                  <option value="PENDING">Pending</option>
                  <option value="CONFIRMED">Confirmed</option>
                  <option value="SHIPPED">Shipped</option>
                  <option value="DELIVERED">Delivered</option>
                  <option value="CANCELLED">Cancelled</option>
                </select>
              </div>
              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}
              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleStatusUpdate}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update Status"}
                </button>
                <button
                  onClick={() => setSelectedOrder(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

Explanation

    Data Fetching:
    The component uses useEffect to fetch orders from /api/admin/orders (you’ll need to create this GET route if you haven’t already). Alternatively, you can pass the orders from SSR as props if you prefer.

    Orders Table:
    Orders are displayed in a table with columns for ID, user, status, total, created date, and an “Actions” column.
    The “View / Edit” button sets the selectedOrder state, which triggers the inline modal.

    Order Edit Modal:
    When an order is selected, an overlay appears (using AnimatePresence from Framer Motion) that shows the order details and a dropdown for updating the order status.
    Clicking “Update Status” calls the API to update the order, and clicking “Close” dismisses the modal.

    Styling:
    Adjust class names such as button-primary and button-secondary as defined in your global CSS to match your luxury design.

This unified ManageOrders component can now be embedded into your admin dashboard’s “Orders” tab, giving you an all‑in‑one experience to view and update orders without navigating to separate pages.
You said:
I am getting : " GET /api/admin/orders 404 in 1089ms
" and "JSON.parse: unexpected character at line 1 column 1 of the JSON data"  in "// components/admin/ManageOrders.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Link from "next/link";

type AdminOrder = {
    id: number;
    status: string;
    totalAmount: string;
    createdAt: string;
    user: {
        email: string;
    } | null;
    shippingAddress?: string | null;
    city?: string | null;
    postalCode?: string | null;
    country?: string | null;
    orderItems?: any[];
};

export function ManageOrders() {
    const [orders, setOrders] = useState<AdminOrder[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState("");
    const [selectedOrder, setSelectedOrder] = useState<AdminOrder | null>(null);
    const [orderStatus, setOrderStatus] = useState("");
    const [updateMessage, setUpdateMessage] = useState("");

    // Fetch orders from an API endpoint
    useEffect(() => {
        async function fetchOrders() {
            setLoading(true);
            setError("");
            try {
                const res = await fetch("/api/admin/orders");
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.error || "Failed to fetch orders.");
                }
                const data = await res.json();
                setOrders(data);
            } catch (err: any) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        }
        fetchOrders();
    }, []);

    // When an order is selected for editing, pre-fill the status field
    function handleOpenOrder(order: AdminOrder) {
        setSelectedOrder(order);
        setOrderStatus(order.status);
        setUpdateMessage("");
    }

    async function handleStatusUpdate() {
        if (!selectedOrder) return;
        setLoading(true);
        setUpdateMessage("");
        try {
            const res = await fetch(/api/admin/orders/${selectedOrder.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ status: orderStatus }),
            });
            const data = await res.json();
            if (!res.ok) {
                setUpdateMessage(data.error || "Failed to update order.");
            } else {
                setUpdateMessage("Order updated successfully");
                // Update local orders list with new status
                setOrders((prev) =>
                    prev.map((o) =>
                        o.id === selectedOrder.id ? { ...o, status: orderStatus } : o
                    )
                );
            }
        } catch (error) {
            setUpdateMessage("Error updating order");
        } finally {
            setLoading(false);
        }
    }

    return (
        <div className="p-6">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Gérer les Commandes</h1>

            {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
            {loading && !selectedOrder && <p className="text-platinumGray">Loading...</p>}

            <div className="overflow-x-auto">
                <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
                    <thead className="bg-burgundy/20 text-brandGold">
                    <tr>
                        <th className="p-3 text-left">ID</th>
                        <th className="p-3 text-left">User</th>
                        <th className="p-3">Status</th>
                        <th className="p-3">Total (€)</th>
                        <th className="p-3">Created</th>
                        <th className="p-3">Actions</th>
                    </tr>
                    </thead>
                    <tbody>
                    {orders.map((order) => (
                        <tr
                            key={order.id}
                            className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
                        >
                            <td className="p-3">{order.id}</td>
                            <td className="p-3">{order.user?.email || "Guest"}</td>
                            <td className="p-3 text-center">{order.status}</td>
                            <td className="p-3 text-center">€{order.totalAmount}</td>
                            <td className="p-3">
                                {new Date(order.createdAt).toLocaleString()}
                            </td>
                            <td className="p-3 text-center">
                                <button
                                    onClick={() => handleOpenOrder(order)}
                                    className="button-secondary"
                                >
                                    View / Edit
                                </button>
                            </td>
                        </tr>
                    ))}
                    </tbody>
                </table>
            </div>

            {/* ---------------------------
          Order Edit Modal (Inline)
          --------------------------- */}
            <AnimatePresence>
                {selectedOrder && (
                    <motion.div
                        initial={{ opacity: 0, y: 50 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: 50 }}
                        transition={{ duration: 0.5 }}
                        className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
                    >
                        <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
                            <h2 className="text-3xl font-serif text-brandGold mb-4">
                                Éditer Commande #{selectedOrder.id}
                            </h2>
                            <p className="mb-2">
                                <strong>User:</strong> {selectedOrder.user?.email || "Guest"}
                            </p>
                            <p className="mb-2">
                                <strong>Total:</strong> €{selectedOrder.totalAmount}
                            </p>
                            {selectedOrder.shippingAddress && (
                                <p className="mb-2">
                                    <strong>Address:</strong> {selectedOrder.shippingAddress},{" "}
                                    {selectedOrder.city}, {selectedOrder.postalCode},{" "}
                                    {selectedOrder.country}
                                </p>
                            )}
                            <div className="mt-4">
                                <label className="block text-lg font-medium text-richEbony mb-2">
                                    Update Status
                                </label>
                                <select
                                    className="input-field w-full"
                                    value={orderStatus}
                                    onChange={(e) => setOrderStatus(e.target.value)}
                                    disabled={loading}
                                >
                                    <option value="PENDING">Pending</option>
                                    <option value="CONFIRMED">Confirmed</option>
                                    <option value="SHIPPED">Shipped</option>
                                    <option value="DELIVERED">Delivered</option>
                                    <option value="CANCELLED">Cancelled</option>
                                </select>
                            </div>
                            {updateMessage && (
                                <p className="text-sm text-burgundy mt-3 font-semibold">
                                    {updateMessage}
                                </p>
                            )}
                            <div className="flex gap-4 mt-6">
                                <button
                                    onClick={handleStatusUpdate}
                                    className="button-primary w-full md:w-auto"
                                    disabled={loading}
                                >
                                    {loading ? "Updating..." : "Update Status"}
                                </button>
                                <button
                                    onClick={() => setSelectedOrder(null)}
                                    className="button-secondary w-full md:w-auto"
                                    disabled={loading}
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}
" api admin order id: "import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";
import { sendOrderUpdateEmail } from "../../../../lib/email";

interface DecodedPayload {
    id: string;
    role: string;
    email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    console.log("🔹 ADMIN ORDER UPDATE ROUTE INITIATED");

    // 🔐 Extract session token manually
    const rawCookie = req.headers.cookie || "";
    let match = rawCookie.match(/next-auth\.session-token=([^;]+)/);
    if (!match) {
        match = rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
        if (!match) {
            console.log("❌ No session token in cookies.");
            return res.status(401).json({ error: "Unauthorized: No session token found." });
        }
    }

    const tokenStr = decodeURIComponent(match[1]);

    // 🔐 Decode JWT token manually
    let payload: DecodedPayload;
    try {
        const secret = process.env.NEXTAUTH_SECRET || "";
        const { payload: decoded } = await jwtVerify(
            tokenStr,
            new TextEncoder().encode(secret)
        );
        console.log("🔹 Decoded JWT Payload:", decoded);
        payload = decoded as unknown as DecodedPayload;
    } catch (err) {
        console.log("❌ JWT Decode Error:", err);
        return res.status(401).json({ error: "Unauthorized: Invalid token." });
    }

    // 🔐 Ensure the user is an admin
    if (payload.role !== "admin") {
        console.log("❌ User is not an admin.");
        return res.status(403).json({ error: "Forbidden: Admin access required." });
    }

    const { id } = req.query;

    if (req.method === "PUT") {
        const { status } = req.body;
        try {
            // ✅ Update the order in the database
            const updatedOrder = await prisma.order.update({
                where: { id: Number(id) },
                data: { status },
                include: { user: true },
            });

            // ✅ Send Email Notification if user email exists
            if (updatedOrder.user?.email) {
                await sendOrderUpdateEmail(updatedOrder.user.email, updatedOrder.id, status);
            }

            console.log(✅ Order #${id} updated to status: ${status});
            return res.status(200).json(updatedOrder);
        } catch (error: any) {
            console.error("❌ Order update error:", error);
            return res.status(500).json({ error: "Failed to update order." });
        }
    }

    return res.status(405).json({ error: "Method not allowed." });
}
"  the component was previously :"// pages/admin/orders/index.tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import Link from "next/link";

type AdminOrder = {
    id: number;
    status: string;
    totalAmount: string;
    createdAt: string;
    user: {
        email: string;
    } | null;
};

export default function OrdersAdminPage({ orders }: { orders: AdminOrder[] }) {
    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Orders</h1>

            {orders.length === 0 ? (
                <p className="text-platinumGray">No orders found.</p>
            ) : (
                <div className="overflow-x-auto">
                    <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
                        <thead className="bg-burgundy/20 text-brandGold">
                        <tr>
                            <th className="p-3 text-left">ID</th>
                            <th className="p-3 text-left">User</th>
                            <th className="p-3">Status</th>
                            <th className="p-3">Total (€)</th>
                            <th className="p-3">Created</th>
                            <th className="p-3">Actions</th>
                        </tr>
                        </thead>
                        <tbody>
                        {orders.map((order) => (
                            <tr
                                key={order.id}
                                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
                            >
                                <td className="p-3">{order.id}</td>
                                <td className="p-3">{order.user?.email ?? "Guest"}</td>
                                <td className="p-3 text-center">{order.status}</td>
                                <td className="p-3 text-center">€{order.totalAmount}</td>
                                <td className="p-3">
                                    {new Date(order.createdAt).toLocaleString()}
                                </td>
                                <td className="p-3 text-center">
                                    <Link href={/admin/orders/${order.id}} className="button-secondary">
                                        View / Edit
                                    </Link>
                                </td>
                            </tr>
                        ))}
                        </tbody>
                    </table>
                </div>
            )}
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: { destination: "/", permanent: false },
        };
    }

    const rawOrders = await prisma.order.findMany({
        include: { user: true },
        orderBy: { createdAt: "desc" },
    });

    return {
        props: { orders: JSON.parse(JSON.stringify(rawOrders)) },
    };
};
"  "// pages/admin/orders/[id].tsx
import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { prisma } from "../../../lib/prisma";
import { useState } from "react";

type OrderEditProps = {
    orderData: any;
};

export default function OrderEditPage({ orderData }: OrderEditProps) {
    const [orderStatus, setOrderStatus] = useState(orderData.status);
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState("");

    async function handleStatusUpdate() {
        setLoading(true);
        setMessage("");

        try {
            const res = await fetch(/api/admin/orders/${orderData.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ status: orderStatus }),
            });

            const data = await res.json();
            if (!res.ok) {
                setMessage(data.error || "Failed to update order");
            } else {
                setMessage("Order updated successfully");
            }
        } catch (error) {
            setMessage("Error updating order");
        } finally {
            setLoading(false);
        }
    }

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-4xl font-serif text-brandGold mb-6">
                Editing Order #{orderData.id}
            </h1>
            {message && <p className="text-burgundy mb-4 font-semibold">{message}</p>}

            {/* Order Info */}
            <div className="bg-burgundy/10 p-6 rounded-lg shadow-luxury space-y-3">
                <p>
                    <strong>User:</strong> {orderData.user?.email || "Guest"}
                </p>
                <p>
                    <strong>Created At:</strong>{" "}
                    {new Date(orderData.createdAt).toLocaleString()}
                </p>
                <p>
                    <strong>Address:</strong> {orderData.shippingAddress}, {orderData.city}{" "}
                    {orderData.postalCode}, {orderData.country}
                </p>
                <p>
                    <strong>Total:</strong> €{orderData.totalAmount}
                </p>

                {/* Update Status */}
                <div className="mt-4">
                    <label className="block text-lg font-medium text-richEbony mb-2">
                        Update Status
                    </label>
                    <select
                        className="input-field w-full max-w-sm"
                        value={orderStatus}
                        onChange={(e) => setOrderStatus(e.target.value)}
                        disabled={loading}
                    >
                        <option value="PENDING">Pending</option>
                        <option value="CONFIRMED">Confirmed</option>
                        <option value="SHIPPED">Shipped</option>
                        <option value="DELIVERED">Delivered</option>
                        <option value="CANCELLED">Cancelled</option>
                    </select>
                </div>

                <button
                    onClick={handleStatusUpdate}
                    className="button-primary w-full md:w-auto mt-4"
                    disabled={loading}
                >
                    {loading ? "Updating..." : "Update Status"}
                </button>
            </div>

            {/* Order Items */}
            <h2 className="text-3xl font-serif text-brandGold mt-8 mb-4">
                Order Items
            </h2>
            <ul className="space-y-4">
                {orderData.orderItems.map((item: any) => {
                    const productName =
                        item.product.translations.find((t: any) => t.language === "en")
                            ?.name || "Unnamed Product";

                    return (
                        <li
                            key={item.id}
                            className="bg-burgundy/10 p-4 rounded-md shadow-subtle"
                        >
                            <p>
                                <strong>{productName}</strong>
                            </p>
                            <p>SKU: {item.product.sku}</p>
                            <p>Quantity: {item.quantity}</p>
                            <p>Price: €{parseFloat(item.price).toFixed(2)}</p>
                        </li>
                    );
                })}
            </ul>
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const { id } = context.params!;
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return { redirect: { destination: "/", permanent: false } };
    }

    const rawOrder = await prisma.order.findUnique({
        where: { id: Number(id) },
        include: {
            user: true,
            orderItems: {
                include: {
                    product: {
                        include: { translations: true },
                    },
                },
            },
        },
    });

    if (!rawOrder) {
        return { notFound: true };
    }

    return {
        props: { orderData: JSON.parse(JSON.stringify(rawOrder)) },
    };
};
"

Below is a unified ManageOrders component that combines listing orders and editing order status into a single view. This component fetches orders from a GET endpoint (which you’ll need to implement if not already available), displays them in a table, and lets the admin open an inline modal to update an order’s status (using the same API for updating as before). You can embed this component in your unified admin dashboard.

// components/admin/ManageOrders.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Link from "next/link";

type AdminOrder = {
  id: number;
  status: string;
  totalAmount: string;
  createdAt: string;
  user: {
    email: string;
  } | null;
  shippingAddress?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  orderItems?: any[];
};

export function ManageOrders() {
  const [orders, setOrders] = useState<AdminOrder[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [selectedOrder, setSelectedOrder] = useState<AdminOrder | null>(null);
  const [orderStatus, setOrderStatus] = useState("");
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch orders from the API endpoint
  useEffect(() => {
    async function fetchOrders() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/orders"); // Ensure this GET route exists
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch orders.");
        }
        const data = await res.json();
        setOrders(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchOrders();
  }, []);

  // When an order is selected for editing, pre-fill the status field
  function handleOpenOrder(order: AdminOrder) {
    setSelectedOrder(order);
    setOrderStatus(order.status);
    setUpdateMessage("");
  }

  // Update order status using API route /api/admin/orders/[id]
  async function handleStatusUpdate() {
    if (!selectedOrder) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/orders/${selectedOrder.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: orderStatus }),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update order.");
      } else {
        setUpdateMessage("Order updated successfully");
        // Update local orders list with new status
        setOrders((prev) =>
          prev.map((o) =>
            o.id === selectedOrder.id ? { ...o, status: orderStatus } : o
          )
        );
      }
    } catch (error) {
      setUpdateMessage("Error updating order");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">
        Gérer les Commandes
      </h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedOrder && <p className="text-platinumGray">Loading...</p>}

      {/* Orders Table */}
      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">User</th>
              <th className="p-3">Status</th>
              <th className="p-3">Total (€)</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {orders.map((order) => (
              <tr
                key={order.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{order.id}</td>
                <td className="p-3">{order.user?.email || "Guest"}</td>
                <td className="p-3 text-center">{order.status}</td>
                <td className="p-3 text-center">€{order.totalAmount}</td>
                <td className="p-3">
                  {new Date(order.createdAt).toLocaleString()}
                </td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => handleOpenOrder(order)}
                    className="button-secondary"
                  >
                    View / Edit
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Order Edit Modal */}
      <AnimatePresence>
        {selectedOrder && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Éditer Commande #{selectedOrder.id}
              </h2>
              <p className="mb-2">
                <strong>User:</strong> {selectedOrder.user?.email || "Guest"}
              </p>
              <p className="mb-2">
                <strong>Total:</strong> €{selectedOrder.totalAmount}
              </p>
              {selectedOrder.shippingAddress && (
                <p className="mb-2">
                  <strong>Address:</strong> {selectedOrder.shippingAddress},{" "}
                  {selectedOrder.city}, {selectedOrder.postalCode},{" "}
                  {selectedOrder.country}
                </p>
              )}
              <div className="mt-4">
                <label className="block text-lg font-medium text-richEbony mb-2">
                  Update Status
                </label>
                <select
                  className="input-field w-full"
                  value={orderStatus}
                  onChange={(e) => setOrderStatus(e.target.value)}
                  disabled={loading}
                >
                  <option value="PENDING">Pending</option>
                  <option value="CONFIRMED">Confirmed</option>
                  <option value="SHIPPED">Shipped</option>
                  <option value="DELIVERED">Delivered</option>
                  <option value="CANCELLED">Cancelled</option>
                </select>
              </div>
              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}
              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleStatusUpdate}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update Status"}
                </button>
                <button
                  onClick={() => setSelectedOrder(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

Key Points

    Data Fetching:
    The component uses useEffect to fetch orders from /api/admin/orders (you’ll need to implement this GET endpoint similar to the products endpoint).

    Orders Table:
    Displays orders with columns for ID, user email, status, total, created date, and an actions column with a “View / Edit” button.

    Inline Modal for Editing:
    Clicking “View / Edit” opens an overlay (using Framer Motion’s AnimatePresence) that shows order details and a dropdown for updating the status. When updated, the component calls your existing PUT API (e.g., /api/admin/orders/[id]) to update the order in the database.

    Error Handling & Loading States:
    Basic error messages and loading indicators are included.

This unified ManageOrders component can now be imported into your unified admin dashboard and used as the “Orders” tab. You can similarly convert your products and categories pages into components for a consolidated admin experience.
You said:
still get : "JSON.parse: unexpected character at line 1 column 1 of the JSON data"  " GET /api/admin/orders 404 in 159ms

" "// components/admin/ManageOrders.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Link from "next/link";

type AdminOrder = {
    id: number;
    status: string;
    totalAmount: string;
    createdAt: string;
    user: {
        email: string;
    } | null;
    shippingAddress?: string | null;
    city?: string | null;
    postalCode?: string | null;
    country?: string | null;
    orderItems?: any[];
};

export function ManageOrders() {
    const [orders, setOrders] = useState<AdminOrder[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState("");
    const [selectedOrder, setSelectedOrder] = useState<AdminOrder | null>(null);
    const [orderStatus, setOrderStatus] = useState("");
    const [updateMessage, setUpdateMessage] = useState("");

    // Fetch orders from the API endpoint
    useEffect(() => {
        async function fetchOrders() {
            setLoading(true);
            setError("");
            try {
                const res = await fetch("/api/admin/orders"); // Ensure this GET route exists
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.error || "Failed to fetch orders.");
                }
                const data = await res.json();
                setOrders(data);
            } catch (err: any) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        }
        fetchOrders();
    }, []);

    // When an order is selected for editing, pre-fill the status field
    function handleOpenOrder(order: AdminOrder) {
        setSelectedOrder(order);
        setOrderStatus(order.status);
        setUpdateMessage("");
    }

    // Update order status using API route /api/admin/orders/[id]
    async function handleStatusUpdate() {
        if (!selectedOrder) return;
        setLoading(true);
        setUpdateMessage("");
        try {
            const res = await fetch(/api/admin/orders/${selectedOrder.id}, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ status: orderStatus }),
            });
            const data = await res.json();
            if (!res.ok) {
                setUpdateMessage(data.error || "Failed to update order.");
            } else {
                setUpdateMessage("Order updated successfully");
                // Update local orders list with new status
                setOrders((prev) =>
                    prev.map((o) =>
                        o.id === selectedOrder.id ? { ...o, status: orderStatus } : o
                    )
                );
            }
        } catch (error) {
            setUpdateMessage("Error updating order");
        } finally {
            setLoading(false);
        }
    }

    return (
        <div className="p-6">
            <h1 className="text-4xl font-serif text-brandGold mb-6">
                Gérer les Commandes
            </h1>

            {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
            {loading && !selectedOrder && <p className="text-platinumGray">Loading...</p>}

            {/* Orders Table */}
            <div className="overflow-x-auto">
                <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
                    <thead className="bg-burgundy/20 text-brandGold">
                    <tr>
                        <th className="p-3 text-left">ID</th>
                        <th className="p-3 text-left">User</th>
                        <th className="p-3">Status</th>
                        <th className="p-3">Total (€)</th>
                        <th className="p-3">Created</th>
                        <th className="p-3">Actions</th>
                    </tr>
                    </thead>
                    <tbody>
                    {orders.map((order) => (
                        <tr
                            key={order.id}
                            className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
                        >
                            <td className="p-3">{order.id}</td>
                            <td className="p-3">{order.user?.email || "Guest"}</td>
                            <td className="p-3 text-center">{order.status}</td>
                            <td className="p-3 text-center">€{order.totalAmount}</td>
                            <td className="p-3">
                                {new Date(order.createdAt).toLocaleString()}
                            </td>
                            <td className="p-3 text-center">
                                <button
                                    onClick={() => handleOpenOrder(order)}
                                    className="button-secondary"
                                >
                                    View / Edit
                                </button>
                            </td>
                        </tr>
                    ))}
                    </tbody>
                </table>
            </div>

            {/* Inline Order Edit Modal */}
            <AnimatePresence>
                {selectedOrder && (
                    <motion.div
                        initial={{ opacity: 0, y: 50 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: 50 }}
                        transition={{ duration: 0.5 }}
                        className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
                    >
                        <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
                            <h2 className="text-3xl font-serif text-brandGold mb-4">
                                Éditer Commande #{selectedOrder.id}
                            </h2>
                            <p className="mb-2">
                                <strong>User:</strong> {selectedOrder.user?.email || "Guest"}
                            </p>
                            <p className="mb-2">
                                <strong>Total:</strong> €{selectedOrder.totalAmount}
                            </p>
                            {selectedOrder.shippingAddress && (
                                <p className="mb-2">
                                    <strong>Address:</strong> {selectedOrder.shippingAddress},{" "}
                                    {selectedOrder.city}, {selectedOrder.postalCode},{" "}
                                    {selectedOrder.country}
                                </p>
                            )}
                            <div className="mt-4">
                                <label className="block text-lg font-medium text-richEbony mb-2">
                                    Update Status
                                </label>
                                <select
                                    className="input-field w-full"
                                    value={orderStatus}
                                    onChange={(e) => setOrderStatus(e.target.value)}
                                    disabled={loading}
                                >
                                    <option value="PENDING">Pending</option>
                                    <option value="CONFIRMED">Confirmed</option>
                                    <option value="SHIPPED">Shipped</option>
                                    <option value="DELIVERED">Delivered</option>
                                    <option value="CANCELLED">Cancelled</option>
                                </select>
                            </div>
                            {updateMessage && (
                                <p className="text-sm text-burgundy mt-3 font-semibold">
                                    {updateMessage}
                                </p>
                            )}
                            <div className="flex gap-4 mt-6">
                                <button
                                    onClick={handleStatusUpdate}
                                    className="button-primary w-full md:w-auto"
                                    disabled={loading}
                                >
                                    {loading ? "Updating..." : "Update Status"}
                                </button>
                                <button
                                    onClick={() => setSelectedOrder(null)}
                                    className="button-secondary w-full md:w-auto"
                                    disabled={loading}
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}
"
2/2

Below is an updated solution that does two things:

    Creates a GET API endpoint for orders at pages/api/admin/orders/index.ts so your unified component can fetch orders.
    Provides the unified ManageOrders component that calls that endpoint.

1. API Endpoint for Orders

Create a file at pages/api/admin/orders/index.ts with the following code. This endpoint will verify the admin token (using manual token parsing with jose), then return all orders (including user info):

// pages/api/admin/orders/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- ADMIN ORDER GET ROUTE START ---");

  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  try {
    // ----- Extract and verify admin session token -----
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    // ----- Fetch orders from the database
    const orders = await prisma.order.findMany({
      include: { user: true },
      orderBy: { createdAt: "desc" },
    });

    console.log("✅ Orders fetched successfully");
    return res.status(200).json(orders);
  } catch (error: any) {
    console.error("❌ API Error:", error);
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

2. Unified ManageOrders Component

Below is the updated ManageOrders component that fetches orders from /api/admin/orders and displays them in a table. It includes an inline modal for editing order status (using your existing PUT route at /api/admin/orders/[id]):

// components/admin/ManageOrders.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

type AdminOrder = {
  id: number;
  status: string;
  totalAmount: string;
  createdAt: string;
  user: {
    email: string;
  } | null;
  shippingAddress?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  orderItems?: any[];
};

export function ManageOrders() {
  const [orders, setOrders] = useState<AdminOrder[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [selectedOrder, setSelectedOrder] = useState<AdminOrder | null>(null);
  const [orderStatus, setOrderStatus] = useState("");
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch orders from the API endpoint
  useEffect(() => {
    async function fetchOrders() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/orders");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch orders.");
        }
        const data = await res.json();
        setOrders(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchOrders();
  }, []);

  // When an order is selected for editing, pre-fill the status field
  function handleOpenOrder(order: AdminOrder) {
    setSelectedOrder(order);
    setOrderStatus(order.status);
    setUpdateMessage("");
  }

  // Update order status using the PUT API route at /api/admin/orders/[id]
  async function handleStatusUpdate() {
    if (!selectedOrder) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/orders/${selectedOrder.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: orderStatus }),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update order.");
      } else {
        setUpdateMessage("Order updated successfully");
        // Update local orders list with new status
        setOrders((prev) =>
          prev.map((o) =>
            o.id === selectedOrder.id ? { ...o, status: orderStatus } : o
          )
        );
      }
    } catch (error) {
      setUpdateMessage("Error updating order");
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">
        Gérer les Commandes
      </h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedOrder && <p className="text-platinumGray">Loading...</p>}

      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">User</th>
              <th className="p-3">Status</th>
              <th className="p-3">Total (€)</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {orders.map((order) => (
              <tr
                key={order.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{order.id}</td>
                <td className="p-3">{order.user?.email || "Guest"}</td>
                <td className="p-3 text-center">{order.status}</td>
                <td className="p-3 text-center">€{order.totalAmount}</td>
                <td className="p-3">
                  {new Date(order.createdAt).toLocaleString()}
                </td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => handleOpenOrder(order)}
                    className="button-secondary"
                  >
                    View / Edit
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Order Edit Modal */}
      <AnimatePresence>
        {selectedOrder && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Éditer Commande #{selectedOrder.id}
              </h2>
              <p className="mb-2">
                <strong>User:</strong> {selectedOrder.user?.email || "Guest"}
              </p>
              <p className="mb-2">
                <strong>Total:</strong> €{selectedOrder.totalAmount}
              </p>
              {selectedOrder.shippingAddress && (
                <p className="mb-2">
                  <strong>Address:</strong> {selectedOrder.shippingAddress},{" "}
                  {selectedOrder.city}, {selectedOrder.postalCode},{" "}
                  {selectedOrder.country}
                </p>
              )}
              <div className="mt-4">
                <label className="block text-lg font-medium text-richEbony mb-2">
                  Update Status
                </label>
                <select
                  className="input-field w-full"
                  value={orderStatus}
                  onChange={(e) => setOrderStatus(e.target.value)}
                  disabled={loading}
                >
                  <option value="PENDING">Pending</option>
                  <option value="CONFIRMED">Confirmed</option>
                  <option value="SHIPPED">Shipped</option>
                  <option value="DELIVERED">Delivered</option>
                  <option value="CANCELLED">Cancelled</option>
                </select>
              </div>
              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}
              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleStatusUpdate}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update Status"}
                </button>
                <button
                  onClick={() => setSelectedOrder(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

Notes

    Ensure the GET API endpoint exists:
    The GET route at /api/admin/orders must be defined (see the API snippet above). This will eliminate the 404 error and the JSON parse error.

    Token Authentication:
    Both the product and order API routes perform manual token verification. Ensure your environment variable NEXTAUTH_SECRET is properly set.

    Unified Admin Dashboard:
    You can now import <ManageOrders /> into your main admin dashboard page and toggle between the products, categories, and orders components.

This approach should resolve your 404/JSON parsing errors and give you a consolidated, unified admin orders management component.
You said:
let's resume what we did so far on the admin dashboard
7/7

Below is a summary of what we've built so far for the Diamant Rouge Admin Dashboard:

    Unified Dashboard Concept
    We consolidated different management systems (Products, Categories, Orders) into a single, tab-based dashboard. This gives the admin a unified experience where they can toggle between sections without leaving the page.

    Product Management
        We combined product listing, creation, editing, and deletion into one component (ManageProducts).
        API endpoints were updated to handle GET (listing) and POST (creation) methods, with separate endpoints for PUT/DELETE for individual products.
        The component uses client‑side fetch calls to retrieve products and update the local state after any changes.

    Categories Management
        We converted the categories management page into a component (ManageCategories) that can be embedded in the dashboard.
        This component allows the admin to create new categories (with translations), edit existing ones, and delete them.
        It interacts with your API routes (/api/admin/categories for GET/POST and /api/admin/categories/[id] for PUT/DELETE).

    Orders Management
        We built a unified ManageOrders component that lists all orders in a table and lets the admin open an inline modal for editing order status.
        A new API endpoint (/api/admin/orders) was implemented to handle GET requests (listing orders), while PUT and DELETE are handled in separate endpoints.
        The inline modal allows for quick order status updates and reflects changes immediately in the local state.

    Security & Token Verification
        All API routes manually extract and verify the admin’s session token using jose and your NEXTAUTH_SECRET.
        This ensures that only authenticated admin users can perform create, update, or delete operations.

    Unified Experience & Reusability
        The unified components are designed to be embedded within your main admin dashboard (e.g., in a tab system).
        This creates a seamless Single Page Application (SPA) feel, while still allowing for deeper routes if necessary.

These changes provide a modern, efficient, and unified admin interface for managing products, categories, and orders, in line with the luxury branding of Diamant Rouge.
You said:
I wont to implement a user management system to the other managements systemson the unified admn dashboard

Below is a complete unified User Management solution for your Diamant Rouge admin dashboard. This solution includes:

    A ManageUsers component that:
        Fetches the list of users from an API endpoint.
        Displays users in a table with basic info (ID, email, name, role, created date).
        Provides inline controls to update the user’s role (and delete a user) via an inline modal.

    API endpoints for user management (GET, PUT, DELETE) that perform manual token verification (using jose) to ensure only admin users have access.

You can integrate the ManageUsers component into your unified admin dashboard along with your products, categories, and orders components.
1. ManageUsers Component

// components/admin/ManageUsers.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

type AdminUser = {
  id: number;
  email: string;
  name?: string | null;
  role: string;
  createdAt: string;
};

export function ManageUsers() {
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  const [editRole, setEditRole] = useState("");
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch users from API endpoint
  useEffect(() => {
    async function fetchUsers() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/users");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch users.");
        }
        const data = await res.json();
        setUsers(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Open a user for editing
  function handleOpenUser(user: AdminUser) {
    setSelectedUser(user);
    setEditRole(user.role);
    setUpdateMessage("");
  }

  // Update the user's role
  async function handleUpdateUser() {
    if (!selectedUser) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/users/${selectedUser.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ role: editRole }),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update user.");
      } else {
        setUpdateMessage("User updated successfully");
        setUsers((prev) =>
          prev.map((u) =>
            u.id === selectedUser.id ? { ...u, role: editRole } : u
          )
        );
      }
    } catch (err: any) {
      setUpdateMessage("Error updating user");
    } finally {
      setLoading(false);
    }
  }

  // Delete user
  async function handleDeleteUser(userId: number) {
    if (!window.confirm("Are you sure you want to delete this user?")) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/admin/users/${userId}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete user");
      }
      setUsers((prev) => prev.filter((u) => u.id !== userId));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Users</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedUser && <p className="text-platinumGray">Loading...</p>}

      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">Email</th>
              <th className="p-3 text-left">Name</th>
              <th className="p-3 text-center">Role</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr
                key={user.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{user.id}</td>
                <td className="p-3">{user.email}</td>
                <td className="p-3">{user.name || "-"}</td>
                <td className="p-3 text-center">{user.role}</td>
                <td className="p-3">
                  {new Date(user.createdAt).toLocaleString()}
                </td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => handleOpenUser(user)}
                    className="button-secondary mr-3"
                  >
                    View / Edit
                  </button>
                  <button
                    onClick={() => handleDeleteUser(user.id)}
                    className="button-secondary"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Edit Modal */}
      <AnimatePresence>
        {selectedUser && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Edit User #{selectedUser.id}
              </h2>
              <p className="mb-2">
                <strong>Email:</strong> {selectedUser.email}
              </p>
              <div className="mt-4">
                <label className="block text-lg font-medium text-richEbony mb-2">
                  Role
                </label>
                <select
                  className="input-field w-full"
                  value={editRole}
                  onChange={(e) => setEditRole(e.target.value)}
                >
                  <option value="customer">Customer</option>
                  <option value="admin">Admin</option>
                </select>
              </div>
              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}
              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleUpdateUser}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update User"}
                </button>
                <button
                  onClick={() => setSelectedUser(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

2. API Endpoints for User Management

Make sure you have the following API routes implemented:
GET /api/admin/users/index.ts

// pages/api/admin/users/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true,
      },
      orderBy: { createdAt: "desc" },
    });
    return res.status(200).json(users);
  } catch (error: any) {
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

PUT /api/admin/users/[id].ts

// pages/api/admin/users/[id].ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;
  if (!id) return res.status(400).json({ error: "User ID is required" });

  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    if (req.method === "PUT") {
      const { role } = req.body;
      const updatedUser = await prisma.user.update({
        where: { id: Number(id) },
        data: { role },
      });
      return res.status(200).json(updatedUser);
    }
    if (req.method === "DELETE") {
      await prisma.user.delete({
        where: { id: Number(id) },
      });
      return res.status(200).json({ message: "User deleted successfully" });
    }
    return res.status(405).json({ error: "Method Not Allowed" });
  } catch (error: any) {
    return res.status(500).json({ error: error.message || "Internal Server Error" });
  }
}

Summary

    ManageUsers Component:
        Fetches the list of users from /api/admin/users (GET endpoint).
        Displays users in a table.
        Provides inline modal editing for user role via a PUT request to /api/admin/users/[id].
        Provides a delete button to remove a user using a DELETE request to /api/admin/users/[id].

    API Endpoints:
        A GET endpoint in pages/api/admin/users/index.ts returns the list of users.
        A PUT/DELETE endpoint in pages/api/admin/users/[id].ts handles updating and deleting users.

You can now integrate this unified ManageUsers component into your all‑in‑one admin dashboard along with the products, categories, and orders components. This gives you a centralized admin interface for managing all backend entities in your Diamant Rouge system.
You said:
I wont the user management system to be pretty more relevant and efficient , managing the users on they're whole attributes based on they're database table attribute : "// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}"

Below is a unified ManageUsers solution for your admin dashboard. This component:

    Fetches all users with their full attributes (email, name, role, phone, address, etc.) from your database via a dedicated GET API endpoint.
    Displays users in a responsive table.
    Provides inline controls (via a modal) for editing each user’s attributes (name, role, phone, address, city, postal code, country).
    Supports deleting users.
    Uses manual token verification in the API endpoints to ensure only admin users can manage users.

You can integrate this component as another tab (e.g., “Users”) in your unified admin dashboard.
ManageUsers Component

// components/admin/ManageUsers.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

type AdminUser = {
  id: number;
  email: string;
  name?: string | null;
  role: string;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  createdAt: string;
};

export function ManageUsers() {
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  
  // State for the inline edit modal
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  const [formData, setFormData] = useState<Partial<AdminUser>>({});
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch users from API
  useEffect(() => {
    async function fetchUsers() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/users");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch users.");
        }
        const data = await res.json();
        setUsers(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Open modal for editing a user, pre-filling formData with all attributes
  function openEditModal(user: AdminUser) {
    setSelectedUser(user);
    setFormData({
      name: user.name || "",
      role: user.role,
      phoneNumber: user.phoneNumber || "",
      address: user.address || "",
      city: user.city || "",
      postalCode: user.postalCode || "",
      country: user.country || "",
    });
    setUpdateMessage("");
  }

  // Handle form input changes
  function handleInputChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  }

  // Update user attributes via API (PUT request)
  async function handleUpdateUser() {
    if (!selectedUser) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/users/${selectedUser.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update user.");
      } else {
        setUpdateMessage("User updated successfully");
        // Update local user list
        setUsers((prev) =>
          prev.map((u) =>
            u.id === selectedUser.id ? { ...u, ...formData } : u
          )
        );
      }
    } catch (err: any) {
      setUpdateMessage("Error updating user");
    } finally {
      setLoading(false);
    }
  }

  // Delete a user via API (DELETE request)
  async function handleDeleteUser(userId: number) {
    if (!window.confirm("Are you sure you want to delete this user?")) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/admin/users/${userId}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete user");
      }
      setUsers((prev) => prev.filter((u) => u.id !== userId));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Users</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedUser && <p className="text-platinumGray">Loading...</p>}

      {/* Users Table */}
      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">Email</th>
              <th className="p-3 text-left">Name</th>
              <th className="p-3 text-center">Role</th>
              <th className="p-3 text-left">Phone</th>
              <th className="p-3 text-left">Address</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr
                key={user.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{user.id}</td>
                <td className="p-3">{user.email}</td>
                <td className="p-3">{user.name || "-"}</td>
                <td className="p-3 text-center">{user.role}</td>
                <td className="p-3">{user.phoneNumber || "-"}</td>
                <td className="p-3">
                  {user.address || "-"}
                  {user.city ? `, ${user.city}` : ""}
                  {user.postalCode ? `, ${user.postalCode}` : ""}
                  {user.country ? `, ${user.country}` : ""}
                </td>
                <td className="p-3">{new Date(user.createdAt).toLocaleString()}</td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => openEditModal(user)}
                    className="button-secondary mr-3"
                  >
                    View / Edit
                  </button>
                  <button
                    onClick={() => handleDeleteUser(user.id)}
                    className="button-secondary"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Edit Modal */}
      <AnimatePresence>
        {selectedUser && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Edit User #{selectedUser.id}
              </h2>
              <p className="mb-2">
                <strong>Email:</strong> {selectedUser.email}
              </p>
              <div className="mt-4 space-y-4">
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Name
                  </label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Role
                  </label>
                  <select
                    name="role"
                    value={formData.role || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  >
                    <option value="customer">Customer</option>
                    <option value="admin">Admin</option>
                  </select>
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Phone Number
                  </label>
                  <input
                    type="text"
                    name="phoneNumber"
                    value={formData.phoneNumber || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Address
                  </label>
                  <input
                    type="text"
                    name="address"
                    value={formData.address || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div className="flex gap-4">
                  <div className="flex-1">
                    <label className="block text-lg font-medium text-richEbony">
                      City
                    </label>
                    <input
                      type="text"
                      name="city"
                      value={formData.city || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </div>
                  <div className="flex-1">
                    <label className="block text-lg font-medium text-richEbony">
                      Postal Code
                    </label>
                    <input
                      type="text"
                      name="postalCode"
                      value={formData.postalCode || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Country
                  </label>
                  <input
                    type="text"
                    name="country"
                    value={formData.country || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
              </div>

              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}

              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleUpdateUser}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update User"}
                </button>
                <button
                  onClick={() => setSelectedUser(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

API Endpoints for Users
GET /api/admin/users/index.ts

// pages/api/admin/users/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        phoneNumber: true,
        address: true,
        city: true,
        postalCode: true,
        country: true,
        createdAt: true,
      },
      orderBy: { createdAt: "desc" },
    });
    return res.status(200).json(users);
  } catch (error: any) {
    return res
      .status(401)
      .json({ error: error.message || "Unauthorized request" });
  }
}

PUT /api/admin/users/[id].ts

// pages/api/admin/users/[id].ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;
  if (!id) return res.status(400).json({ error: "User ID is required" });

  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    if (req.method === "PUT") {
      const { name, role, phoneNumber, address, city, postalCode, country } = req.body;
      const updatedUser = await prisma.user.update({
        where: { id: Number(id) },
        data: { name, role, phoneNumber, address, city, postalCode, country },
      });
      return res.status(200).json(updatedUser);
    }

    if (req.method === "DELETE") {
      await prisma.user.delete({
        where: { id: Number(id) },
      });
      return res.status(200).json({ message: "User deleted successfully" });
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  } catch (error: any) {
    return res.status(500).json({
      error: error.message || "Internal Server Error",
    });
  }
}

Summary

    The ManageUsers component now displays a complete table of users with all attributes from your User model (email, name, role, phone, address, etc.).
    Admins can edit these attributes via an inline modal (which sends a PUT request) or delete a user via a DELETE request.
    API endpoints for GET and PUT/DELETE are implemented with manual token verification to ensure admin-only access.
    This component can be integrated into your unified admin dashboard along with your products, categories, and orders components.

This unified user management system is now optimized to manage users based on all attributes from your database.
You said:
view edit on a user should show all existing informations about the respective customer as they're already registered adress orders wishlists and any other relevant information where the admin can read create update and delelte on any information : "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
" "// components/admin/ManageUsers.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

type AdminUser = {
  id: number;
  email: string;
  name?: string | null;
  role: string;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  createdAt: string;
};

export function ManageUsers() {
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  
  // State for the inline edit modal
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  const [formData, setFormData] = useState<Partial<AdminUser>>({});
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch users from API
  useEffect(() => {
    async function fetchUsers() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/users");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch users.");
        }
        const data = await res.json();
        setUsers(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Open modal for editing a user, pre-filling formData with all attributes
  function openEditModal(user: AdminUser) {
    setSelectedUser(user);
    setFormData({
      name: user.name || "",
      role: user.role,
      phoneNumber: user.phoneNumber || "",
      address: user.address || "",
      city: user.city || "",
      postalCode: user.postalCode || "",
      country: user.country || "",
    });
    setUpdateMessage("");
  }

  // Handle form input changes
  function handleInputChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  }

  // Update user attributes via API (PUT request)
  async function handleUpdateUser() {
    if (!selectedUser) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(/api/admin/users/${selectedUser.id}, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update user.");
      } else {
        setUpdateMessage("User updated successfully");
        // Update local user list
        setUsers((prev) =>
          prev.map((u) =>
            u.id === selectedUser.id ? { ...u, ...formData } : u
          )
        );
      }
    } catch (err: any) {
      setUpdateMessage("Error updating user");
    } finally {
      setLoading(false);
    }
  }

  // Delete a user via API (DELETE request)
  async function handleDeleteUser(userId: number) {
    if (!window.confirm("Are you sure you want to delete this user?")) return;
    setLoading(true);
    try {
      const res = await fetch(/api/admin/users/${userId}, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete user");
      }
      setUsers((prev) => prev.filter((u) => u.id !== userId));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Users</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedUser && <p className="text-platinumGray">Loading...</p>}

      {/* Users Table */}
      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">Email</th>
              <th className="p-3 text-left">Name</th>
              <th className="p-3 text-center">Role</th>
              <th className="p-3 text-left">Phone</th>
              <th className="p-3 text-left">Address</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr
                key={user.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{user.id}</td>
                <td className="p-3">{user.email}</td>
                <td className="p-3">{user.name || "-"}</td>
                <td className="p-3 text-center">{user.role}</td>
                <td className="p-3">{user.phoneNumber || "-"}</td>
                <td className="p-3">
                  {user.address || "-"}
                  {user.city ? , ${user.city} : ""}
                  {user.postalCode ? , ${user.postalCode} : ""}
                  {user.country ? , ${user.country} : ""}
                </td>
                <td className="p-3">{new Date(user.createdAt).toLocaleString()}</td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => openEditModal(user)}
                    className="button-secondary mr-3"
                  >
                    View / Edit
                  </button>
                  <button
                    onClick={() => handleDeleteUser(user.id)}
                    className="button-secondary"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Edit Modal */}
      <AnimatePresence>
        {selectedUser && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-lg">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                Edit User #{selectedUser.id}
              </h2>
              <p className="mb-2">
                <strong>Email:</strong> {selectedUser.email}
              </p>
              <div className="mt-4 space-y-4">
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Name
                  </label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Role
                  </label>
                  <select
                    name="role"
                    value={formData.role || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  >
                    <option value="customer">Customer</option>
                    <option value="admin">Admin</option>
                  </select>
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Phone Number
                  </label>
                  <input
                    type="text"
                    name="phoneNumber"
                    value={formData.phoneNumber || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Address
                  </label>
                  <input
                    type="text"
                    name="address"
                    value={formData.address || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
                <div className="flex gap-4">
                  <div className="flex-1">
                    <label className="block text-lg font-medium text-richEbony">
                      City
                    </label>
                    <input
                      type="text"
                      name="city"
                      value={formData.city || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </div>
                  <div className="flex-1">
                    <label className="block text-lg font-medium text-richEbony">
                      Postal Code
                    </label>
                    <input
                      type="text"
                      name="postalCode"
                      value={formData.postalCode || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-lg font-medium text-richEbony">
                    Country
                  </label>
                  <input
                    type="text"
                    name="country"
                    value={formData.country || ""}
                    onChange={handleInputChange}
                    className="input-field w-full"
                  />
                </div>
              </div>

              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}

              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleUpdateUser}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update User"}
                </button>
                <button
                  onClick={() => setSelectedUser(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
"  "// pages/api/admin/users/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true,
      },
      orderBy: { createdAt: "desc" },
    });
    return res.status(200).json(users);
  } catch (error: any) {
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}
"  "// pages/api/admin/users/[id].ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;
  if (!id) return res.status(400).json({ error: "User ID is required" });

  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    if (req.method === "PUT") {
      const { name, role, phoneNumber, address, city, postalCode, country } = req.body;
      const updatedUser = await prisma.user.update({
        where: { id: Number(id) },
        data: { name, role, phoneNumber, address, city, postalCode, country },
      });
      return res.status(200).json(updatedUser);
    }

    if (req.method === "DELETE") {
      await prisma.user.delete({
        where: { id: Number(id) },
      });
      return res.status(200).json({ message: "User deleted successfully" });
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  } catch (error: any) {
    return res.status(500).json({
      error: error.message || "Internal Server Error",
    });
  }
}
" "// pages/admin/index.tsx

import { GetServerSideProps } from "next";
import { getSession } from "next-auth/react";
import { useState } from "react";
import { ManageProducts } from "../../components/admin/ManageProducts";
import { ManageCategories } from "../../components/admin/ManageCategories";
import { ManageOrders } from "../../components/admin/ManageOrders";
import { ManageUsers } from "../../components/admin/ManageUsers";

// Example placeholders for your sub-sections




export default function AdminDashboard() {
    // Manage which tab is currently active
    const [activeTab, setActiveTab] = useState<"products" | "categories" | "orders" | "users">("products");

    return (
        <section className="section-light min-h-screen p-8">
            <h1 className="text-3xl font-serif text-brandGold mb-6">Admin Dashboard</h1>
            <p className="text-platinumGray mb-8">
                Bienvenue sur la plateforme d'administration Diamant-Rouge.
            </p>

            {/* Tab Navigation Buttons */}
            <div className="flex gap-4 mb-6">
                <button
                    onClick={() => setActiveTab("products")}
                    className={px-6 py-2 rounded-full font-medium transition
            ${activeTab === "products" && <ManageProducts />
                        ? "bg-brandGold text-richEbony"
                        : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                        }
          }
                >
                    Produits
                </button>
                <button
                    onClick={() => setActiveTab("categories")}
                    className={px-6 py-2 rounded-full font-medium transition
            ${activeTab === "categories"
                        ? "bg-brandGold text-richEbony"
                        : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                    }
          }
                >
                    Catégories
                </button>
                <button
                    onClick={() => setActiveTab("orders")}
                    className={px-6 py-2 rounded-full font-medium transition
            ${activeTab === "orders"
                        ? "bg-brandGold text-richEbony"
                        : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                    }
          }
                >
                    Commandes
                </button>
                <button
                    onClick={() => setActiveTab("users")}
                    className={px-6 py-2 rounded-full font-medium transition
            ${activeTab === "users"
                        ? "bg-brandGold text-richEbony"
                        : "bg-burgundy/20 text-richEbony hover:bg-burgundy/40"
                    }
            }
                >
                    Utilisateurs
                </button>

            </div>

            {/* Conditional Rendering of Each Section */}
            {activeTab === "products" && <ManageProducts />}
            {activeTab === "categories" && <ManageCategories />}
            {activeTab === "orders" && <ManageOrders />}
            {activeTab === "users" && <ManageUsers />}
        </section>
    );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
    const session = await getSession(context);
    if (!session || session.user.role !== "admin") {
        return {
            redirect: {
                destination: "/",
                permanent: false,
            },
        };
    }
    return { props: {} };
};
"

Below is an updated, unified ManageUsers component. When an admin clicks “View / Edit” on a user, an inline modal appears that shows all the customer’s details—including their registered address, phone, orders summary, wishlists summary, and other attributes. The admin can then update any information or delete the user.

    Note:
    This example assumes that your GET endpoint (/api/admin/users) is updated to include extra fields (like orders and wishlists) for each user. If not, you may need to modify your API or fetch additional details on demand.

// components/admin/ManageUsers.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

type OrderSummary = {
  id: number;
  totalAmount: string;
  status: string;
  createdAt: string;
};

type WishlistItem = {
  id: number;
  productId: number;
  // Optionally include product info here if needed
};

export type AdminUser = {
  id: number;
  email: string;
  name?: string | null;
  role: string;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  createdAt: string;
  // Extra details for admin view
  orders?: OrderSummary[];
  wishlists?: WishlistItem[];
};

export function ManageUsers() {
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  
  // State for the inline edit modal
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  // formData holds all editable fields
  const [formData, setFormData] = useState<Partial<AdminUser>>({});
  const [updateMessage, setUpdateMessage] = useState("");

  // Fetch users from API on mount
  useEffect(() => {
    async function fetchUsers() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/users");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch users.");
        }
        const data = await res.json();
        setUsers(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Open edit modal with all user details pre-filled
  function openEditModal(user: AdminUser) {
    setSelectedUser(user);
    setFormData({
      name: user.name || "",
      role: user.role,
      phoneNumber: user.phoneNumber || "",
      address: user.address || "",
      city: user.city || "",
      postalCode: user.postalCode || "",
      country: user.country || "",
    });
    setUpdateMessage("");
  }

  // Handle input changes in modal
  function handleInputChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  }

  // Update user details via API
  async function handleUpdateUser() {
    if (!selectedUser) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/users/${selectedUser.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update user.");
      } else {
        setUpdateMessage("User updated successfully");
        // Update local list with new data
        setUsers((prev) =>
          prev.map((u) =>
            u.id === selectedUser.id ? { ...u, ...formData } : u
          )
        );
      }
    } catch (err: any) {
      setUpdateMessage("Error updating user");
    } finally {
      setLoading(false);
    }
  }

  // Delete a user
  async function handleDeleteUser(userId: number) {
    if (!window.confirm("Are you sure you want to delete this user?")) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/admin/users/${userId}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete user");
      }
      setUsers((prev) => prev.filter((u) => u.id !== userId));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Users</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedUser && <p className="text-platinumGray">Loading...</p>}

      {/* Users Table */}
      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">Email</th>
              <th className="p-3 text-left">Name</th>
              <th className="p-3 text-center">Role</th>
              <th className="p-3 text-left">Phone</th>
              <th className="p-3 text-left">Address</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr
                key={user.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{user.id}</td>
                <td className="p-3">{user.email}</td>
                <td className="p-3">{user.name || "-"}</td>
                <td className="p-3 text-center">{user.role}</td>
                <td className="p-3">{user.phoneNumber || "-"}</td>
                <td className="p-3">
                  {user.address || "-"}
                  {user.city ? `, ${user.city}` : ""}
                  {user.postalCode ? `, ${user.postalCode}` : ""}
                  {user.country ? `, ${user.country}` : ""}
                </td>
                <td className="p-3">{new Date(user.createdAt).toLocaleString()}</td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => openEditModal(user)}
                    className="button-secondary mr-3"
                  >
                    View / Edit
                  </button>
                  <button
                    onClick={() => handleDeleteUser(user.id)}
                    className="button-secondary"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Edit Modal */}
      <AnimatePresence>
        {selectedUser && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-3xl">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                View / Edit User #{selectedUser.id}
              </h2>

              {/* Display full user details */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <p>
                    <strong>Email:</strong> {selectedUser.email}
                  </p>
                  <p>
                    <strong>Name:</strong>{" "}
                    <input
                      type="text"
                      name="name"
                      value={formData.name || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>Role:</strong>{" "}
                    <select
                      name="role"
                      value={formData.role || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    >
                      <option value="customer">Customer</option>
                      <option value="admin">Admin</option>
                    </select>
                  </p>
                  <p>
                    <strong>Phone:</strong>{" "}
                    <input
                      type="text"
                      name="phoneNumber"
                      value={formData.phoneNumber || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                </div>
                <div>
                  <p>
                    <strong>Address:</strong>{" "}
                    <input
                      type="text"
                      name="address"
                      value={formData.address || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>City:</strong>{" "}
                    <input
                      type="text"
                      name="city"
                      value={formData.city || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>Postal Code:</strong>{" "}
                    <input
                      type="text"
                      name="postalCode"
                      value={formData.postalCode || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>Country:</strong>{" "}
                    <input
                      type="text"
                      name="country"
                      value={formData.country || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                </div>
              </div>

              {/* Display Orders and Wishlists summary */}
              <div className="mt-6 border-t border-platinumGray pt-4">
                <h3 className="text-2xl font-semibold text-brandGold mb-2">
                  Orders & Wishlists
                </h3>
                <p className="text-platinumGray">
                  <strong>Orders:</strong>{" "}
                  {selectedUser.orders ? selectedUser.orders.length : 0}
                </p>
                <p className="text-platinumGray">
                  <strong>Wishlist Items:</strong>{" "}
                  {selectedUser.wishlists ? selectedUser.wishlists.length : 0}
                </p>
                {/* Optionally, add links to view detailed orders/wishlists */}
              </div>

              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}

              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleUpdateUser}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update User"}
                </button>
                <button
                  onClick={() => setSelectedUser(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

API Endpoints

Ensure that your API endpoints already include:

    GET /api/admin/users/index.ts – Returns users with full attributes (you might want to update it to include orders and wishlists if desired).
    PUT /api/admin/users/[id].ts – Updates user information (as shown previously).
    DELETE /api/admin/users/[id].ts – Deletes a user.

Summary

    The updated ManageUsers component now shows a detailed inline modal when editing a user.
    The modal displays all customer information from the User table (email, name, role, phone, address, city, postal code, country, created date) plus a summary (or count) of their orders and wishlists.
    Admins can update any information, and the component will update its local state after a successful PUT request.
    This component is designed to be embedded into your unified admin dashboard alongside your products, categories, and orders management components.

This approach gives the admin a comprehensive view of each customer’s data and a means to read, update, and delete any user information from one consolidated interface.
You said:
i still can't see the already registered address  on a user that got registered address on his profile 

It sounds like the GET API for users isn’t returning the full address information. In your current GET endpoint, you're only selecting a few fields. To show the registered address (and related fields) on the ManageUsers component, you need to include them in your query.

For example, update your GET endpoint in pages/api/admin/users/index.ts like this:

// pages/api/admin/users/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    // Include all necessary fields
    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        phoneNumber: true,
        address: true,
        city: true,
        postalCode: true,
        country: true,
        createdAt: true,
      },
      orderBy: { createdAt: "desc" },
    });
    return res.status(200).json(users);
  } catch (error: any) {
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

What Changed?

    We added phoneNumber, address, city, postalCode, and country to the select clause so that these fields are returned to the client.

Once you update the API endpoint, your ManageUsers component will receive the full address information and display it correctly.
Next Steps

    Update your API endpoint as shown above.
    Test by reloading the ManageUsers component.
    You should now see the full address details (address, city, postal code, country) for users who have them registered in their profile.

This change should resolve the issue where you weren't seeing the registered address data.
You said:
get the admin to be able to  see the cart of the user either 

Below is an updated solution that adds a “View Cart” feature to the unified user management system. In order to let an admin view a user’s cart, we take the following steps:

    Persist Cart Items:
    Since your schema doesn’t include a cart, we add a new model (e.g., CartItem) in your Prisma schema so that a user’s cart items are stored in the database. For example, in your schema.prisma you could add:

    model CartItem {
      id         Int      @id @default(autoincrement())
      userId     Int
      productId  Int
      quantity   Int      @default(1)
      createdAt  DateTime @default(now())
      updatedAt  DateTime @updatedAt

      user       User     @relation(fields: [userId], references: [id])
      product    Product  @relation(fields: [productId], references: [id])
    }

    Run a migration after updating the schema.

    Create an API Endpoint:
    We implement a GET API endpoint at pages/api/admin/users/[id]/cart.ts that retrieves the cart items for a given user (with product details). This endpoint uses manual token verification to ensure only admin users can access it.

    Update the ManageUsers Component:
    In the inline edit modal for a user, we add a “View Cart” button. When clicked, it calls the new API endpoint to fetch the selected user’s cart items and displays them below the other user details.

Below are the updated code snippets:
A) API Endpoint to Get a User’s Cart Items

// pages/api/admin/users/[id]/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    const { id } = req.query;
    const cartItems = await prisma.cartItem.findMany({
      where: { userId: Number(id) },
      include: {
        product: {
          include: { translations: true },
        },
      },
    });

    return res.status(200).json(cartItems);
  } catch (error: any) {
    console.error("❌ Error fetching cart items:", error);
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

B) Updated ManageUsers Component with “View Cart” Option

Below is the updated ManageUsers component. In the inline modal (for editing a user), a View Cart button is added. When clicked, it fetches the user’s cart items using the API above and displays them.

// components/admin/ManageUsers.tsx

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";

export type AdminUser = {
  id: number;
  email: string;
  name?: string | null;
  role: string;
  phoneNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  createdAt: string;
  // Optionally, you could include orders and wishlists if needed.
};

type CartItem = {
  id: number;
  quantity: number;
  product: {
    id: number;
    sku: string;
    translations: { language: string; name: string }[];
    images: string[];
  };
};

export function ManageUsers() {
  const [users, setUsers] = useState<AdminUser[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  
  // State for the inline edit modal
  const [selectedUser, setSelectedUser] = useState<AdminUser | null>(null);
  const [formData, setFormData] = useState<Partial<AdminUser>>({});
  const [updateMessage, setUpdateMessage] = useState("");
  
  // State for showing cart items and storing fetched cart data
  const [showCart, setShowCart] = useState(false);
  const [cartItems, setCartItems] = useState<CartItem[]>([]);

  // Fetch users from API
  useEffect(() => {
    async function fetchUsers() {
      setLoading(true);
      setError("");
      try {
        const res = await fetch("/api/admin/users");
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || "Failed to fetch users.");
        }
        const data = await res.json();
        setUsers(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Open modal for editing a user
  function openEditModal(user: AdminUser) {
    setSelectedUser(user);
    setFormData({
      name: user.name || "",
      role: user.role,
      phoneNumber: user.phoneNumber || "",
      address: user.address || "",
      city: user.city || "",
      postalCode: user.postalCode || "",
      country: user.country || "",
    });
    setUpdateMessage("");
    setShowCart(false);
  }

  // Handle input changes
  function handleInputChange(e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  }

  // Update user via API
  async function handleUpdateUser() {
    if (!selectedUser) return;
    setLoading(true);
    setUpdateMessage("");
    try {
      const res = await fetch(`/api/admin/users/${selectedUser.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });
      const data = await res.json();
      if (!res.ok) {
        setUpdateMessage(data.error || "Failed to update user.");
      } else {
        setUpdateMessage("User updated successfully");
        setUsers((prev) =>
          prev.map((u) =>
            u.id === selectedUser.id ? { ...u, ...formData } : u
          )
        );
      }
    } catch (err: any) {
      setUpdateMessage("Error updating user");
    } finally {
      setLoading(false);
    }
  }

  // Delete a user via API
  async function handleDeleteUser(userId: number) {
    if (!window.confirm("Are you sure you want to delete this user?")) return;
    setLoading(true);
    try {
      const res = await fetch(`/api/admin/users/${userId}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Failed to delete user");
      }
      setUsers((prev) => prev.filter((u) => u.id !== userId));
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }

  // Fetch cart items for a user
  async function fetchUserCart(userId: number) {
    try {
      const res = await fetch(`/api/admin/users/${userId}/cart`);
      if (!res.ok) {
        throw new Error("Failed to fetch cart items");
      }
      const data = await res.json();
      setCartItems(data);
    } catch (err: any) {
      console.error(err);
    }
  }

  // Toggle display of cart items in the modal
  function handleToggleCart(userId: number) {
    if (!showCart) {
      fetchUserCart(userId);
    }
    setShowCart((prev) => !prev);
  }

  return (
    <div className="p-6">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Manage Users</h1>

      {error && <p className="text-burgundy mb-4 font-semibold">{error}</p>}
      {loading && !selectedUser && <p className="text-platinumGray">Loading...</p>}

      {/* Users Table */}
      <div className="overflow-x-auto">
        <table className="w-full bg-burgundy/10 text-richEbony rounded-lg shadow-luxury">
          <thead className="bg-burgundy/20 text-brandGold">
            <tr>
              <th className="p-3 text-left">ID</th>
              <th className="p-3 text-left">Email</th>
              <th className="p-3 text-left">Name</th>
              <th className="p-3 text-center">Role</th>
              <th className="p-3 text-left">Phone</th>
              <th className="p-3 text-left">Address</th>
              <th className="p-3">Created</th>
              <th className="p-3">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr
                key={user.id}
                className="border-b border-platinumGray/30 hover:bg-burgundy/5 transition"
              >
                <td className="p-3">{user.id}</td>
                <td className="p-3">{user.email}</td>
                <td className="p-3">{user.name || "-"}</td>
                <td className="p-3 text-center">{user.role}</td>
                <td className="p-3">{user.phoneNumber || "-"}</td>
                <td className="p-3">
                  {user.address || "-"}
                  {user.city ? `, ${user.city}` : ""}
                  {user.postalCode ? `, ${user.postalCode}` : ""}
                  {user.country ? `, ${user.country}` : ""}
                </td>
                <td className="p-3">{new Date(user.createdAt).toLocaleString()}</td>
                <td className="p-3 text-center">
                  <button
                    onClick={() => openEditModal(user)}
                    className="button-secondary mr-3"
                  >
                    View / Edit
                  </button>
                  <button
                    onClick={() => handleDeleteUser(user.id)}
                    className="button-secondary"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Inline Edit Modal */}
      <AnimatePresence>
        {selectedUser && (
          <motion.div
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 50 }}
            transition={{ duration: 0.5 }}
            className="fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4"
          >
            <div className="bg-brandIvory p-6 rounded-lg shadow-2xl w-full max-w-3xl">
              <h2 className="text-3xl font-serif text-brandGold mb-4">
                View / Edit User #{selectedUser.id}
              </h2>

              {/* User Basic Information */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <p>
                    <strong>Email:</strong> {selectedUser.email}
                  </p>
                  <p>
                    <strong>Name:</strong>{" "}
                    <input
                      type="text"
                      name="name"
                      value={formData.name || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>Role:</strong>{" "}
                    <select
                      name="role"
                      value={formData.role || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    >
                      <option value="customer">Customer</option>
                      <option value="admin">Admin</option>
                    </select>
                  </p>
                </div>
                <div>
                  <p>
                    <strong>Phone:</strong>{" "}
                    <input
                      type="text"
                      name="phoneNumber"
                      value={formData.phoneNumber || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p>
                    <strong>Address:</strong>{" "}
                    <input
                      type="text"
                      name="address"
                      value={formData.address || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                  <p className="flex gap-4">
                    <span className="w-1/2">
                      <strong>City:</strong>{" "}
                      <input
                        type="text"
                        name="city"
                        value={formData.city || ""}
                        onChange={handleInputChange}
                        className="input-field w-full"
                      />
                    </span>
                    <span className="w-1/2">
                      <strong>Postal Code:</strong>{" "}
                      <input
                        type="text"
                        name="postalCode"
                        value={formData.postalCode || ""}
                        onChange={handleInputChange}
                        className="input-field w-full"
                      />
                    </span>
                  </p>
                  <p>
                    <strong>Country:</strong>{" "}
                    <input
                      type="text"
                      name="country"
                      value={formData.country || ""}
                      onChange={handleInputChange}
                      className="input-field w-full"
                    />
                  </p>
                </div>
              </div>

              {/* Orders & Wishlists Summary */}
              <div className="mt-6 border-t border-platinumGray pt-4">
                <h3 className="text-2xl font-semibold text-brandGold mb-2">
                  Orders & Wishlists
                </h3>
                <p className="text-platinumGray">
                  <strong>Orders:</strong>{" "}
                  {selectedUser.orders ? selectedUser.orders.length : 0}
                </p>
                <p className="text-platinumGray">
                  <strong>Wishlist Items:</strong>{" "}
                  {selectedUser.wishlists ? selectedUser.wishlists.length : 0}
                </p>
              </div>

              {/* View Cart Button */}
              <button
                onClick={() => handleToggleCart(selectedUser.id)}
                className="button-secondary mt-4"
              >
                {showCart ? "Hide Cart" : "View Cart"}
              </button>

              {/* Display Cart Items if toggled */}
              {showCart && (
                <div className="mt-4">
                  <h3 className="text-xl font-semibold text-brandGold mb-2">
                    User Cart
                  </h3>
                  {cartItems.length === 0 ? (
                    <p className="text-platinumGray">Cart is empty.</p>
                  ) : (
                    <ul className="list-disc list-inside">
                      {cartItems.map((item) => (
                        <li key={item.id} className="text-richEbony">
                          {item.product.translations.find(
                            (t: any) => t.language === "en"
                          )?.name || item.product.sku}{" "}
                          (Qty: {item.quantity})
                        </li>
                      ))}
                    </ul>
                  )}
                </div>
              )}

              {updateMessage && (
                <p className="text-sm text-burgundy mt-3 font-semibold">
                  {updateMessage}
                </p>
              )}

              <div className="flex gap-4 mt-6">
                <button
                  onClick={handleUpdateUser}
                  className="button-primary w-full md:w-auto"
                  disabled={loading}
                >
                  {loading ? "Updating..." : "Update User"}
                </button>
                <button
                  onClick={() => setSelectedUser(null)}
                  className="button-secondary w-full md:w-auto"
                  disabled={loading}
                >
                  Close
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

API Endpoints Recap

    GET /api/admin/users/index.ts returns full user details (ensure you include all address and phone fields).
    PUT /api/admin/users/[id].ts updates user information.
    DELETE /api/admin/users/[id].ts deletes a user.
    GET /api/admin/users/[id]/cart.ts returns cart items for a specific user (requires the new CartItem model to exist).

Summary

With these updates, the admin can:

    View a detailed list of users with all registered attributes (email, name, role, phone, address, etc.).
    Click “View / Edit” to open a modal that shows all the user's information, including a summary of their orders and wishlists.
    Use a new “View Cart” button within that modal to fetch and display the user's cart items (assuming you have a CartItem model and the corresponding API endpoint).
    Update any of the user's attributes or delete the user entirely.

This provides a comprehensive and efficient user management system within your unified admin dashboard.
You said:
 and how each user been able to see it's cart previously without that cart table : "import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

type CartItem = {
    productId: number;
    variationId?: number;
    sku: string;
    name: string;
    price: number;
    quantity: number;
    image?: string; // ✅ Ensure image is stored
};

type CartContextType = {
    cart: CartItem[];
    addToCart: (item: CartItem) => void;
    removeFromCart: (productId: number, variationId?: number) => void;
    clearCart: () => void;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
    const { data: session } = useSession();
    const userEmail = session?.user?.email || "guest";
    const userKey = cart-${userEmail};

    const [cart, setCart] = useState<CartItem[]>([]);

    // ✅ Load cart from localStorage when user logs in/out
    useEffect(() => {
        if (typeof window !== "undefined") {
            const savedCart = localStorage.getItem(userKey);
            setCart(savedCart ? JSON.parse(savedCart) : []);
        }
    }, [userKey]);

    // ✅ Save cart whenever it updates
    useEffect(() => {
        if (typeof window !== "undefined") {
            localStorage.setItem(userKey, JSON.stringify(cart));
        }
    }, [cart, userKey]);

    function addToCart(item: CartItem) {
        setCart((prev) => {
            const existingIndex = prev.findIndex(
                (p) => p.productId === item.productId && p.variationId === item.variationId
            );
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex].quantity += item.quantity;
                return updated;
            } else {
                return [...prev, item];
            }
        });
    }

    function removeFromCart(productId: number, variationId?: number) {
        setCart((prev) =>
            prev.filter((p) => p.productId !== productId || p.variationId !== variationId)
        );
    }

    function clearCart() {
        setCart([]);
    }

    return (
        <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart }}>
            {children}
        </CartContext.Provider>
    );
}

export function useCart() {
    const context = useContext(CartContext);
    if (!context) {
        throw new Error("useCart must be used within a CartProvider");
    }
    return context;
}
"  "import { useCart } from "../contexts/CartContext";
import Link from "next/link";
import Image from "next/image";

export default function CartPage() {
    const { cart, removeFromCart, clearCart } = useCart();

    const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

    if (cart.length === 0) {
        return (
            <main className="section-light p-8 text-center min-h-screen">
                <h1 className="text-4xl font-serif text-brandGold mb-4">Your Cart</h1>
                <p className="text-platinumGray">Your cart is currently empty.</p>
                <Link href="/" className="text-brandGold hover:underline">
                    Continue Shopping
                </Link>
            </main>
        );
    }

    return (
        <main className="section-light p-8 max-w-3xl mx-auto min-h-screen">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Your Cart</h1>

            <ul className="space-y-6">
                {cart.map((item) => (
                    <li
                        key={item.productId}
                        className="bg-burgundy/10 p-4 rounded-lg flex items-center gap-4 shadow-luxury"
                    >
                        <Image
                            src={item.image || "/images/placeholder.jpg"}
                            width={100}
                            height={100}
                            alt={item.name}
                            className="rounded-lg object-cover"
                            onError={(e) => (e.currentTarget.src = "/images/placeholder.jpg")}
                        />
                        <div className="flex-1">
                            <p className="text-xl font-semibold text-richEbony">{item.name}</p>
                            <p className="text-sm text-platinumGray">SKU: {item.sku}</p>
                            <p className="text-sm text-platinumGray">Qty: {item.quantity}</p>
                        </div>
                        <div className="flex flex-col items-end">
                            <p className="text-lg font-bold text-brandGold">
                                €{(item.price * item.quantity).toFixed(2)}
                            </p>
                            <button
                                onClick={() => removeFromCart(item.productId)}
                                className="text-burgundy hover:text-brandGold transition mt-2"
                            >
                                Remove
                            </button>
                        </div>
                    </li>
                ))}
            </ul>

            <div className="text-right mt-8">
                <p className="text-2xl font-bold text-brandGold mb-4">
                    Total: €{total.toFixed(2)}
                </p>
                <button
                    onClick={clearCart}
                    className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full mr-4 transition duration-300"
                >
                    Clear Cart
                </button>
                <Link href="/checkout">
                    <button className="bg-brandGold hover:bg-burgundy text-richEbony px-6 py-3 rounded-full transition duration-300">
                        Proceed to Checkout
                    </button>
                </Link>
            </div>
        </main>
    );
}
"

By default, our storefront kept each user’s cart solely in localStorage using the CartContext. That meant each user could see their own cart on their browser, but—since it wasn’t saved to the database—the admin couldn’t query it.

To let an admin view a user’s cart, you’ll need to implement a persistent cart system. One common approach is to add a CartItem model to your Prisma schema so that every time a user adds to their cart, you also save it server‑side. Then, you can create an API endpoint (for example, GET /api/admin/users/[id]/cart) that returns a user’s saved cart items, which the admin can view.

Below are the steps and example code to achieve this:
1. Update the Prisma Schema

Add a new model (e.g., CartItem) so that each cart item is saved for the user:

model CartItem {
  id         Int      @id @default(autoincrement())
  userId     Int
  productId  Int
  quantity   Int      @default(1)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])
  product    Product  @relation(fields: [productId], references: [id])
}

Then run a migration:

npx prisma migrate dev --name "add_cartitem_model"

2. Update CartContext (Optional)

To keep both localStorage and persistent storage in sync, you might want to update your CartContext’s addToCart function so that it also saves the item to the database (using a POST to a new API endpoint like /api/cart). This step is optional if you prefer to have the cart only on the server once the user checks out—but for admin viewing, the cart must be persisted.
3. Create an API Endpoint for a User’s Cart

Create a new file at pages/api/admin/users/[id]/cart.ts:

// pages/api/admin/users/[id]/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
  try {
    const rawCookie = req.headers.cookie || "";
    let match =
      rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
      rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
    if (!match) throw new Error("Unauthorized: No token found");

    const tokenStr = decodeURIComponent(match[1]);
    const secret = process.env.NEXTAUTH_SECRET || "";
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    const user = decoded as unknown as DecodedPayload;
    if (user.role !== "admin") throw new Error("Unauthorized: Admin access required");

    const { id } = req.query;
    const cartItems = await prisma.cartItem.findMany({
      where: { userId: Number(id) },
      include: {
        product: {
          include: { translations: true },
        },
      },
    });
    return res.status(200).json(cartItems);
  } catch (error: any) {
    console.error("Error fetching cart items:", error);
    return res.status(401).json({ error: error.message || "Unauthorized request" });
  }
}

4. Update the ManageUsers Component

In the inline edit modal for a user, add a “View Cart” button that calls the above endpoint. For example, in your ManageUsers component, add a function to fetch and display the cart:

// Within ManageUsers.tsx

// State for cart items and toggle
const [showCart, setShowCart] = useState(false);
const [cartItems, setCartItems] = useState<CartItem[]>([]);

async function fetchUserCart(userId: number) {
  try {
    const res = await fetch(`/api/admin/users/${userId}/cart`);
    if (!res.ok) {
      throw new Error("Failed to fetch cart items");
    }
    const data = await res.json();
    setCartItems(data);
  } catch (err: any) {
    console.error(err);
  }
}

function handleToggleCart(userId: number) {
  if (!showCart) {
    fetchUserCart(userId);
  }
  setShowCart((prev) => !prev);
}

Then, in your inline modal (where you view/edit a user), add a button to toggle cart visibility and display the cart items if available:

{/* View Cart Button */}
<button onClick={() => handleToggleCart(selectedUser.id)} className="button-secondary mt-4">
  {showCart ? "Hide Cart" : "View Cart"}
</button>

{/* Display Cart Items if toggled */}
{showCart && (
  <div className="mt-4">
    <h3 className="text-xl font-semibold text-brandGold mb-2">User Cart</h3>
    {cartItems.length === 0 ? (
      <p className="text-platinumGray">Cart is empty.</p>
    ) : (
      <ul className="list-disc list-inside">
        {cartItems.map((item) => (
          <li key={item.id} className="text-richEbony">
            {item.product.translations.find((t: any) => t.language === "en")?.name || item.product.sku} (Qty: {item.quantity})
          </li>
        ))}
      </ul>
    )}
  </div>
)}

Summary

    Previously, the user’s cart was stored in localStorage via the CartContext, so each user saw their cart only on their device.
    To allow the admin to view a user’s cart, you must persist the cart items to a backend database (using a new CartItem model in Prisma).
    A new API endpoint (GET /api/admin/users/[id]/cart) fetches the persistent cart items for a given user.
    The ManageUsers component’s inline edit modal now includes a “View Cart” toggle that, when activated, fetches and displays the cart items for that user.

Implementing this persistent cart system bridges the gap between client-side cart storage (localStorage) and a server‑accessible cart that the admin can review.
You said:
"┌──(dr_house㉿Kali)-[~/Documents/pro/diamant-rouge/diamant-rouge]
└─$ npx prisma migrate dev --name "add_cartitem_model"

Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": PostgreSQL database "diamant_rouge_db", schema "public" at "localhost:5432"


Error: Prisma schema validation - (validate wasm)
Error code: P1012
error: Error validating field user in model CartItem: The relation field user on model CartItem is missing an opposite relation field on the model User. Either run prisma format or add it manually.
  -->  prisma/schema.prisma:108
   | 
107 | 
108 |   user       User     @relation(fields: [userId], references: [id])
109 |   product    Product  @relation(fields: [productId], references: [id])
   | 
error: Error validating field product in model CartItem: The relation field product on model CartItem is missing an opposite relation field on the model Product. Either run prisma format or add it manually.
  -->  prisma/schema.prisma:109
   | 
108 |   user       User     @relation(fields: [userId], references: [id])
109 |   product    Product  @relation(fields: [productId], references: [id])
110 | }
   | 

Validation Error Count: 2
[Context: validate]

Prisma CLI Version : 6.2.1
"

The error means that in your new CartItem model, you declared a relation to User and Product, but Prisma expects the related models (User and Product) to have a corresponding back‑relation field.

To fix this, update your schema as follows:

    In the CartItem model: (No change needed here if it’s as before)
    In the User model: Add a back‑relation field (e.g., cartItems) that references the CartItem model.
    In the Product model: Add a back‑relation field (e.g., cartItems) that references the CartItem model.

For example:

model CartItem {
  id         Int      @id @default(autoincrement())
  userId     Int
  productId  Int
  quantity   Int      @default(1)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id])
  product    Product  @relation(fields: [productId], references: [id])
}

model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  password    String
  name        String?
  role        String   @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orders      Order[]
  wishlists   Wishlist[]
  cartItems   CartItem[]  // ← Add this line
}

model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]        // ← Add this line
}

After updating your schema, run:

npx prisma format
npx prisma migrate dev --name "add_cartitem_relation_fields"

This will add the missing back‑relation fields and resolve the validation errors.
You said:
Now let's rework the user cart management system to incorporate the new CartItem modeil in prisma feature : "import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

type CartItem = {
    productId: number;
    variationId?: number;
    sku: string;
    name: string;
    price: number;
    quantity: number;
    image?: string; // ✅ Ensure image is stored
};

type CartContextType = {
    cart: CartItem[];
    addToCart: (item: CartItem) => void;
    removeFromCart: (productId: number, variationId?: number) => void;
    clearCart: () => void;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
    const { data: session } = useSession();
    const userEmail = session?.user?.email || "guest";
    const userKey = cart-${userEmail};

    const [cart, setCart] = useState<CartItem[]>([]);

    // ✅ Load cart from localStorage when user logs in/out
    useEffect(() => {
        if (typeof window !== "undefined") {
            const savedCart = localStorage.getItem(userKey);
            setCart(savedCart ? JSON.parse(savedCart) : []);
        }
    }, [userKey]);

    // ✅ Save cart whenever it updates
    useEffect(() => {
        if (typeof window !== "undefined") {
            localStorage.setItem(userKey, JSON.stringify(cart));
        }
    }, [cart, userKey]);

    function addToCart(item: CartItem) {
        setCart((prev) => {
            const existingIndex = prev.findIndex(
                (p) => p.productId === item.productId && p.variationId === item.variationId
            );
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex].quantity += item.quantity;
                return updated;
            } else {
                return [...prev, item];
            }
        });
    }

    function removeFromCart(productId: number, variationId?: number) {
        setCart((prev) =>
            prev.filter((p) => p.productId !== productId || p.variationId !== variationId)
        );
    }

    function clearCart() {
        setCart([]);
    }

    return (
        <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart }}>
            {children}
        </CartContext.Provider>
    );
}

export function useCart() {
    const context = useContext(CartContext);
    if (!context) {
        throw new Error("useCart must be used within a CartProvider");
    }
    return context;
}
"   "import { useCart } from "../contexts/CartContext";
import Link from "next/link";
import Image from "next/image";

export default function CartPage() {
    const { cart, removeFromCart, clearCart } = useCart();

    const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

    if (cart.length === 0) {
        return (
            <main className="section-light p-8 text-center min-h-screen">
                <h1 className="text-4xl font-serif text-brandGold mb-4">Your Cart</h1>
                <p className="text-platinumGray">Your cart is currently empty.</p>
                <Link href="/" className="text-brandGold hover:underline">
                    Continue Shopping
                </Link>
            </main>
        );
    }

    return (
        <main className="section-light p-8 max-w-3xl mx-auto min-h-screen">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Your Cart</h1>

            <ul className="space-y-6">
                {cart.map((item) => (
                    <li
                        key={item.productId}
                        className="bg-burgundy/10 p-4 rounded-lg flex items-center gap-4 shadow-luxury"
                    >
                        <Image
                            src={item.image || "/images/placeholder.jpg"}
                            width={100}
                            height={100}
                            alt={item.name}
                            className="rounded-lg object-cover"
                            onError={(e) => (e.currentTarget.src = "/images/placeholder.jpg")}
                        />
                        <div className="flex-1">
                            <p className="text-xl font-semibold text-richEbony">{item.name}</p>
                            <p className="text-sm text-platinumGray">SKU: {item.sku}</p>
                            <p className="text-sm text-platinumGray">Qty: {item.quantity}</p>
                        </div>
                        <div className="flex flex-col items-end">
                            <p className="text-lg font-bold text-brandGold">
                                €{(item.price * item.quantity).toFixed(2)}
                            </p>
                            <button
                                onClick={() => removeFromCart(item.productId)}
                                className="text-burgundy hover:text-brandGold transition mt-2"
                            >
                                Remove
                            </button>
                        </div>
                    </li>
                ))}
            </ul>

            <div className="text-right mt-8">
                <p className="text-2xl font-bold text-brandGold mb-4">
                    Total: €{total.toFixed(2)}
                </p>
                <button
                    onClick={clearCart}
                    className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full mr-4 transition duration-300"
                >
                    Clear Cart
                </button>
                <Link href="/checkout">
                    <button className="bg-brandGold hover:bg-burgundy text-richEbony px-6 py-3 rounded-full transition duration-300">
                        Proceed to Checkout
                    </button>
                </Link>
            </div>
        </main>
    );
}
"  "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
'
2/2

Previously, each user’s cart wasn’t stored in the database at all. Instead, it was maintained entirely on the client side using our CartContext. In other words, when a user added items to their cart, those items were saved in localStorage (keyed by the user’s email) and managed in-memory via React state. This allowed each user to see their cart on their own browser, but it meant that the cart data wasn’t available on the server—so the admin couldn’t query or review a user’s cart.

Now that we’re introducing a persistent CartItem model in Prisma, we can save cart items in the database. This change lets us create an API endpoint (e.g., GET /api/admin/users/[id]/cart) so that an admin can view any user’s cart. At the same time, you have the option to update the CartContext logic so that adding items to the cart both updates localStorage (for immediate UI responsiveness) and sends the data to the server to persist it.

In summary:

    Before:
    • Cart items were stored locally (in localStorage) using CartContext.
    • Users saw their cart only in their browser.
    • The server had no record of the cart, so admins couldn’t view it.

    Now:
    • With the new Prisma CartItem model, cart items can be stored persistently in the database.
    • An admin API endpoint can fetch a user’s cart items so the admin can see what’s in a user’s cart.
    • You can update the CartContext (or add a separate mechanism) to save items to the database when users add products to their cart.

This persistent solution opens the door for both an improved user experience and an admin view of user carts.
You said:
the user cart system is still usig the local storage , let's refractor it to use the persistent cartitem prisma table model : "import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

type CartItem = {
    productId: number;
    variationId?: number;
    sku: string;
    name: string;
    price: number;
    quantity: number;
    image?: string; // ✅ Ensure image is stored
};

type CartContextType = {
    cart: CartItem[];
    addToCart: (item: CartItem) => void;
    removeFromCart: (productId: number, variationId?: number) => void;
    clearCart: () => void;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
    const { data: session } = useSession();
    const userEmail = session?.user?.email || "guest";
    const userKey = cart-${userEmail};

    const [cart, setCart] = useState<CartItem[]>([]);

    // ✅ Load cart from localStorage when user logs in/out
    useEffect(() => {
        if (typeof window !== "undefined") {
            const savedCart = localStorage.getItem(userKey);
            setCart(savedCart ? JSON.parse(savedCart) : []);
        }
    }, [userKey]);

    // ✅ Save cart whenever it updates
    useEffect(() => {
        if (typeof window !== "undefined") {
            localStorage.setItem(userKey, JSON.stringify(cart));
        }
    }, [cart, userKey]);

    function addToCart(item: CartItem) {
        setCart((prev) => {
            const existingIndex = prev.findIndex(
                (p) => p.productId === item.productId && p.variationId === item.variationId
            );
            if (existingIndex > -1) {
                const updated = [...prev];
                updated[existingIndex].quantity += item.quantity;
                return updated;
            } else {
                return [...prev, item];
            }
        });
    }

    function removeFromCart(productId: number, variationId?: number) {
        setCart((prev) =>
            prev.filter((p) => p.productId !== productId || p.variationId !== variationId)
        );
    }

    function clearCart() {
        setCart([]);
    }

    return (
        <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart }}>
            {children}
        </CartContext.Provider>
    );
}

export function useCart() {
    const context = useContext(CartContext);
    if (!context) {
        throw new Error("useCart must be used within a CartProvider");
    }
    return context;
}
"  "import { useCart } from "../contexts/CartContext";
import Link from "next/link";
import Image from "next/image";

export default function CartPage() {
    const { cart, removeFromCart, clearCart } = useCart();

    const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

    if (cart.length === 0) {
        return (
            <main className="section-light p-8 text-center min-h-screen">
                <h1 className="text-4xl font-serif text-brandGold mb-4">Your Cart</h1>
                <p className="text-platinumGray">Your cart is currently empty.</p>
                <Link href="/" className="text-brandGold hover:underline">
                    Continue Shopping
                </Link>
            </main>
        );
    }

    return (
        <main className="section-light p-8 max-w-3xl mx-auto min-h-screen">
            <h1 className="text-4xl font-serif text-brandGold mb-6">Your Cart</h1>

            <ul className="space-y-6">
                {cart.map((item) => (
                    <li
                        key={item.productId}
                        className="bg-burgundy/10 p-4 rounded-lg flex items-center gap-4 shadow-luxury"
                    >
                        <Image
                            src={item.image || "/images/placeholder.jpg"}
                            width={100}
                            height={100}
                            alt={item.name}
                            className="rounded-lg object-cover"
                            onError={(e) => (e.currentTarget.src = "/images/placeholder.jpg")}
                        />
                        <div className="flex-1">
                            <p className="text-xl font-semibold text-richEbony">{item.name}</p>
                            <p className="text-sm text-platinumGray">SKU: {item.sku}</p>
                            <p className="text-sm text-platinumGray">Qty: {item.quantity}</p>
                        </div>
                        <div className="flex flex-col items-end">
                            <p className="text-lg font-bold text-brandGold">
                                €{(item.price * item.quantity).toFixed(2)}
                            </p>
                            <button
                                onClick={() => removeFromCart(item.productId)}
                                className="text-burgundy hover:text-brandGold transition mt-2"
                            >
                                Remove
                            </button>
                        </div>
                    </li>
                ))}
            </ul>

            <div className="text-right mt-8">
                <p className="text-2xl font-bold text-brandGold mb-4">
                    Total: €{total.toFixed(2)}
                </p>
                <button
                    onClick={clearCart}
                    className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full mr-4 transition duration-300"
                >
                    Clear Cart
                </button>
                <Link href="/checkout">
                    <button className="bg-brandGold hover:bg-burgundy text-richEbony px-6 py-3 rounded-full transition duration-300">
                        Proceed to Checkout
                    </button>
                </Link>
            </div>
        </main>
    );
}
"  "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
"

Below is an updated CartContext that uses your new persistent CartItem model via API calls rather than relying on localStorage. In this version, when the CartProvider mounts (or the session changes), it fetches the cart from a new API endpoint (e.g. GET /api/cart) that returns the cart items stored in your database. Likewise, when you add, update, or remove items, it calls the appropriate API endpoints so that the changes are persisted.

    Note:
    You’ll need to implement the following API endpoints on your backend:

        GET /api/cart: Returns the current user’s cart items (using the persistent CartItem model).
        POST /api/cart: Creates a new cart item.
        PUT /api/cart/[id]: Updates an existing cart item (e.g. updating quantity).
        DELETE /api/cart/[id]: Deletes a single cart item.
        DELETE /api/cart/clear: Clears all cart items for the logged‑in user.

Below is the updated code:

// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(`/api/cart/${existingItem.id}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(`/api/cart/${item.id}`, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}

Updating the CartPage

Since the CartPage uses useCart(), it will automatically display the persistent cart items once the API endpoints are implemented and return the current user's cart.

// pages/cart.tsx

import { useCart } from "../contexts/CartContext";
import Link from "next/link";
import Image from "next/image";

export default function CartPage() {
  const { cart, removeFromCart, clearCart } = useCart();

  const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);

  if (cart.length === 0) {
    return (
      <main className="section-light p-8 text-center min-h-screen">
        <h1 className="text-4xl font-serif text-brandGold mb-4">Your Cart</h1>
        <p className="text-platinumGray">Your cart is currently empty.</p>
        <Link href="/" className="text-brandGold hover:underline">
          Continue Shopping
        </Link>
      </main>
    );
  }

  return (
    <main className="section-light p-8 max-w-3xl mx-auto min-h-screen">
      <h1 className="text-4xl font-serif text-brandGold mb-6">Your Cart</h1>

      <ul className="space-y-6">
        {cart.map((item) => (
          <li
            key={item.id || item.productId}
            className="bg-burgundy/10 p-4 rounded-lg flex items-center gap-4 shadow-luxury"
          >
            <Image
              src={item.image || "/images/placeholder.jpg"}
              width={100}
              height={100}
              alt={item.name}
              className="rounded-lg object-cover"
              onError={(e) => (e.currentTarget.src = "/images/placeholder.jpg")}
            />
            <div className="flex-1">
              <p className="text-xl font-semibold text-richEbony">{item.name}</p>
              <p className="text-sm text-platinumGray">SKU: {item.sku}</p>
              <p className="text-sm text-platinumGray">Qty: {item.quantity}</p>
            </div>
            <div className="flex flex-col items-end">
              <p className="text-lg font-bold text-brandGold">
                €{(item.price * item.quantity).toFixed(2)}
              </p>
              <button
                onClick={() => removeFromCart(item.productId, item.variationId)}
                className="text-burgundy hover:text-brandGold transition mt-2"
              >
                Remove
              </button>
            </div>
          </li>
        ))}
      </ul>

      <div className="text-right mt-8">
        <p className="text-2xl font-bold text-brandGold mb-4">
          Total: €{total.toFixed(2)}
        </p>
        <button
          onClick={clearCart}
          className="bg-burgundy hover:bg-brandGold text-brandIvory px-6 py-3 rounded-full mr-4 transition duration-300"
        >
          Clear Cart
        </button>
        <Link href="/checkout">
          <button className="bg-brandGold hover:bg-burgundy text-richEbony px-6 py-3 rounded-full transition duration-300">
            Proceed to Checkout
          </button>
        </Link>
      </div>
    </main>
  );
}

Summary

    We refactored the CartContext to use persistent storage via API calls that interact with the new Prisma CartItem model.
    When the CartProvider mounts, it calls GET /api/cart to load the cart from the database.
    Functions like addToCart, removeFromCart, and clearCart now call the appropriate API endpoints so that all changes are persisted.
    The CartPage continues to display the cart items from context as before, but now those items are backed by persistent storage.

Be sure to implement the corresponding API endpoints on your backend to support these operations. This change allows the admin and the user to both work with a persistent cart stored in your database.
You said:
now need to create the necessary apis for that cart that are missing

Below is an example implementation of the missing API endpoints for your persistent cart. In this example, we assume that when a user adds an item to the cart, the backend should check if an identical item (same productId and variationId) already exists for that user—if so, it updates the quantity; otherwise, it creates a new record. We also provide endpoints for updating a cart item, deleting a single cart item, and clearing the entire cart for the logged‑in user.

All endpoints perform manual token verification (using the jose library) so that only an authenticated user can manipulate their cart. (You can adjust the logic if you prefer using getSession.)
1. GET & POST /api/cart

Create a file at pages/api/cart/index.ts:

// pages/api/cart/index.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Verify the user session token
  const rawCookie = req.headers.cookie || "";
  let match = rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
              rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }

  // Use the user id for all operations
  const userId = Number(payload.id);

  if (req.method === "GET") {
    // GET: Return all cart items for this user
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  } else if (req.method === "POST") {
    // POST: Create or update a cart item
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Check if an item with the same productId and variationId exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId, variationId: variationId || null },
      });
      let cartItem;
      if (existing) {
        // Update quantity
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + quantity },
        });
      } else {
        // Create new cart item
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId,
            quantity,
            // The following fields are stored for reference:
            // (You might want to store these redundantly or fetch them from the Product table later)
            // Note: You could optionally skip storing sku, name, price, image if you plan to join with Product later.
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      return res.status(500).json({ error: "Error adding cart item" });
    }
  } else {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
}

2. PUT & DELETE /api/cart/[id].ts

Create a file at pages/api/cart/[id].ts:

// pages/api/cart/[id].ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;
  if (!id || isNaN(Number(id))) {
    return res.status(400).json({ error: "Invalid cart item ID" });
  }

  // Verify token
  const rawCookie = req.headers.cookie || "";
  let match = rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
              rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  
  const userId = Number(payload.id);

  // Ensure that the cart item belongs to the current user
  const cartItem = await prisma.cartItem.findUnique({
    where: { id: Number(id) },
  });
  if (!cartItem || cartItem.userId !== userId) {
    return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
  }

  if (req.method === "PUT") {
    const { quantity } = req.body;
    if (quantity === undefined) {
      return res.status(400).json({ error: "Quantity is required" });
    }
    try {
      const updated = await prisma.cartItem.update({
        where: { id: Number(id) },
        data: { quantity },
      });
      return res.status(200).json(updated);
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to update cart item" });
    }
  } else if (req.method === "DELETE") {
    try {
      await prisma.cartItem.delete({
        where: { id: Number(id) },
      });
      return res.status(200).json({ message: "Cart item deleted successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to delete cart item" });
    }
  } else {
    return res.status(405).json({ error: "Method Not Allowed" });
  }
}

3. DELETE /api/cart/clear.ts

Create a file at pages/api/cart/clear.ts:

// pages/api/cart/clear.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // Verify token
  const rawCookie = req.headers.cookie || "";
  let match = rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
              rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }

  const userId = Number(payload.id);

  try {
    await prisma.cartItem.deleteMany({
      where: { userId },
    });
    return res.status(200).json({ message: "Cart cleared successfully" });
  } catch (err: any) {
    return res.status(500).json({ error: "Failed to clear cart" });
  }
}

Summary

    GET /api/cart (in pages/api/cart/index.ts) fetches all cart items for the current user (by verifying their token).
    POST /api/cart (in the same file) creates a new cart item, or—if desired—you can check for duplicates and update quantity.
    PUT /api/cart/[id].ts updates a specific cart item (e.g., quantity) after ensuring the item belongs to the current user.
    DELETE /api/cart/[id].ts deletes a specific cart item.
    DELETE /api/cart/clear.ts deletes all cart items for the current user.

Integrate these endpoints with your updated CartContext, so that when users add, update, or remove items, your front end calls these endpoints, and the cart is persisted in the database via your Prisma CartItem model.
You said:
can we combine them all on a file api/cart.ts ?

Below is an example of combining all cart‑related operations (GET, POST, PUT, DELETE, and clearing) into a single API file. In this unified endpoint, if a query parameter id is provided, we update or delete that specific cart item. If the query parameter clear is provided on a DELETE request, we clear the entire cart for the user. Otherwise, a GET returns the cart and POST creates a new cart item.

Make sure your environment variable NEXTAUTH_SECRET is set and that your Prisma schema includes the new CartItem model with the back‑relations in User and Product.

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle query parameters -----
  // Optionally, if an "id" query parameter is present, we perform update/delete on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle collection of cart items for the user -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Check if an item with same productId and variationId exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId, variationId: variationId || null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + quantity },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId,
            quantity,
            // Optionally, store additional fields if desired
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

How It Works

    Token Verification:
    The endpoint verifies the session token and extracts the user’s ID.

    Query Handling:
        If the DELETE method includes a query parameter clear, it deletes all cart items for the user.
        If a query parameter id is provided, it treats the request as an operation on a specific cart item (PUT to update quantity or DELETE to remove that item).
        Otherwise, a GET returns all cart items for the user and POST creates a new cart item.

    Usage:
    Your CartContext now calls these endpoints to persist cart changes in the database instead of localStorage.

This unified file simplifies your cart API by handling all CRUD operations for the persistent cart in one endpoint. Adjust the logic as needed for your specific use case.
You said:
i ve get : " GET /_next/data/development/en/products/2.json?id=2 200 in 153ms
 POST /api/cart 500 in 26ms


"  "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
"  "// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(/api/cart/${existingItem.id}, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(/api/cart/${item.id}, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle query parameters -----
  // Optionally, if an "id" query parameter is present, we perform update/delete on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle collection of cart items for the user -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Check if an item with same productId and variationId exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId, variationId: variationId || null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + quantity },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId,
            quantity,
            // Optionally, store additional fields if desired
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
" "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
  cartItems CartItem[]
}

// 

model CartItem {
  id        Int      @id @default(autoincrement())
  userId    Int
  productId Int
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"

Below is a revised unified API file (located at pages/api/cart.ts) that combines all cart operations into one endpoint. In this update, we explicitly convert fields (like productId and quantity) to numbers so that Prisma can process them correctly. This should help resolve your 500 error when making a POST request.

Make sure you’ve run your migration so that the CartItem model is present in your database. Also, adjust any fields as needed for your application.

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is present, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

Explanation

    Token Verification:
    The code extracts and verifies the JWT token from the cookies. If verification fails, it returns a 401 error.

    Query Handling:
        If a query parameter clear is present with DELETE, it clears all cart items for the current user.
        If an id is provided, the endpoint will update (PUT) or delete (DELETE) that specific cart item after verifying ownership.

    GET Request:
    Returns all cart items for the current user along with the related product translations.

    POST Request:
    Checks for required fields, ensures numeric conversion for productId and quantity, then either updates an existing cart item (if one exists with the same productId and variationId) or creates a new one.

    Unified Endpoint:
    All cart operations (GET, POST, PUT, DELETE, and clear) are combined into a single file at pages/api/cart.ts.

Make sure you adjust any additional fields as needed, and that your Prisma schema is up-to-date. This unified approach should resolve the 500 error you encountered during POST operations.
You said:
Still get " GET /_next/data/development/en/products/2.json?id=2 200 in 211ms
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:134:14)
  132 |       return res.status(201).json(cartItem);
  133 |     } catch (err: any) {
> 134 |       console.error("Error in POST /api/cart:", err);
      |              ^
  135 |       return res.status(500).json({ error: "Error adding cart item" });
  136 |     }
  137 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:134:14)
  132 |       return res.status(201).json(cartItem);
  133 |     } catch (err: any) {
> 134 |       console.error("Error in POST /api/cart:", err);
      |              ^
  135 |       return res.status(500).json({ error: "Error adding cart item" });
  136 |     }
  137 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 POST /api/cart 500 in 453ms
"  where adding to cart form product detial page : "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const { payload: decoded } = await jwtVerify(
      tokenStr,
      new TextEncoder().encode(secret)
    );
    payload = decoded as unknown as DecodedPayload;
  } catch (err: any) {
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is present, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
"  "// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(/api/cart/${existingItem.id}, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(/api/cart/${item.id}, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}
"

Below is an updated version of your unified /api/cart.ts endpoint. In this version, we add extra checks for the decoded token payload so that if the payload is null (or not an object), we throw an error before proceeding. This should help prevent the "payload argument must be of type object. Received null" error.

Make sure that your token is being set correctly in your cookies and that your NEXTAUTH_SECRET is correctly defined.

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is present, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

What Changed?

    Additional Checks on JWT Verification:
    We now check that the result of jwtVerify has a non‑null payload of type object before proceeding. If not, we throw an error.
    Error Logging:
    We log the error if JWT verification fails, which helps pinpoint issues with token generation or transmission.
    Numeric Conversions:
    We explicitly convert productId, quantity, and other numeric fields using Number(), ensuring that Prisma receives the correct types.

Next Steps

    Ensure that your NEXTAUTH_SECRET is correctly set in your environment.
    Verify that your token is being set in the cookies. You can inspect your cookies in the browser’s developer tools.
    Test the endpoint with a valid token (using Postman or your app) to ensure that the cart operations work as expected.

This updated endpoint should help resolve the 500 error and the payload error you encountered when adding a cart item from the product detail page.
You said:
still get " GET /api/cart 200 in 119ms
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:135:14)
  133 |       return res.status(201).json(cartItem);
  134 |     } catch (err: any) {
> 135 |       console.error("Error in POST /api/cart:", err);
      |              ^
  136 |       return res.status(500).json({ error: "Error adding cart item" });
  137 |     }
  138 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:135:14)
  133 |       return res.status(201).json(cartItem);
  134 |     } catch (err: any) {
> 135 |       console.error("Error in POST /api/cart:", err);
      |              ^
  136 |       return res.status(500).json({ error: "Error adding cart item" });
  137 |     }
  138 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 POST /api/cart 500 in 519ms

"  . "// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(/api/cart/${existingItem.id}, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(/api/cart/${item.id}, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is present, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
"  ensure ifeverything is alligned either with the cart model in prisma : "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
  cartItems CartItem[]
}

// 

model CartItem {
  id        Int      @id @default(autoincrement())
  userId    Int
  productId Int
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"

The error indicates that when our endpoint is handling a POST request, the decoded JWT payload is coming back as null (or not an object) even though we expect it to be valid. This may mean that:

• The token sent with the POST request is missing or malformed.
• NEXTAUTH_SECRET isn’t set properly in your environment, or the token’s payload isn’t structured as expected.

To help diagnose and fix this, we can add extra logging and checks. Below is an updated unified API file for /api/cart.ts with more robust error handling and logging to ensure that the token’s payload is indeed an object before proceeding. Please verify that your NextAuth configuration is generating tokens with a valid payload (an object with at least an id field) and that your environment variable NEXTAUTH_SECRET is correctly set.

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    // Ensure the payload is an object and not null.
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is provided, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: {
          userId,
          productId: prodId,
          variationId: variationId ? Number(variationId) : null,
        },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

Next Steps and Debugging Tips

    Check NEXTAUTH_SECRET:
    Verify that your environment variable NEXTAUTH_SECRET is correctly set and is the same one used by NextAuth for signing tokens.

    Inspect the Token:
    In your browser’s developer tools, check the cookie named next-auth.session-token or __Secure-next-auth.session-token to ensure it contains a valid JWT. You might decode it using an online JWT decoder to confirm it has a valid payload.

    Add Logging:
    If the error persists, add further logging before the jwtVerify call (or use a debugger) to see the raw token string. This can help determine if the token is malformed or missing.

    Test with a Known Valid Token:
    You can temporarily hardcode a valid token (from your JWT generation logic) to test the endpoint in isolation.

This unified endpoint now combines all cart operations in one file and includes extra checks for the JWT payload. With these changes and verification of your environment and token, the error should be resolved.
You said:
ensure consistency between the product details add to cart button with cart context with  the cart api: "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
            image: selectedImage,
            productId: productData.id,
            variationId: undefined,
            sku: productData.sku,
            name: productTranslation?.name || "Bijou personnalisé",
            price: totalPrice,
            quantity: 1,
        });
    };

    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
"  "// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(/api/cart/${existingItem.id}, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(/api/cart/${item.id}, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // ----- 1. Verify User via Token -----
  console.log("--- CART API START ---");
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    // Ensure the payload is an object and not null.
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  // ----- 2. Handle Query Parameters -----
  // If an "id" query parameter is provided, operate on that specific cart item.
  const { id, clear } = req.query;

  // ----- 3. Clear Cart: DELETE with query parameter clear -----
  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  // ----- 4. Specific Cart Item Operations (if id is provided) -----
  if (id) {
    const cartItemId = Number(id);
    // Ensure the cart item belongs to the current user
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  // ----- 5. Handle Collection of Cart Items for the User -----
  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      // Ensure numeric values
      const prodId = Number(productId);
      const qty = Number(quantity);
      // Check if an identical item exists for this user
      const existing = await prisma.cartItem.findFirst({
        where: {
          userId,
          productId: prodId,
          variationId: variationId ? Number(variationId) : null,
        },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
"

The error indicates that when a POST request is made to our unified cart API, the token’s payload is coming back as null—this usually happens when no valid session token is sent with the request.

To ensure consistency between your product detail “Ajouter au Panier” button, your CartContext, and the Cart API, you must guarantee that:

    The user is logged in (and thus has a valid session token).
        If no session exists, either disable the “Add to Cart” button or fall back to localStorage.
    Your API endpoint correctly validates the token.
        Our endpoint checks that the decoded payload is an object. If it’s null, that means the token wasn’t properly set.

How to Fix It
1. Ensure Users Are Authenticated Before Adding Items

In your CartContext’s addToCart function, check if a session exists before calling the API. For example, if there’s no valid session, you can show an error or redirect to the login page. For instance:

async function addToCart(item: CartItem) {
  if (!session?.user?.email) {
    console.error("User not authenticated. Cannot persist cart item.");
    // Optionally, you might want to redirect or show a message.
    return;
  }
  // ... rest of your addToCart logic
}

This prevents unauthenticated requests from reaching your API endpoint where the token verification fails.
2. Update Your API Endpoint (Optional)

If you want to allow guest cart functionality (using localStorage) while still having a persistent cart for logged‑in users, you could adjust your API endpoint to handle the missing token gracefully. However, the recommended approach is to require authentication for persistent cart operations. In our API, we already return a 401 if no token is found.
3. Verify NEXTAUTH_SECRET and Token in Cookies

Double‑check that your environment variable NEXTAUTH_SECRET is correctly set and that the token is properly stored in your cookies. You can inspect your cookies in your browser’s developer tools to see if the token is present and valid.
Final Unified /api/cart.ts Endpoint

Here’s our final unified cart API file with the extra check and error logging. (Make sure you have the session check in your CartContext as shown above.)

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- CART API START ---");
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  const { id, clear } = req.query;

  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  if (id) {
    const cartItemId = Number(id);
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }
    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }
    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      const prodId = Number(productId);
      const qty = Number(quantity);
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

Ensure Consistency on the Product Details Page

Your product details page’s "Ajouter au Panier" button calls handleAddToCart from the CartContext, which then sends a POST request to /api/cart. Make sure that:

    The user is logged in (a valid session exists) so that the token is sent with the request.
    The data passed (such as productId, sku, etc.) matches your API expectations.

For example, your handleAddToCart function from the product page should look like this:

const handleAddToCart = () => {
  addToCart({
    image: selectedImage,
    productId: productData.id,
    variationId: undefined,
    sku: productData.sku,
    name: productTranslation?.name || "Bijou personnalisé",
    price: totalPrice,
    quantity: 1,
  });
};

And in your CartContext, before calling addToCart, you might want to check that a session exists:

async function addToCart(item: CartItem) {
  if (!session?.user?.email) {
    console.error("User not authenticated. Please log in to add items to the cart.");
    return;
  }
  // ... rest of addToCart logic
}

Final Notes

    Authentication Requirement:
    Persistent cart operations now require a valid session token. Ensure that your users are logged in before they can add items to the persistent cart.

    NEXTAUTH_SECRET:
    Double-check your NEXTAUTH_SECRET environment variable and verify that the token in your cookies is valid.

    Debugging:
    Use logging (as shown) to inspect the token and payload. If the payload is still null, check your token generation in NextAuth and ensure that your client is sending the cookie with each request.

With these adjustments, your product details “Ajouter au Panier” button, CartContext, and unified Cart API should work consistently using the persistent CartItem model.
You said:
Still getting : "// pages/products/[id].tsx

import { GetServerSideProps } from "next";
import { prisma } from "../../lib/prisma";
import Image from "next/image";
import { useState, useMemo } from "react";
import { useCart } from "../../contexts/CartContext";
import { NextSeo } from "next-seo";
import { motion } from "framer-motion";
import Link from "next/link";
import ProductCard from "../../components/ProductCard";

type ProductTranslation = {
    language: string;
    name: string;
    description: string;
};

type ProductVariation = {
    id: number;
    variationType: string;
    variationValue: string;
    additionalPrice: string;
};

type ProductData = {
    id: number;
    sku: string;
    basePrice: string;
    images: string[];
    translations: ProductTranslation[];
    variations: ProductVariation[];
    categoryId?: number | null; // In case you store categoryId for matching
};

type ProductPageProps = {
    productData: ProductData | null;
    similarProducts: ProductData[];
    locale: string;
};

export default function ProductPage({
                                        productData,
                                        similarProducts,
                                        locale,
                                    }: ProductPageProps) {
    const { addToCart } = useCart();

    // ──────────────────────────────────────────
    // 1) Basic Checks
    // ──────────────────────────────────────────
    if (!productData) {
        return (
            <section className="py-12 px-6 section-dark">
                <h1 className="text-5xl font-serif text-brandGold mb-4">
                    Création Introuvable
                </h1>
                <p className="text-platinumGray">
                    La pièce que vous recherchez n’est plus disponible.
                </p>
            </section>
        );
    }

    // ──────────────────────────────────────────
    // 2) Translation
    // ──────────────────────────────────────────
    const productTranslation =
        productData.translations.find((t) => t.language === locale) ||
        productData.translations.find((t) => t.language === "fr") ||
        productData.translations.find((t) => t.language === "en");

    // ──────────────────────────────────────────
    // 3) Variation Selections
    // ──────────────────────────────────────────
    const [selectedVariations, setSelectedVariations] = useState<{
        [key: string]: ProductVariation;
    }>({});

    function updateVariation(variation: ProductVariation) {
        setSelectedVariations((prev) => ({
            ...prev,
            [variation.variationType]: variation,
        }));
    }

    // ──────────────────────────────────────────
    // 4) Pricing
    // ──────────────────────────────────────────
    const basePriceNum = parseFloat(productData.basePrice || "0");
    const additionalPriceSum = useMemo(() => {
        let sum = 0;
        Object.values(selectedVariations).forEach((v) => {
            sum += parseFloat(v.additionalPrice || "0");
        });
        return sum;
    }, [selectedVariations]);

    const totalPrice = basePriceNum + additionalPriceSum;

    // ──────────────────────────────────────────
    // 5) Selected Image
    // ──────────────────────────────────────────
    const [selectedImage, setSelectedImage] = useState(
        productData.images[0] || "/images/placeholder.jpg"
    );

    // ──────────────────────────────────────────
    // 6) Shipping Info (1 Month from Now)
    // ──────────────────────────────────────────
    const currentDate = new Date();
    const shippingDate = new Date(
        currentDate.setMonth(currentDate.getMonth() + 1)
    );
    const shippingDateStr = shippingDate.toLocaleDateString(locale || "fr", {
        year: "numeric",
        month: "long",
        day: "numeric",
    });

    // ──────────────────────────────────────────
    // 7) Summary of Selections
    // ──────────────────────────────────────────
    const selectionSummary = Object.values(selectedVariations)
        .map((v) => ${v.variationType}: ${v.variationValue})
        .join(" | ");

    // ──────────────────────────────────────────
    // 8) Add to Cart
    // ──────────────────────────────────────────
    const handleAddToCart = () => {
        addToCart({
          image: selectedImage,
          productId: productData.id,
          variationId: undefined,
          sku: productData.sku,
          name: productTranslation?.name || "Bijou personnalisé",
          price: totalPrice,
          quantity: 1,
        });
      };
      
    return (
        <>
            <NextSeo
                title={Diamant Rouge | ${productTranslation?.name}}
                description={productTranslation?.description}
                openGraph={{
                    title: Diamant Rouge | ${productTranslation?.name},
                    description: productTranslation?.description,
                }}
            />

            {/** ─────────────────────────────────────────
             MAIN PRODUCT SECTION
             ───────────────────────────────────────── */}
            <motion.section
                className="py-16 px-6 grid grid-cols-1 md:grid-cols-2 gap-16 text-left"
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6 }}
            >
                {/* LEFT: Images */}
                <div>
                    {/* Main Image */}
                    <div className="relative w-full h-auto mb-4">
                        <Image
                            src={selectedImage}
                            width={700}
                            height={700}
                            alt={productTranslation?.name || "Bijou Diamant Rouge"}
                            className="rounded-lg shadow-luxury"
                        />
                    </div>

                    {/* Thumbnails */}
                    <div className="flex gap-3 overflow-x-auto">
                        {productData.images.map((img, index) => {
                            const isSelected = selectedImage === img;
                            return (
                                <button
                                    key={index}
                                    onClick={() => setSelectedImage(img)}
                                    className={border rounded-lg overflow-hidden ${
                                        isSelected ? "border-brandGold" : "border-transparent"
                                    }}
                                >
                                    <Image
                                        src={img}
                                        width={80}
                                        height={80}
                                        alt={Miniature ${index}}
                                        className="object-cover"
                                    />
                                </button>
                            );
                        })}
                    </div>
                </div>

                {/* RIGHT: Info & Customization */}
                <div>
                    {/* Title & Price */}
                    <h1 className="text-4xl font-serif text-richEbony mb-2">
                        {productTranslation?.name}
                    </h1>
                    <p className="text-2xl text-brandGold font-bold mb-2">
                        {totalPrice.toFixed(2)} MAD
                    </p>
                    <hr className="border-platinumGray mb-4" />

                    {/* Description */}
                    <div className="text-platinumGray mb-6">
                        {productTranslation?.description}
                    </div>

                    {/* Material Details */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Détails du Matériau
                        </h3>
                        <p className="text-platinumGray text-sm">
                            Chaque création Diamant Rouge est façonnée à partir de métaux
                            nobles et de pierres précieuses soigneusement sélectionnées.
                        </p>
                    </div>

                    {/* Personalization Options */}
                    <div className="mb-6">
                        <h3 className="text-lg font-semibold text-richEbony mb-2">
                            Personnalisation
                        </h3>
                        {[
                            "diamondShape",
                            "carat",
                            "quality",
                            "coupe",
                            "metalColor",
                            "ringSize",
                        ].map((type) => {
                            const variationGroup = productData.variations.filter(
                                (v) => v.variationType === type
                            );
                            if (variationGroup.length === 0) return null;

                            return (
                                <div key={type} className="mb-4">
                                    <p className="font-medium text-sm text-richEbony mb-1">
                                        {getVariationLabel(type)}
                                    </p>
                                    <div className="flex flex-wrap gap-3">
                                        {variationGroup.map((variation) => {
                                            const isSelected =
                                                selectedVariations[type]?.id === variation.id;
                                            return (
                                                <button
                                                    key={variation.id}
                                                    onClick={() => updateVariation(variation)}
                                                    className={px-3 py-1 rounded-full border transition
                            ${
                                                        isSelected
                                                            ? "bg-burgundy text-brandIvory border-burgundy"
                                                            : "bg-brandIvory text-richEbony border-burgundy"
                                                    }
                          }
                                                >
                                                    {variation.variationValue}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Summary of Selections */}
                    {selectionSummary && (
                        <div className="mb-6">
                            <p className="text-sm text-platinumGray">
                                <strong>Votre configuration:</strong> {selectionSummary}
                            </p>
                        </div>
                    )}

                    {/* Shipping Info */}
                    <div className="mb-6">
                        <p className="text-sm text-platinumGray">
                            Livraison estimée autour du {shippingDateStr}
                        </p>
                    </div>

                    {/* Paiement Sécurisé */}
                    <div className="flex items-center gap-2 bg-burgundy/10 p-3 rounded-md mb-4">
                        <p className="text-sm text-richEbony font-semibold">
                            Paiement Sécurisé
                        </p>
                        <Image
                            src="/images/icons/img.icons8.png"
                            width={40}
                            height={24}
                            alt="Visa"
                        />
                        <Image
                            src="/images/icons/mastercard-old.svg"
                            width={40}
                            height={24}
                            alt="Mastercard"
                        />
                    </div>

                    {/* Buttons: "Try in Showroom" & "Add to Cart" */}
                    <div className="flex flex-wrap gap-4">
                        <Link href="/appointments" passHref>
                            <button
                                className="
                  button-secondary
                  px-6 py-3
                  font-medium
                  rounded-full
                  transition
                  w-full sm:w-auto
                "
                            >
                                Essayer en Showroom
                            </button>
                        </Link>
                        <button
                            onClick={handleAddToCart}
                            className="
                button-primary
                px-6 py-3
                font-medium
                rounded-full
                transition
                w-full sm:w-auto
              "
                        >
                            Ajouter au Panier ({totalPrice.toFixed(2)} MAD)
                        </button>
                    </div>
                </div>
            </motion.section>

            {/** ─────────────────────────────────────────
             SIMILAR PRODUCTS SECTION
             ───────────────────────────────────────── */}
            {similarProducts.length > 0 && (
                <motion.section
                    className="py-12 px-6 text-center"
                    initial={{ opacity: 0, y: 50 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6 }}
                    viewport={{ once: true }}
                >
                    <h2 className="text-2xl font-serif text-brandGold mb-6">
                        Vous aimerez peut-être
                    </h2>
                    <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 gap-6 justify-items-center">
                        {similarProducts.map((product) => (
                            <ProductCard key={product.id} product={product} />
                        ))}
                    </div>
                </motion.section>
            )}
        </>
    );
}

// Helper function to label your variation types in French
function getVariationLabel(type: string): string {
    switch (type) {
        case "diamondShape":
            return "Forme du diamant";
        case "carat":
            return "Carat";
        case "quality":
            return "Qualité";
        case "coupe":
            return "Coupe";
        case "metalColor":
            return "Couleur du métal";
        case "ringSize":
            return "Taille de bague";
        default:
            return type;
    }
}

/* ───────────────────────────────────────────────────────────────────────────
   ✅ getServerSideProps
   Fetch product, find similar products, pass to the page
──────────────────────────────────────────────────────────────────────────── */
export const getServerSideProps: GetServerSideProps = async (context) => {
    const id = parseInt(context.params?.id as string, 10);
    if (isNaN(id)) return { notFound: true };

    const product = await prisma.product.findUnique({
        where: { id },
        include: {
            translations: true,
            variations: true,
            category: true, // if you have a category relation
        },
    });

    if (!product) {
        return { notFound: true };
    }

    // Convert Decimal fields to string
    const productData = {
        ...product,
        basePrice: product.basePrice.toString(),
        variations: product.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    };

    // ─────────────────────────────────────────────────
    // Fetch "Similar Products"
    // e.g. same category (excluding current product)
    // If product.categoryId is null, we can just pick random or top new arrivals
    let similarProducts = [];
    if (product.categoryId) {
        similarProducts = await prisma.product.findMany({
            where: {
                categoryId: product.categoryId,
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    } else {
        // fallback: just get some random products
        similarProducts = await prisma.product.findMany({
            where: {
                id: { not: product.id },
            },
            take: 5,
            include: {
                translations: true,
                variations: true,
            },
        });
    }

    // Convert decimals in similar products
    const similarProductsData = similarProducts.map((p) => ({
        ...p,
        basePrice: p.basePrice.toString(),
        variations: p.variations.map((v) => ({
            ...v,
            additionalPrice: v.additionalPrice.toString(),
        })),
    }));

    return {
        props: {
            productData: JSON.parse(JSON.stringify(productData)),
            similarProducts: JSON.parse(JSON.stringify(similarProductsData)),
            locale: context.locale || "fr",
        },
    };
};
"  "// contexts/CartContext.tsx

import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { useSession } from "next-auth/react";

export type CartItem = {
  id?: number; // ID returned from persistent storage
  productId: number;
  variationId?: number;
  sku: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
};

type CartContextType = {
  cart: CartItem[];
  addToCart: (item: CartItem) => Promise<void>;
  removeFromCart: (productId: number, variationId?: number) => Promise<void>;
  clearCart: () => Promise<void>;
  refreshCart: () => Promise<void>;
};

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const { data: session } = useSession();
  const [cart, setCart] = useState<CartItem[]>([]);

  // Fetch persistent cart from the server
  async function fetchCartFromServer() {
    if (!session?.user?.email) {
      setCart([]);
      return;
    }
    try {
      const res = await fetch("/api/cart");
      if (res.ok) {
        const data = await res.json();
        setCart(data);
      } else {
        console.error("Failed to fetch cart items.");
      }
    } catch (err) {
      console.error("Error fetching cart:", err);
    }
  }

  // Load cart when session changes
  useEffect(() => {
    fetchCartFromServer();
  }, [session]);

  // Add item to cart – update quantity if already exists, else create new
  async function addToCart(item: CartItem) {
    if (!session?.user?.email) {
        console.error("User not authenticated. Please log in to add items to the cart.");
        return;
      }
    const existingItem = cart.find(
      (p) => p.productId === item.productId && p.variationId === item.variationId
    );
    if (existingItem && existingItem.id) {
      // Update quantity via PUT
      try {
        const res = await fetch(/api/cart/${existingItem.id}, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ quantity: existingItem.quantity + item.quantity }),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error updating cart item:", err);
      }
    } else {
      // Create new cart item via POST
      try {
        const res = await fetch("/api/cart", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item),
        });
        if (res.ok) {
          await fetchCartFromServer();
        }
      } catch (err) {
        console.error("Error adding cart item:", err);
      }
    }
  }

  // Remove an item from cart
  async function removeFromCart(productId: number, variationId?: number) {
    const item = cart.find(
      (p) => p.productId === productId && p.variationId === variationId
    );
    if (!item || !item.id) return;
    try {
      const res = await fetch(/api/cart/${item.id}, {
        method: "DELETE",
      });
      if (res.ok) {
        await fetchCartFromServer();
      }
    } catch (err) {
      console.error("Error removing cart item:", err);
    }
  }

  // Clear all items in the cart
  async function clearCart() {
    try {
      const res = await fetch("/api/cart/clear", {
        method: "DELETE",
      });
      if (res.ok) {
        setCart([]);
      }
    } catch (err) {
      console.error("Error clearing cart:", err);
    }
  }

  // Manual refresh (if needed)
  async function refreshCart() {
    await fetchCartFromServer();
  }

  return (
    <CartContext.Provider value={{ cart, addToCart, removeFromCart, clearCart, refreshCart }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error("useCart must be used within a CartProvider");
  }
  return context;
}
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- CART API START ---");
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  const { id, clear } = req.query;

  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  if (id) {
    const cartItemId = Number(id);
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }
    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }
    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }
    return res.status(405).json({ error: "Method Not Allowed" });
  }

  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      const prodId = Number(productId);
      const qty = Number(quantity);
      const existing = await prisma.cartItem.findFirst({
        where: { userId, productId: prodId, variationId: variationId ? Number(variationId) : null },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
"

The error message indicates that when your POST request is made to the cart API, the token payload is coming back as null. This usually happens because the token (stored in a cookie) isn’t being sent along with the fetch request. In a same‑origin scenario, fetch will send credentials (cookies) automatically, but if that’s not happening you need to explicitly include them.

Here are some steps and adjustments to help resolve the issue:
1. Ensure Cookies Are Sent with Fetch Requests

Update your CartContext (and any other client‑side fetch calls) so that they include credentials. For example, in every fetch call, add the option:

{ credentials: "include" }

For instance, change your fetch calls in CartContext like this:

async function fetchCartFromServer() {
  if (!session?.user?.email) {
    setCart([]);
    return;
  }
  try {
    const res = await fetch("/api/cart", { credentials: "include" });
    if (res.ok) {
      const data = await res.json();
      setCart(data);
    } else {
      console.error("Failed to fetch cart items.");
    }
  } catch (err) {
    console.error("Error fetching cart:", err);
  }
}

And update your POST, PUT, and DELETE calls similarly:

const res = await fetch("/api/cart", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  credentials: "include",
  body: JSON.stringify(item),
});

This ensures that the cookie containing your NextAuth token is included in the request.
2. Check That the User Is Authenticated

In your CartContext’s addToCart function, you already check for session?.user?.email. Make sure that the user is actually logged in when they click “Ajouter au Panier”. If the user is not authenticated, the cookie won’t be sent, and jwtVerify will receive a null token payload.

For example, you can add a guard:

async function addToCart(item: CartItem) {
  if (!session?.user?.email) {
    console.error("User not authenticated. Please log in to add items to the cart.");
    return;
  }
  // ... rest of your addToCart logic
}

3. Verify Your NEXTAUTH_SECRET and Token Format

Double‑check that your NEXTAUTH_SECRET environment variable is correctly set and that your NextAuth configuration is generating a token with a valid payload (an object with at least an id field). You can inspect your browser cookies (look for next-auth.session-token or __Secure-next-auth.session-token) to verify that a JWT is present and decodable.
4. Final Unified API Code

Below is your updated /api/cart.ts endpoint with no changes in the core logic but with our logging and our expectation that the token is now being sent:

// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- CART API START ---");
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    // Ensure payload is valid
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  const { id, clear } = req.query;

  if (req.method === "DELETE" && clear) {
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  if (id) {
    const cartItemId = Number(id);
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  if (req.method === "GET") {
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      const prodId = Number(productId);
      const qty = Number(quantity);
      const existing = await prisma.cartItem.findFirst({
        where: {
          userId,
          productId: prodId,
          variationId: variationId ? Number(variationId) : null,
        },
      });
      let cartItem;
      if (existing) {
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}

Next Steps

    Update Your Client-Side Fetches:
    Ensure every fetch call in your CartContext (and elsewhere) includes { credentials: "include" } so that the token cookie is sent.

    Verify Your Token:
    Inspect the token in your browser’s developer tools to confirm it exists and contains a payload. Use an online JWT decoder if needed.

    Test in a Logged-In Session:
    Make sure you are logged in (with a valid session) before clicking the “Ajouter au Panier” button.

With these changes, your product details page’s "Ajouter au Panier" button should work consistently with your CartContext and the unified Cart API.
You said:
Still getting : "
--- CART API START ---
Authenticated user ID: 1
 POST {}
Adding cart item for user ID: 1
Adding cart item: {
  image: '/uploads/1739061754329-94cvscub.png',
  productId: 2,
  sku: 'IMPERIAL-BRACELET-001',
  name: 'Imperial Gold Bracelet',
  price: 2999.99,
  quantity: 1
}
Checking existing cart item
prisma:query SELECT 1
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:153:14)
  151 |       return res.status(201).json(cartItem);
  152 |     } catch (err: any) {
> 153 |       console.error("Error in POST /api/cart:", err);
      |              ^
  154 |       return res.status(500).json({ error: "Error adding cart item" });
  155 |     }
  156 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 ⨯ TypeError: The "payload" argument must be of type object. Received null
    at handler (pages/api/cart.ts:153:14)
  151 |       return res.status(201).json(cartItem);
  152 |     } catch (err: any) {
> 153 |       console.error("Error in POST /api/cart:", err);
      |              ^
  154 |       return res.status(500).json({ error: "Error adding cart item" });
  155 |     }
  156 |   } {
  code: 'ERR_INVALID_ARG_TYPE',
  page: '/api/cart'
}
 POST /api/cart 500 in 242ms

"  the problem is when quering checking existing cart items . : "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
  cartItems CartItem[]
}

// 

model CartItem {
  id        Int      @id @default(autoincrement())
  userId    Int
  productId Int
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"  "// pages/api/cart.ts

import { NextApiRequest, NextApiResponse } from "next";
import { prisma } from "../../lib/prisma";
import { jwtVerify } from "jose";

interface DecodedPayload {
  id: string;
  role: string;
  email: string;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  console.log("--- CART API START ---");
  const rawCookie = req.headers.cookie || "";
  let match =
    rawCookie.match(/next-auth\.session-token=([^;]+)/) ||
    rawCookie.match(/__Secure-next-auth\.session-token=([^;]+)/);
  if (!match) {
    return res.status(401).json({ error: "Unauthorized: No token found" });
  }
  const tokenStr = decodeURIComponent(match[1]);
  const secret = process.env.NEXTAUTH_SECRET || "";
  let payload: DecodedPayload;
  try {
    const decodedResult = await jwtVerify(tokenStr, new TextEncoder().encode(secret));
    // Ensure payload is valid
    if (!decodedResult || typeof decodedResult.payload !== "object" || decodedResult.payload === null) {
      console.error("Decoded token payload is null or invalid:", decodedResult);
      throw new Error("Token payload is null or invalid");
    }
    payload = decodedResult.payload as unknown as DecodedPayload;
  } catch (err: any) {
    console.error("JWT verification error:", err);
    return res.status(401).json({ error: "Unauthorized: Invalid token" });
  }
  const userId = Number(payload.id);
  console.log(Authenticated user ID: ${userId});
  if (isNaN(userId)) {
    console.error("User ID is not a valid number:", payload.id);
    return res.status(401).json({ error: "Unauthorized: Invalid user ID in token" });
  }

  const { id, clear } = req.query;
  console.log("", req.method, req.query);

  if (req.method === "DELETE" && clear) {
    console.log("Clearing cart for user ID:", userId);
    try {
      await prisma.cartItem.deleteMany({ where: { userId } });
      return res.status(200).json({ message: "Cart cleared successfully" });
    } catch (err: any) {
      console.error("Error clearing cart:", err);
      return res.status(500).json({ error: "Failed to clear cart" });
    }
  }

  if (id) {
    const cartItemId = Number(id);
    const cartItem = await prisma.cartItem.findUnique({ where: { id: cartItemId } });
    if (!cartItem || cartItem.userId !== userId) {
      return res.status(403).json({ error: "Forbidden: You don't own this cart item" });
    }

    if (req.method === "PUT") {
        console.log("Updating cart item:", cartItemId);
      const { quantity } = req.body;
      if (quantity === undefined) {
        return res.status(400).json({ error: "Quantity is required" });
      }
      try {
        const updated = await prisma.cartItem.update({
          where: { id: cartItemId },
          data: { quantity: cartItem.quantity + Number(quantity) },
        });
        return res.status(200).json(updated);
      } catch (err: any) {
        console.error("Error updating cart item:", err);
        return res.status(500).json({ error: "Failed to update cart item" });
      }
    }

    if (req.method === "DELETE") {
        console.log("Deleting cart item:", cartItemId);
      try {
        await prisma.cartItem.delete({ where: { id: cartItemId } });
        return res.status(200).json({ message: "Cart item deleted successfully" });
      } catch (err: any) {
        console.error("Error deleting cart item:", err);
        return res.status(500).json({ error: "Failed to delete cart item" });
      }
    }

    return res.status(405).json({ error: "Method Not Allowed" });
  }

  if (req.method === "GET") {
    console.log("Fetching cart items for user ID:", userId);
    try {
      const cartItems = await prisma.cartItem.findMany({
        where: { userId },
        include: {
          product: {
            include: { translations: true },
          },
        },
      });
      return res.status(200).json(cartItems);
    } catch (err: any) {
      console.error("Error fetching cart items:", err);
      return res.status(500).json({ error: "Error fetching cart items" });
    }
  }

  if (req.method === "POST") {
    console.log("Adding cart item for user ID:", userId);
    const { productId, variationId, sku, name, price, quantity, image } = req.body;
    console.log("Adding cart item:", req.body);
    if (!productId || !sku || !name || !price || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    try {
      const prodId = Number(productId);
      const qty = Number(quantity);
      console.log("Checking existing cart item");
      const existing = await prisma.cartItem.findFirst({
        where: {
          userId,
          productId: prodId,
          variationId: variationId ? Number(variationId) : null,
        },
      });
      let cartItem;
      if (existing) {
        console.log("Updating existing cart item:", existing.id);
        cartItem = await prisma.cartItem.update({
          where: { id: existing.id },
          data: { quantity: existing.quantity + qty },
        });
      } else {
        console.log("Creating new cart item");
        cartItem = await prisma.cartItem.create({
          data: {
            userId,
            productId: prodId,
            quantity: qty,
          },
        });
      }
      console.log("Cart item added:", cartItem);
      return res.status(201).json(cartItem);
    } catch (err: any) {
      console.error("Error in POST /api/cart:", err);
      return res.status(500).json({ error: "Error adding cart item" });
    }
  }

  return res.status(405).json({ error: "Method Not Allowed" });
}
"

The error you're seeing ("The 'payload' argument must be of type object. Received null") is likely caused by a mismatch between the data your API expects and what’s defined in your Prisma schema. In your CartContext and API you use a field called variationId, but your CartItem model does not include it. This mismatch can lead to unexpected behavior when your code passes a value (or null) for variationId.

To fix this, update your Prisma schema for CartItem to include an optional variationId field. Then run a migration so that your database schema matches your application code.

For example, update your prisma/schema.prisma like this:

model CartItem {
  id          Int      @id @default(autoincrement())
  userId      Int
  productId   Int
  variationId Int?     // ← Add this optional field
  quantity    Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id])
  product     Product  @relation(fields: [productId], references: [id])
}

After editing your schema, run:

npx prisma format
npx prisma migrate dev --name "add_variationId_to_cartitem"

Once your schema is updated and the migration is applied, your API endpoint (and CartContext) will have a field for variationId. This should resolve the error when adding a cart item from the product details page.
Next Steps

    Ensure your client requests send cookies:
    Make sure that fetch requests in your CartContext include { credentials: "include" } so that your session token is passed to the API.

    Test the Endpoint:
    After migrating your schema, test adding a cart item again from the product details page. You should no longer see the payload error.

This update should align your persistent cart system (CartContext, API, and Prisma model) and resolve the error.
You said:
shouldn't the variation from the cart point to the productVariation model in prisma ? "// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------------------------------------
// PRODUCT & TRANSLATIONS
// --------------------------------------------------------------------
model Product {
  id           Int                  @id @default(autoincrement())
  sku          String               @unique
  basePrice    Decimal              @default(0.0)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  categoryId   Int?
  images       String[]             @default([])
  translations ProductTranslation[]
  category     Category?            @relation(fields: [categoryId], references: [id])
  variations   ProductVariation[]
  wishlists    Wishlist[]
  orderItems   OrderItem[]
  cartItems    CartItem[]
}

model ProductTranslation {
  id          Int     @id @default(autoincrement())
  language    String
  name        String
  description String
  productId   Int
  product     Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// CATEGORY & TRANSLATIONS
// --------------------------------------------------------------------
model Category {
  id        Int      @id @default(autoincrement())
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  translations CategoryTranslation[]
  products     Product[]
}

model CategoryTranslation {
  id          Int      @id @default(autoincrement())
  language    String
  name        String
  description String?
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id])
}

// --------------------------------------------------------------------
// PRODUCT VARIATIONS
// (e.g., ring sizes, gem types, metal colors, etc.)
// --------------------------------------------------------------------
model ProductVariation {
  id              Int     @id @default(autoincrement())
  productId       Int
  variationType   String
  variationValue  String
  additionalPrice Decimal @default(0.0)
  inventory       Int     @default(0)

  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// USER TABLE
// --------------------------------------------------------------------
model User {
  id          Int     @id @default(autoincrement())
  email       String  @unique
  password    String
  name        String?
  role        String  @default("customer")
  phoneNumber String?
  address     String?
  city        String?
  postalCode  String?
  country     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders    Order[]
  wishlists Wishlist[]
  cartItems CartItem[]
}

// 

model CartItem {
  id        Int      @id @default(autoincrement())
  userId    Int
  productId Int
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
"

Yes – if a cart item may include a specific variation (for example, a particular ring size or metal color), it’s best to store a reference to that variation. In other words, the CartItem should have an optional field (for example, variationId) that points to the ProductVariation model. This makes it easy to join data later and ensure referential integrity.

You can update your Prisma schema like so:

model CartItem {
  id           Int      @id @default(autoincrement())
  userId       Int
  productId    Int
  variationId  Int?     // Optional field for the selected variation
  quantity     Int      @default(1)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id])
  product      Product  @relation(fields: [productId], references: [id])
  variation    ProductVariation? @relation(fields: [variationId], references: [id])
}


// --------------------------------------------------------------------
// ORDER & ORDER ITEMS
// (Basic placeholder for future expansions)
// --------------------------------------------------------------------
model Order {
  id            Int      @id @default(autoincrement())
  userId        Int?
  totalAmount   Decimal  @default(0.0)
  status        String   @default("PENDING") // Could be PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  paymentMethod String // ✅ NEW: Added Payment Method Field
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Added shipping details
  shippingAddress String?
  city            String?
  postalCode      String?
  country         String?

  user       User?       @relation(fields: [userId], references: [id])
  orderItems OrderItem[]
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  productId Int
  quantity  Int     @default(1)
  price     Decimal @default(0.0)

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // For more detail, you might also link to a specific variation if needed
}

// --------------------------------------------------------------------
// WISHLIST TABLE
// --------------------------------------------------------------------
model Wishlist {
  id        Int @id @default(autoincrement())
  userId    Int
  productId Int

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // ✅ Prevent duplicate wishlist entries
}

// --------------------------------------------------------------------
// APPOINTMENT TABLE
// --------------------------------------------------------------------
model Appointment {
  id   Int      @id @default(autoincrement())
  date DateTime
  time String
}
